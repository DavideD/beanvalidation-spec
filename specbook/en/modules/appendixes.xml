<appendix id="standard-resolver-messages">
    <title>Standard ResourceBundle messages</title>

    <para>The properties listed below are resolved by the default message
    interpolator.</para>

    <programlisting>javax.validation.constraints.Null.message=must be null
javax.validation.constraints.NotNull.message=must not be null
javax.validation.constraints.AssertTrue.message=must be true
javax.validation.constraints.AssertFalse.message=must be false
javax.validation.constraints.Min.message=must be greater than or equal to {value}
javax.validation.constraints.Max.message=must be less than or equal to {value}
javax.validation.constraints.Size.message=size must be between {min} and {max}
javax.validation.constraints.Digits.message= \
    numeric value out of bounds (&lt;{integer} digits&gt;.&lt;{fraction} digits&gt; expected)
javax.validation.constraints.Past.message=must be a past date
javax.validation.constraints.Future.message=must be a future date
javax.validation.constraints.Pattern.message=must match the following regular expression: {regexp}</programlisting>
  </appendix>

  <appendix id="appendix-methodlevelvalidation">
    <title>Proposal for method-level validation</title>

    <para>This proposition has not been integrated into the core specification
    and is not part of it. It remains here for archaeological purposes and
    will be seriously considered for a future revision of this specification.
    This proposal is likely to be a bit out of sync with the rest of the
    specification artifacts.</para>

    <note>
      <para>Bean Validation providers are free to implement this proposal as a
      specific extension. Such specific extension could for example be
      accessed via the use of the <methodname>Validator.unwrap</methodname>
      method.</para>
    </note>

    <para>A popular demand was to provide a method and parameter level
    validation mechanism reusing the constraint descriptions of the
    specification. This set of APIs is meant to be used by interceptor
    frameworks such as:</para>

    <itemizedlist>
      <listitem>
        <para>application frameworks like JSR-299</para>
      </listitem>

      <listitem>
        <para>component frameworks like Enterprise Java Beans</para>
      </listitem>

      <listitem>
        <para>aspect based frameworks</para>
      </listitem>
    </itemizedlist>

    <para>These frameworks can call the validation APIs to validate either the
    parameter list or the returned value of a method when such method is
    called. More precisely, validation occurs around a method
    invocation.</para>

    <para>This extension of the Bean Validation API allows to reuse the core
    engine as well as the constraint definition and declaration for such
    method level validations.</para>

    <para>The following APIs are added to
    <classname>Validator</classname>.</para>

    <programlisting>public interface Validator {
    // [...]
    
    
    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the method for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if the Object[] does not match the method signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(Class&lt;T&gt; clazz, Method method,
                                                       Object[] parameterValues,
                                                       Class&lt;?&gt;... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the parameterIndex-t parameter of method
     * @param parameterIndex parameter index of the parameter validated in method
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Method method,
                                                   Object parameterValue,
                                                   int parameterIndex, Class&lt;?&gt;... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose result is validated
     * @param returnedValue the value returned by the method invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateReturnedValue(Class&lt;T&gt; clazz, Method method,
                                                       Object returnedValue, Class&lt;?&gt;... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the constructor whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the constructor for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if the Object[] does not match the constructor signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameters(Class&lt;T&gt; clazz, Constructor constructor,
                                                    Object[] parameterValues, Class&lt;?&gt;... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the
     *                       parameterIndex-th parameter of constructor
     * @param parameterIndex parameter index of the parameter validated in constructor
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Constructor constructor,
                                                   Object parameterValue, int parameterIndex,
                                                   Class&lt;?&gt;... groups);</programlisting>

    <para>The constraints declarations evaluated are the constraints hosted on
    the parameters of the method or constructor. If
    <classname>@Valid</classname> is placed on a parameter, constraints
    declared on the object itself are considered.</para>

    <para><methodname>validateReturnedValue</methodname> evaluates the
    constraints hosted on the method itself. If <classname>@Valid</classname>
    is placed on the method, the constraints declared on the object itself are
    considered.</para>

    <programlisting>public @NotNull String saveItem(@Valid @NotNull Item item, @Max(23) BigDecimal price)</programlisting>

    <para>In the previous example,</para>

    <itemizedlist>
      <listitem>
        <para><literal>item</literal> is validated against
        <classname>@NotNull</classname> and all the constraints it
        hosts</para>
      </listitem>

      <listitem>
        <para><literal>price</literal> is validated against
        <classname>@Max(23)</classname></para>
      </listitem>

      <listitem>
        <para>the result of <methodname>saveItem</methodname> is validated
        against <classname>@NotNull</classname></para>
      </listitem>
    </itemizedlist>

    <para>Note that the Bean Validation specification does not trigger the
    validation call. An external framework is responsible for calling one of
    the <methodname>validateParameters</methodname>,
    <methodname>validateParameter</methodname> and
    <methodname>validateReturnedValue</methodname> methods at the appropriate
    time.</para>

    <para>For completeness, Bean Validation exposes metadata for constraints
    hosted on parameters and methods.</para>

    <programlisting>public interface ParameterDescriptor extends ElementDescriptor { 
    boolean isCascaded(); 
    int getIndex(); 
} 

public interface MethodDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
    boolean isCascaded(); 
} 

public interface ConstructorDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
} 

public interface BeanDescriptor { 
    MethodDescriptor getConstraintsForMethod(Method); 
    MethodDescriptor getConstraintsForConstructor(Constructor); 
    Set&lt;String&gt; getConstrainedProperties(); 
    Set&lt;Method&gt; getConstrainedMethods(); 
    Set&lt;Constructor&gt; getConstrainedConstructors(); 
} </programlisting>
  </appendix>

  <appendix id="appendix-jpa">
    <title>Java Persistence 2.0 integration</title>

    <para>Integration with Java Persistence is described in the Java
    Persistence 2 specification (JSR-317). Persistence frameworks are
    encouraged to mimic the integration work done with Java
    Persistence.</para>

    <para>While not specified by this specification or the Java Persistence
    2.0 specification, Persistence Providers are encouraged to make use of
    Bean Validation constraint metadata when generating DDL schemas. The
    proposal is as followed.</para>

    <programlisting>Ideas explored and not standardized

Java Persistence consumes Bean Validation (BV) metadata to enhance persistence property 
metadata.

A Persistence provider must use the BV metadata of a given list of groups. 
The default group evaluated is Default (default BV group). Groups evaluated 
can be overridden by a property. 
This property contains the comma separated groups (fully qualified class name).

For each entity, apply the following algorithm. 
For each persistent property in a given entity: 
 - extract the list of BV constraints (including the composing constraints) 
 - determine the subset of applicable constraints 
    (i.e. constraints understood by the persistence provider)
 - apply these constraints on the persistent property metadata 
 - if the property type is an embeddable object or a collection 
of embeddable objects, apply the algorithm on the embeddable object properties

The list of constraints that must be understood by persistence providers are
as followed:
 - @NotNull should be considered equivalent to @Column(nullable=false) / 
     @JoinColumn(nullable=false)
 - @Size.max should be considered equivalent to @Column.length 
     for String properties 
 - @Digits (which contains integer and fraction) should be considered 
     equivalent to @Column.precision = integer+fraction, 
     @Column.scale = fraction for decimal columns

The BV annotation metadata should have priority over JPA metadata 
(JPA has no sensible "unset" values on their annotations).

Question: should we add @Unique that would map to @Column(unique=true)? 
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part 
of the BV spec today.

Persistence Provider should optionally recognize and try to apply the 
following constraints as well:
 - @Min / @Max on numeric columns (TODO String too?)
 - @Future / @Past on temporal columns
 - @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model. 
For example, provider ACME might recognize and understand @com.acme.validation.Email 
and apply it to the database model.

While most high level constraints will not be recognize, the BV built-in constraints 
will be the common language spoken by Persistence Providers. Any high level constraint 
can be composed of more modular constraints (constraint composition).

* additional proposal
In case of a constraint violation report detected and generated by the database 
(not null, etc), the Java persistence provider catches this report and translates 
it into a BV error report. From the perspective of the application, constraint 
errors are viewed through a unified layer. BV must provide some API to create a 
constraint violation error (constraintDescriptor.createConstraintViolation(...)).

While this proposal has a lot of value-add, I wonder how difficult it can be to 
implement this in persistence providers.

Provide a way to disable BV metadata use by a persistence provider (property based).</programlisting>

    <para>This is not an endorsement of the Java Persistence expert group or
    the Bean Validation expert group. Such approach may nor may not be
    standardized in the future. Such integration should not be considered
    portable.</para>
  </appendix>

  <appendix id="appendix-jsf">
    <title>Java Server Faces 2.0 integration</title>

    <para>Integration with Java Server Faces is described in the Java Server
    Faces 2 specification (JSR-314). Presentation frameworks are encouraged to
    study the integration work done with JSF 2.</para>
  </appendix>

  <appendix id="appendix-ee">
    <title>Proposal for Java EE integration</title>

    <para>This proposal is being discussed with the EE expert group. It
    proposes a way to smoothly integrates Bean Validation to the platform.
    This proposition is the result of the work done on JSF and JPA
    integrations.</para>

    <para>Java Persistence and Java Server Faces have deep integration
    proposals with Bean Validation. Java EE Connector Architecture uses Bean
    Validation to validate particular artifacts.</para>

    <para></para>

    <para></para>

    <para>TODO: This section is outdated. See the latest version in the Java
    EE 6 specification.</para>

    <para><classname>Validator</classname> and
    <classname>ValidatorFactory</classname> are very good candidates for
    injectable Java EE resources (<classname>ValidatorFactory</classname> is
    responsible for providing <classname>Validator</classname> instances which
    executes the validation logic). To tie everything together in a unified
    way for the Java EE application developer, some integration at the Java EE
    level would be beneficial.</para>

    <para>A <classname>ValidatorFactory</classname> is built by the EE
    container and exposed to applications as well as services like JPA, JSF
    and Java EE Connectors (this imply a
    <classname>ValidatorFactory</classname> must be built and ready before
    these services). While not required, it is recommended to cache and share
    the same <classname>ValidatorFactory</classname> for a given deployment
    unit. <emphasis>Should we mandate it?</emphasis>.</para>

    <para>The container passes the <classname>ValidatorFactory</classname>
    instance to the JPA provider via the configuration Map of
    <code>PersistenceProvider.createContainerEntityManagerFactory(PersistenceUnitInfo,
    Map)</code>. The property name is
    <literal>javax.persistence.validation.factory</literal>
    (<literal>Persistence.VALIDATOR_FACTORY</literal>).</para>

    <para>The container places the <classname>ValidatorFactory</classname>
    instance under the following JNDI name. JSF 2 implementations are required
    to look in this entry for any <classname>ValidatorFactory</classname> and
    use it.</para>

    <para>In addition, <classname>Validator</classname> and
    <classname>ValidatorFactory</classname> should be considered as Java EE
    resources: injection aware services should allow injection of
    <classname>Validator</classname> instances as well as
    <classname>ValidatorFactory</classname> instances.
    <classname>@Resource</classname> is used for this. If
    <classname>Validator</classname> instances are injected, the default
    validation context is used. In other words,
    <classname>Validator</classname> are provided by
    <code>validatorFactory.getValidator()</code>. The factory is available for
    the lifetime of the deployment.</para>
  </appendix>