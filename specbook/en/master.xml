<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <title>JSR 303: Bean Validation</title>

  <bookinfo>
    <title>JSR 303: Bean Validation</title>

    <releaseinfo>1.0.Alpha.20071012</releaseinfo>

    <date>2007-10-12</date>

    <copyright>
      <year>2007</year>

      <holder>Red Hat Middleware, LLC (to be adjusted but for now...)</holder>
    </copyright>

    <authorgroup>
      <corpauthor>Bean Validation Expert Group</corpauthor>

      <author>
        <firstname>Emmanuel</firstname>

        <surname>Bernard</surname>

        <affiliation>
          <orgname>Red Hat Middleware, LLC</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <legalnotice>
      <para>All right reserved, do not distribute outside the JSR 303 expert
      group.</para>
    </legalnotice>
  </bookinfo>

  <preface>
    <title>License</title>

    <para>All right reserved, do not distribute outside the JSR 303 expert
    group.</para>
  </preface>

  <chapter>
    <title>Introduction</title>

    <para>This document is the specification of the Java API for the JavaBean
    validation with Java EE and Java SE. The technical objective of this work
    is to provide an object level constraint declaration and validation
    facility for the Java application developer, as well as a metadata
    repository and querying API for such constraints repository.</para>

    <section>
      <title>Expert group</title>

      <para>This work is being conducted as part of JSR-303 under the Java
      Community Process Program. This specification is the result of the
      collaborative work of the members of the JSR 303 Expert Group. These
      include the following present and former expert group members: Red Hat
      Middleware LLC: Emmanuel Bernard, TBD corp, Jason Carreira, TBD
      individuals.</para>
    </section>

    <section>
      <title>Document conventions</title>

      <para>Sigh...</para>
    </section>

    <section>
      <title>Specification goals</title>

      <para>Validating data is a common task that is duplicated in many
      different layers of an application, from the presentation tier to the
      persistence layer. Many times the exact same validations will have to be
      implemented in each separate validation framework, proving time
      consuming and error-prone. To prevent having to re-implement these
      validations at each layer, many developers will bundle validations
      directly into their classes, cluttering them with copied validation code
      that is, in fact, meta-data about the class itself.</para>

      <para>This JSR defines a meta-data model and API for JavaBean
      validation. The default meta-data source is annotations, with the
      ability to override and extend the meta-data through the use of XML
      validation descriptors.</para>

      <para>The validation API developed by this JSR is not specific to any
      one tier or programming model. It is specifically not tied to either the
      web tier or the persistence tier, and is available for both server-side
      application programming, as well as rich client Swing application
      developers. This API is seen as a general extension to the JavaBeans
      object model, and as such is expected to be used as a core component in
      other specifications, such as JSF, JPA, Web Beans and Bean
      Binding.</para>
    </section>
  </chapter>

  <chapter>
    <title>Object graph constraints declaration</title>

    <para>The Bean Validation specification aims at defining a framework for
    JavaBeans constraints definition and validation. Constraints can be
    applied to the object itself or to any of the object's fields or
    properties. The primary declaration mechanism is through the use of
    annotations.</para>

    <para>Constraints are defined per object class, and applied on an object
    or object graph instance.</para>

    <section>
      <title>Requirements on objects to be validated</title>

      <para>Objects that are to be validated need to fulfill the following
      requirements.</para>

      <para>Properties holding constraints declaration have to follow the
      JavaBean specification, the object state to be validated will be access
      either through the JavaBeans style property accessor or via attribute
      access. Getters and field visibility are not restricted.</para>

      <para>It is required that the entity class follows the method signature
      conventions for JavaBeans read properties (as defined by the JavaBeans
      Introspector class) for properties holding a constraint
      declaration.</para>

      <para>The objects can support inheritance, interface and
      associations.</para>

      <para>A given constraint declaration can be applied to any field,
      property or type (class) provided that:</para>

      <itemizedlist>
        <listitem>
          <para>the annotation <classname>TARGET</classname> supports
          it</para>
        </listitem>

        <listitem>
          <para>the constraint validator implementation supports the return
          type of the given field or property, or the object type</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>Object-based validation</title>

        <para>Constraint declarations can be applied on the object type (class
        or interface). In such case, the state to be validated is the object
        instance itself.</para>
      </section>

      <section>
        <title>field-based and property-based validation</title>

        <para>TODO adapt EJB3 2.1.1?</para>

        <para>Constraint declarations can be applied on both fields and
        properties for the same object type. The same constraint should
        however not be duplicated between a field and its associated property
        (the validation rule would be applied twice). It is recommended for
        objects holding constraint declarations to adhere a single state
        access strategy (either annotated fields or properties).</para>

        <para>When a field is annotated with a constraint definition, field
        access strategy will be used to access the state validated by such
        constraint.</para>

        <para>When a property is annotated with a constraint definition,
        property access strategy will be used to access the state validated by
        such constraint.</para>
      </section>

      <section>
        <title>Associated objects validation</title>

        <para>An object B associated to a object A can be requested to be
        validated by cascade when object A is validated: validation by cascade
        means that object B's bean, field and method constraint have to be
        validated. Object B is accessed through the previously describe
        mechanisms. Association is defined as an object field or property
        referencing another object, or as an object field or property
        referencing a collection or array of objects. The cascading behavior
        is defined statically at the field or property level through
        annotation.</para>

        <para>Collection-valued or array-valued fields and properties can hold
        constraint declarations, in this case the validated state is the
        collection or the array.</para>

        <para>If cascade validation is requested on such a field or property,
        all the objects contained in the collection-valued or array-valued
        field or property will be validated. Collection-valued fields and
        properties targeted for cascaded validation must be defined in terms
        of one of the following collection-valued interfaces regardless of
        whether the entity class otherwise adheres to the JavaBeans method
        conventions noted above and whether field or property-based access is
        used: <classname>java.util.Collection</classname>,
        <classname>java.util.Set</classname>,
        <classname>java.util.List</classname>,
        <classname>java.util.Map</classname>.</para>
      </section>
    </section>

    <section>
      <title>Constraint declaration</title>

      <para>Constraint declarations are defined on classes (or interfaces see
      XXX), primarily through annotations. The annotation target dictates
      which piece of data is validated. A constraint annotation (see XXX
      constraint definition), can be applied on the object type itself (class
      level), on any of the object fields or on any of the JavaBeans compliant
      properties.</para>

      <para>When a constraint declaration is set on the object type (class
      level), the object being validated is passed to the validation routine
      associated to the constraint. When a constraint declaration is set on a
      field, the field value is passed to the validation routine. When a
      constraint declaration is set on a getter, the result of the getter
      invocation is passed to the validation routine.</para>
    </section>

    <section>
      <title>Bean validation routine</title>

      <para>To validate a given bean, the Bean Validation provider is expected
      to execute the constraint validations in the following order:</para>

      <itemizedlist>
        <listitem>
          <para>execute all class level validations matching the requested
          groups (or the default group if none are explicitly
          requested)</para>
        </listitem>

        <listitem>
          <para>execute all field level validations matching the requested
          groups (or the default group if none are explicitly requested) and
          the cascading validation if necessary (see below)</para>
        </listitem>

        <listitem>
          <para>execute all getter level validations matching the requested
          groups (or the default group if none are explicitly requested) and
          the cascading validation if necessary (see below)</para>
        </listitem>
      </itemizedlist>

      <para>The object validation routine is described as such. For each
      constraint declaration and in the previously defined order:</para>

      <itemizedlist>
        <listitem>
          <para>execute the <methodname>isValid</methodname> operation
          (validation routine) on the appropriate data (see XXX)</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns true, continue to
          the next constraint,</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns false, the Bean
          Validation provider populate an
          <classname>InvalidConstraint</classname> object and queue it for
          return</para>
        </listitem>

        <listitem>
          <para>if the failing constraint declaration is shortcircuit = true,
          or if there is no more constraint declaration to process, return all
          the <classname>InvalidConstraint</classname> objects</para>
        </listitem>

        <listitem>
          <para>otherwise, continue to the next constraint</para>
        </listitem>
      </itemizedlist>

      <para>TBD: are short-circuited elements prioritized over non
      short-circuited ones? If yes, inside their target or global? And what
      about cascaded validation</para>

      <section>
        <title>Object graph validation</title>

        <para>The Bean Validation specification supports the ability to
        validate associated objects (object graph) by cascade. Instead of
        manually validating several related (associated) objects one by one, a
        unified list of invalid values is returned in a single
        operation.</para>

        <para>The <classname>@Valid</classname> annotation on a given
        association (ie object reference or collection / array of objects),
        dictates the Bean Validator implementation to apply recursively the
        bean validation routine on (each of) the associated object(s) when the
        field or the getter is processed. This mechanism is recursive: an
        associated object can itself contains cascaded references. The Bean
        Validation implementation must ignore the cascading operation if the
        associated object instance has already been validated by the current
        validation routine, thus preventing infinite loops.</para>

        <para>The <classname>InvalidConstraint</classname> objects, built when
        a failing constraint on an associated object is found, reflects the
        path to reach the object from the root validated object (See
        XXX).</para>
      </section>
    </section>

    <section>
      <title>Inheritance (interface and superclass)</title>

      <para>A constraint declaration can be defined on an interface.
      Constraint declarations held on superclasses (recursively) as well as
      interfaces (or super interfaces recursively) have to be honored by the
      constraint validation routine. Constraints declared on the superclasses
      have to be checked before the constraints declared on the subclasses.
      Constraints declared on interfaces have to be checked before constraints
      declared on the implementation class. Ordering between constraints from
      different interfaces is undefined.</para>

      <para>TBD: should we do all superclass before subclasses or all bean
      level super classes before bean level subclasses and so on for fields
      and methods</para>

      <para>The constraints are additive. This especially means that
      constraints declared on a superclass getter will be checked as well as
      any constraints defined on an overridden version of the getter.</para>
    </section>
  </chapter>

  <chapter>
    <title>Constraints definition</title>

    <para>Constraints are defined through annotations. Constraint annotations
    can be held at the field level, property level as well as the JavaBean
    level (ie class level).</para>

    <section>
      <title>Constraint declaration</title>

      <para>A constraint is expressed through annotations. An annotation is
      considered a constraint definition if its retention policy contains
      <literal>RUNTIME</literal> and if the annotation itself is annotated
      with <literal>javax.validation.ValidatorClass</literal>. The annotation
      target can be <literal>FIELD</literal>, <literal>METHOD</literal> and/or
      <literal>TYPE</literal>.</para>

      <para>A given constraint usually targets one or several specific types
      (eg a String length validation constraint targets String objects): the
      constraint annotation JavaDoc should clearly state which type the
      validation routine supports. Using a constraint on an incompatible type
      is considered an development error.</para>

      <section>
        <title>Parameters</title>

        <para>A constraint definition can have several parameters that a user
        can (or might have to) define when using the constraint. The
        parameters are mapped as annotation parameters. Parameters can be on
        any type supported by annotations. The parameter names can be anything
        but <literal>message</literal>, <literal>shortcircuit</literal> and
        <literal>groups</literal>.</para>

        <para>TBD Any other name to exclude? Like valid-*</para>

        <section>
          <title>message</title>

          <para><literal>message</literal> is a String parameter that any
          constraint annotation must implement.</para>

          <programlisting>    String message() default "{beancheck.myConstraintFailure}";</programlisting>

          <para>The <methodname>message</methodname> parameter value will be
          used to build the (localized) error message, see XXX for more
          information.</para>
        </section>

        <section>
          <title>groups</title>

          <para><literal>groups</literal> is an optional parameter describing
          the group(s) the constraint declaration belongs to. If no group is
          defined or if the annotation does not have a
          <literal>groups</literal> parameter defined, the
          <literal>default</literal> group is used. The validation will be
          applied if one or more requested group is matching one or more
          constraint declaration groups. See XXX.</para>
        </section>

        <section>
          <title>shortcircuit</title>

          <para>This parameter is a boolean defaulted to false. When a
          validation failure happens for the given constraint, the Bean
          Validation provider stop executing the validation process and return
          immediately if <parameter>shortcircuit</parameter> is true.
          Otherwise the next constraints are processed. See XXX.</para>
        </section>

        <section>
          <title>Constraint specific parameter</title>

          <para>The constraint annotation can support any additional
          parameters needed to refine the way the constraint will be applied.
          Those parameters will be provided to the constraint validation
          implementation by the Bean Validation provider.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Multiple constraint declarations of the same type</title>

      <para>It is sometimes useful to apply the same constraint type (ie same
      annotation type) twice on the same target. <literal>@Pattern</literal>
      (constraint based on a regular expression) is an example, the use of
      different constraint parameters for different groups is another
      example.</para>

      <para>To allow that, annotations declared on a type, field or property
      whose <literal>value</literal> parameter is an array of constraint
      annotations and whose retention is <literal>RUNTIME</literal> should be
      processed by the Bean Validation implementation so that each individual
      constraint annotation (from <literal>value</literal> array) are applied
      on the target (field, getter or class).</para>

      <programlisting>@Documented
@ValidatorClass(PatternValidator.class)
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Pattern {
    /** regular expression */
    String regex();

    /** regular expression processing flags */
    int flags() default 0;

    String message() default "{validator.pattern}";
}

@Documented
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Patterns {
    Pattern[] value();
}</programlisting>

      <programlisting>public class Engine {
    @Patterns( {
            @Pattern(regex = "^[A-Z0-9-]+$", message = "must contain alphabetical characters only"),
            @Pattern(regex = "^....-....-....$", message="must match ....-....-....")
            } )
    private String serialNumber;
}</programlisting>

      <para>In this example, both constraints (<literal>^[A-Z0-9-]+$</literal>
      and <literal>^....-....-....$</literal>) will be applied on the
      <literal>serialNumber</literal> field.</para>
    </section>

    <section>
      <title>Constraint validator implementation</title>

      <para>A constraint validator implementation class, for a given
      constraint is described by the <parameter>value</parameter> parameter of
      <classname>javax.validation.ValidatorClass</classname> held by the
      constraint annotation</para>

      <para>A constraint validator implementation implements the following
      interface</para>

      <programlisting>/**
 * Define the logic to validate a given constraint
 *
 * @author Emmanuel Bernard
 */
public interface Constraint {
    /**
     * Validator parameters for a given constraint definition
     * Annotations parameters are passed as key/value into parameters
     *
     * @param parameters parameters for a given constraint definition
     * FIXME should it be the actual annotation passed (using generics Validator&lt;A extends Annotation&gt;
     * FIXME it would provide type safety, but complicate (slightly) the code for XML parsing
     * FIXME ebernard +1 for the change
     */
    void initialize(Map parameters);
    /**
     * Implement the validation constraint
     *
     * @param object object to validate
     * @return true if object pass the constraint
     */
    boolean isValid(Object object);
}</programlisting>

      <para>The <methodname>isValid</methodname> implementation has to assume
      it will be called concurrently, it has to be thread-safe in that
      respect.</para>

      <para>The lifecycle of a constraint implementation instances are
      undefined, but the Bean Validation provider guaranties that the
      constraint validation implementation used for a given constraint
      definition has been initialized with the constraint definition
      parameters. TODO: are we OK for such a constraint? reusing the
      implementation make sense?</para>

      <para><methodname>isValid</methodname> will be executed by the Bean
      Validation provider each time a given state needs to be validated
      against the associated constraint. <literal>true</literal> must be
      returned if the object validate the constraint, <literal>false</literal>
      otherwise.</para>

      <note>
        <para>While not mandatory, it is considered a good practice to split
        the core constraint validation from the object nullability (for
        example, an @Email constraint will return true on a null object, ie
        will not take care of the @NotNull validation)</para>
      </note>

      <para>If the Constraint validation routine retrieve an object of an
      unexpected type an <literal>IllegalArgumentException</literal> should be
      raised.</para>
    </section>

    <section id="constraintsdefinition-standardconstraint">
      <title>StandardConstraint description</title>

      <para>Constraint metadata can be consumed through the <xref
      linkend="constraint-metadata" />. In addition to their
      <classname>Constraint</classname> inmplementation, built-in and custom
      constraint validators can describe the constraint through some static
      and standard dimensions (such as nullability, length for a String etc).
      Such metadata are particularly useful for third-party metadata consumers
      like persistence frameworks generating database schemas (such as Java
      Persistence) or presentation frameworks.</para>

      <para>Any constraint validator can implement the
      <classname>StandardConstraint</classname> interface to express such
      static dimensions.</para>

      <programlisting>/**
 * Define the constraint influence on standard constraints
 *
 * @author Emmanuel Bernard
 */
public interface StandardConstraint {
    /**
     * returns the StandardConstraintDescriptor initialized according to the
     * constraint validator
     */
    StandardConstraintDescriptor getStandardConstraints();
}

/**
 * Describe how the current constraint influences the standard constraints
 *
 * @author Emmanuel Bernard
 */
public class StandardConstraintDescriptor {
    /**
     * Defines the object nullability.
     * TRUE means the object is nullable,
     * FALSE means the object is not nullable
     * NULL means unaffected.
     */
    public Boolean getNullability() {
        return null;
    }

    /**
     * Defines the precision if the validated object is a number.
     * NULL means unaffected
     */
    public Integer getPrecision() {
        return null;
    }

    /**
     * Defines the scale if the validated object is a number.
     * NULL means unaffected
     */
    public Integer getScale() {
        return null;
    }

    /**
     * Defines the length if the validated object is a string.
     * NULL means unaffected
     */
    public Boolean getLength() {
        return null;
    }
}</programlisting>

      <para>TODO: should we expand the list? Up to which level.</para>

      <para>TODO should we explicitely allow "proprietary" extensions based on
      the same model (ie a specific interface implemented by the constraint
      implementation and providing proprietary dimensions? Another extension
      possibility is to subclass StandardConstraintDescriptor by a
      "proprietary" subclass.</para>
    </section>
  </chapter>

  <chapter>
    <title>Validation APIs</title>

    <para>TODO make something to smooth that. Validation.createValidator(Class
    type)??</para>

    <para>TODO make something to smooth that. Validation.createValidator(Class
    type)??</para>

    <para>The default package for the Bean Validation APIs is
    <classname>javax.validation</classname>.</para>

    <section>
      <title>Validator&lt;T&gt; API</title>

      <para>The main Bean Validation API is the
      <classname>javax.validation.Validator&lt;T&gt;</classname> interface and
      the Bean Validation provider implementation. The besides implementing
      the Validator&lt;T&gt; API, the Bean Validation provider implementation
      class must have a constructor Constructor(Class&lt;T&gt;).</para>

      <para>A Validator&lt;T&gt; instance is able to validate instances of T
      classes (and the associated objects if any). It is recommended to cache
      Validator&lt;T&gt; instances. The Bean Validation provider has to
      guarantee that concurrent, multi-threaded access to a Validator&lt;T&gt;
      implementation is safe.</para>

      <programlisting>/**
 * Validate a given object type
 *
 * FIXME should Serializable be part of the definition.
 * 
 * @author Emmanuel Bernard
 */
public interface Validator&lt;T&gt; extends Serializable {
    /**
     * validate all constraints on object (unless shortcutted)
     *
     * @param object object to validate
     * @param groups group name(s) targeted for validation (default to &lt;code&gt;default&lt;/code&gt;
     * @return array of invalid constrains or an empty array if none
     * @throws IllegalArgumentException e if object is null TODO should it just be ignored?
     */
    InvalidConstraint[] validate(T object, String... groups);

    /**
     * validate all constraints on propertyname property of object (unless shortcutted)
     *
     * TODO do we keep it?
     *
     * @param object object to validate
     * @param propertyName property to validate
     * @param groups group name(s) targeted for validation (default to &lt;code&gt;default&lt;/code&gt;
     * @return array of invalid constrains or an empty array if none
     * @throws IllegalArgumentException e if object is null TODO should it just be ignored?
     */
    InvalidConstraint[] validateProperty(T object, String propertyName, String... groups);

    /**
     * validate all constraints on propertyname property if the property value is value
     *
     * FIXME do we keep it?
     * TODO express limitations of InvalidConstraint in this case
     *
     * @param propertyName property to validate
     * @param value property value to validate
     * @param groups group name(s) targeted for validation (default to &lt;code&gt;default&lt;/code&gt;
     * @return array of invalid constrains or an empty array if none
     */
    InvalidConstraint[] validateValue(String propertyName, Object value, String... groups);

    [...]

}</programlisting>

      <para>TODO do something to smooth that. Validation.createValidator(Class
      type)??</para>

      <section>
        <title>validate an object</title>

        <para><methodname>InvalidConstraint[] validate(T object, String...
        groups)</methodname> is used to validate a given object of type T from
        a Validator&lt;T&gt; instance. An array of
        <classname>InvalidConstraint</classname> is returned.</para>

        <para><methodname>InvalidConstraint[] validate(T object, String
        propertyName, String... groups)</methodname> validates a given field
        or property of a given object. The property name is the JavaBeans
        property name (as defined by the JavaBeans Introspector class). This
        method is useful for partial object validation. TODO do we keep it?
        TODO should we ignore @Valid for such methods?</para>

        <para><methodname>InvalidConstraint[] validateValue(String
        propertyName, Object value, String... groups)</methodname> validate
        the property referenced by <parameter>propertyName</parameter>, if the
        property value were <parameter>value</parameter>. This method is
        useful for ahead of time validation. TODO do we keep it? TODO should
        we ignore @Valid for such methods?</para>

        <para>The (list of) group(s) restricts the constraints applied. Only
        the constraints targeting (see XXX group parameter) one or more of the
        group(s) passed as a parameter will be applied. If no group is passed,
        the <literal>default</literal> group is assumed.</para>

        <programlisting>public class Address {
    @NotEmpty(groups = "minimal")
    @Length(max=50)
    private String street1;
    
    @NotEmpty
    private String city;

    @NotEmpty(groups = {"minimal", "default"})
    private String zipCode;
    ...
}</programlisting>

        <para>In the previous example, @NotEmpty on street1 applies to the
        group minimal, @Length on street1 applies to the group default and
        @NotEmpty on zipCode applies to the groups default and minimal.</para>

        <programlisting>validator.validate(address);</programlisting>

        <para>applies @Length on street1, @NotEmpty on city, @NotEmpty on
        zipCode. Particularly, @NotEmpty on street1 is not applied.</para>

        <programlisting>validator.validate(address, "minimal");</programlisting>

        <para>applies @NotEmpty on street1 and @NotEmpty on zipCode</para>

        <programlisting>validator.validate(address, "minimal", "default");</programlisting>

        <para>applies @NotEmpty and @Length on street1, @NotEmpty on city,
        @NotEmpty on zipCode.</para>
      </section>
    </section>

    <section>
      <title>InvalidConstraint</title>

      <para><classname>InvalidConstraint</classname> is the class describing a
      single constraint failure. An array of InvalidConstraint is returned
      from an object validation.</para>

      <programlisting>/**
 * Describe a constraint validation defect
 *
 * FIXME the rational behind rootBean and propertyPath is to keep the context available to the user
 * TODO add pointers to the metadata? 
 *
 * @author Emmanuel Bernard
 */
public interface InvalidConstraint {
    
    /**
     * Error message
     */
    String getMessage();

    /**
     * Root bean being validated validated
     */
    Object getRootBean();

    /**
     * Bean type being validated
     */
    Class getBeanClass();

    /**
     * the value failing to pass the constraint
     */
    Object getValue();

    /**
     * the property path to the value from &lt;code&gt;rootBean&lt;/code&gt;
     * Null if the value is the rootBean itself
     */
    String getPropertyPath();

    /**
     * return the list of groups that the triggered constraint applies on and witch also are
     * within the list of groups requested for validation
     */
    String[] getGroups();

}</programlisting>

      <para><methodname>message</methodname> return the expanded (localized)
      message for the failing constraint (See XXX) for more
      information.</para>

      <para><methodname>rootBean</methodname> returns the root object being
      validated that leaded to the failing constraint (ie the object the
      client code passed to the <methodname>Validator.validate</methodname>
      method.</para>

      <para><methodname>beanClass</methodname> returns the type of the current
      bean being validated and leading to the failure.</para>

      <para><methodname>value</methodname> returns the value (field, property
      or validated object) being passed to <methodname>isValid</methodname>
      and returning false.</para>

      <para><methodname>propertyPath</methodname> is defined by the following
      rules:</para>

      <itemizedlist>
        <listitem>
          <para>if the constraint is a class level constraint, then the empty
          string is used</para>
        </listitem>

        <listitem>
          <para>if the constraint is a field level constraint, the field name
          is the propertyPath</para>
        </listitem>

        <listitem>
          <para>if the constraint is a property, the JavaBeans property name
          (as defined by the JavaBeans Introspector class) is the
          propertyPath</para>
        </listitem>

        <listitem>
          <para>if an associated object is validated, add the association
          field or JavaBeans property name and a dot ('.') as a prefix to the
          previous rules. This rule is recursive.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>From <methodname>rootBean</methodname> and
        <methodname>propertyPath</methodname>, it is possible to rebuild the
        context of the failure</para>
      </note>

      <para>groups returns the intersection of the groups the triggered
      constraint applies on and the groups requested for validation.</para>
    </section>

    <section>
      <title>Message</title>

      <para>The default message resolver can resolve properties based on a
      user defined <filename>/ValidationMessages.properties</filename> file
      (which supports properties localization) backed up by a Bean Validation
      provider embedded property file.</para>

      <para>The error message for a given constraint failure is built from the
      following rules:</para>

      <orderedlist>
        <listitem>
          <para>the message string is taken from the
          <parameter>message</parameter> parameter of the currently failing
          constraint (while defaulted, such a message can be overridden by the
          user through the constraint annotation) See XXX</para>
        </listitem>

        <listitem>
          <para>any <literal>{property}</literal> pattern (open bracket -
          property name - close bracket) is extended to the value of property
          in the constraint parameters if such a parameter name is present,
          otherwise it is ignored</para>
        </listitem>

        <listitem>
          <para>any <literal>{property}</literal> pattern is extended from the
          matching name in <filename>/ValidationMessages.properties</filename>
          if such a property is present in the properties file. If not,
          <literal>{property}</literal> is extended from the matching name in
          the Bean Validation provider embedded property file.</para>
        </listitem>

        <listitem>
          <para>step 2 and 3 are executed until no more matching can be found
          for step 2 and 3 in a row.</para>
        </listitem>
      </orderedlist>

      <para>It is possible to plug a custom message resolver implementation
      (for example to resolve contextual data, or to adjust the Locale used).
      A message resolver implementation must implement the following
      interface:</para>

      <programlisting>/**
* Interpolate a given validation message
*
* @author Emmanuel Bernard
*/
public interface MessageResolver {
    /**
     * Interpolate the message from the constraint parameters (annotation)
     */
    String interpolate(String message, ConstraintDescriptor constraintDescriptor);
}</programlisting>

      <para><parameter>message</parameter> is the raw unresolved message as
      seen in <literal>@Annotation.message</literal>,
      <parameter>constraintDescriptor</parameter> is the
      <classname>ConstraintDescriptor</classname> object representing the
      metadata of the failing constraint (see <xref
      linkend="constraint-metadata" />). Every time a constraint is failing,
      the final message is resolved calling
      <methodname>MessageResolver.interpolate()</methodname>.</para>

      <para>A message resolver implementation is expected to be
      threadsafe.</para>

      <para>The message resolver is injected to the validator instance through
      <methodname>validator.setMessageResolver(MessageResolver)</methodname>.
      TODO: Define threadsafety rules when switching from one MessageResolver
      to an other.</para>
    </section>
  </chapter>

  <chapter id="constraint-metadata" label=""
           xreflabel="Constraint metadata request API">
    <title>Constraint metadata request APIs</title>

    <para>The Bean Validation specification provides a way to query the
    constraint repository. This API is expected to be used for tooling support
    as well as integration with other frameworks, libraries and JSRs: the Bean
    Validation is expected to be the main object oriented constraint
    declaration repository, whose metadata are consumed by all component
    oriented or domain model oriented frameworks avoiding duplication at the
    platform level (EE or SE).</para>

    <section>
      <title>Validator&lt;T&gt;</title>

      <para>The main API to access all metadata related to a given object is
      <classname>Validator&lt;T&gt;</classname> (see XX for more information
      on how to retrieve a <classname>Validator</classname> instance).</para>

      <para>A <classname>Validator&lt;T&gt;</classname> instance is the
      metadata repository for <parameter>T</parameter> classes. It is
      recommended to cache <classname>Validator&lt;T&gt;</classname>
      instances. The Bean Validation provider has to guarantee that
      concurrent, multi-threaded access to a
      <classname>Validator&lt;T&gt;</classname> implementation is safe.</para>

      <programlisting>/**
 * Describe a contraint validation defect
 *
 * FIXME the rational behind rootBean and propertyPath is to keep the context available to the user
 *
 * @author Emmanuel Bernard
 */
public interface Validator&lt;T&gt; {

    [...]

    /**
     * return true if at least one constraint declaration is present for the given bean
     * or if one property is marked for validation cascade
     */
    boolean hasConstraints();

    /**
     * return the class level constraints
     */
    ElementDescriptor getBeanConstraints();

    /**
     * return the property level constraints for a given propertyName
     * or null if either the property does not exist or has no constraint
     */
    ElementDescriptor getConstraintsForProperty(String propertyName);

    /**
     * return the property names having at least a constraint defined
     */
    String[] getValidatedProperties();

}</programlisting>

      <para><methodname>hasConstraints</methodname> returns true if the given
      <parameter>T</parameter> class has at least one constraint
      declared.</para>

      <para><methodname>getBeanConstraints</methodname> returns an
      <classname>ElementDescriptor</classname> object describing the bean
      level constraints (See XXX).</para>

      <para><methodname>getConstraintsForProperty</methodname> returns an
      <classname>ElementDescriptor</classname> object describing the property
      level constraints (See XXX). The property is uniquely identified by its
      name as per the JavaBeans convention: field level and getter level
      constraints of the given name are all returned.</para>

      <para><methodname>getValidatedProperties</methodname> returns the names
      of the bean properties having at least one constraint or being cascaded
      (<classname>@Valid</classname> annotation)</para>

      <para></para>
    </section>

    <section>
      <title>ElementDescriptor</title>

      <para><classname>ElementDescriptor</classname> is the object used to
      describe the list of constraints for a given element (whether it be a
      field, a method or a class).</para>

      <programlisting>/**
 * Describes a validated element (class, field or property)
 * 
 * @author Emmanuel Bernard
 */
public interface ElementDescriptor {
    /**
     * Element type
     */
    ElementType getElementType();

    /**
     * statically defined returned type
     * //TODO should it be Type or even completly removed
     */
    Class getReturnType();

    /**
     * is the association cascaded
     */
    boolean isCascaded();

    /**
     * all the constraint descriptors for the given element
     */
    ConstraintDescriptor[] getConstraintDescriptors();

    /**
     * Property path from the root entity validated.
     * //FIXME there is a problem in describing cyclic dependencies
     */
    String getPropertyPath();

}</programlisting>

      <para><methodname>getElementType</methodname> returns the
      <classname>java.lang.annotations.ElementType</classname> the constraint
      is declared on. The expected types for the current version of the Bean
      Validation specification are:</para>

      <itemizedlist>
        <listitem>
          <para>TYPE</para>
        </listitem>

        <listitem>
          <para>FIELD</para>
        </listitem>

        <listitem>
          <para>METHOD</para>
        </listitem>
      </itemizedlist>

      <para><methodname>getReturnType</methodname> returns either the object
      type for a class, or the returned type for a property (TODO problem of
      generics resolution).</para>

      <para><methodname>isCascaded</methodname> returns
      <literal>true</literal> of the property is marked with
      <classname>@Valid</classname>. Class level element descriptors always
      return <literal>false</literal>.</para>

      <para><methodname>getPropertyPath</methodname> returns the property path
      as described in XXX (TODO what about circularity)</para>

      <para><classname>getConstraintDescriptors</classname> return an array of
      <classname>ConstraintDescriptor</classname> (see XXX), each
      <classname>ConstraintDescriptor</classname> describing one of the
      constraints declared on the given element.</para>
    </section>

    <section>
      <title>ConstraintDescriptor</title>

      <para>A <classname>ConstraintDescriptor</classname> object describes a
      given constraint declaration (ie a constraint annotation).</para>

      <programlisting>/**
 * describes a single constraint
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintDescriptor {
    /**
     * Constraint declaration annotation
     */
    Annotation getAnnotation();

    /**
     * constraint parameters
     */
    Map&lt;String, Object&gt; getParameters();

    /**
     * Does the constraint enables short circuit
     */
    boolean isShortCircuited();

    /**
     * What are the contexts the constraint is applied on
     */
    String[] getContexts();

    /**
     * Return the constraint implementation routine
     */
    Constraint getConstraintImplementation();
}</programlisting>

      <para><methodname>getAnnotation</methodname> returns the annotation
      instance (or an annotation instance representing the given constraint
      declaration)</para>

      <para><methodname>getParameters</methodname> returns a map containing
      the annotation parameter names as a key, and the annotation parameter
      values as a value (this API is anticipated to be simpler to use by tools
      that reflection over the annotation instance)</para>

      <para><methodname>isShortCircuited</methodname> returns
      <literal>true</literal> if the annotation's
      <parameter>shortCircuit</parameter> parameter (if any) is set to
      <literal>true</literal>.</para>

      <para><methodname>getGroups</methodname> returns the group names, the
      constraint is supposed to be applied upon.</para>

      <para><methodname>getConstraintImplementation</methodname> returns the
      initialized and ready to use
      <classname>javax.validator.Constraint</classname> implementation for the
      given constraint declaration. Specifically, the
      <classname>StandardConstraintDescriptor</classname> is available if the
      constraint validator implements
      <classname>StandardConstraint</classname> (see <xref
      linkend="constraintsdefinition-standardconstraint" />).</para>

      <para>TODO should ConstraintDescriptor points back to
      ElementDescriptor?</para>
    </section>
  </chapter>

  <chapter>
    <title>Metadata descriptors</title>

    <section>
      <title>Annotations</title>

      <para></para>
    </section>

    <section>
      <title>XML descriptor</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>TODOs</title>

    <para>Talk about XML</para>

    <para>Port my TODO list to this chapter :)</para>

    <para>Provide some examples in the spec</para>

    <para>What about chapter reordering, specifically put chapter 3
    (definition) before chapter 2 (declaration and lifecycles)</para>
  </chapter>
</book>