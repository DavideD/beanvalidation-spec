<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <title>JSR 303: Bean Validation</title>

  <bookinfo>
    <title>JSR 303: Bean Validation</title>

    <releaseinfo>1.0.Alpha.20070614</releaseinfo>

    <date>2007-06-14</date>

    <copyright>
      <year>2007</year>

      <holder>Red Hat Middleware, LLC (to be adjusted but for now...)</holder>
    </copyright>

    <authorgroup>
      <corpauthor>Bean Validation Expert Group</corpauthor>

      <author>
        <firstname>Emmanuel</firstname>

        <surname>Bernard</surname>

        <affiliation>
          <orgname>Red Hat Middleware, LLC</orgname>
        </affiliation>
      </author>
    </authorgroup>

    <legalnotice>
      <para>All right reserved, do not distribute outside the JSR 303 expert
      group.</para>
    </legalnotice>
  </bookinfo>

  <preface>
    <title>License</title>

    <para>All right reserved, do not distribute outside the JSR 303 expert
    group.</para>
  </preface>

  <chapter>
    <title>Introduction</title>

    <para>This document is the specification of the Java API for the JavaBean
    validation with Java EE and Java SE. The technical objective of this work
    is to provide an object level constraint declaration and validation
    facility for the Java application developer, as well as a metadata
    repository and querying API for such constraints repository.</para>

    <section>
      <title>Expert group</title>

      <para>This work is being conducted as part of JSR-303 under the Java
      Community Process Program. This specification is the result of the
      collaborative work of the members of the JSR 303 Expert Group. These
      include the following present and former expert group members: Red Hat
      Middleware LLC: Emmanuel Bernard, TBD corp, Jason Carreira, TBD
      individuals.</para>
    </section>

    <section>
      <title>Document conventions</title>

      <para>Sigh...</para>
    </section>

    <section>
      <title>Specification goals</title>

      <para>Validating data is a common task that is copied in many different
      layers of an application, from the presentation tier to the persistence
      layer. Many times the exact same validations will have to be implemented
      in each separate validation framework, proving time consuming and
      error-prone. To prevent having to re-implement these validations at each
      layer, many developers will bundle validations directly into their
      classes, cluttering them with copied validation code that is, in fact,
      meta-data about the class itself.</para>

      <para>This JSR defines a meta-data model and API for JavaBean
      validation. The default meta-data source is annotations, with the
      ability to override and extend the meta-data through the use of XML
      validation descriptors.</para>

      <para>The validation API developed by this JSR is not specific to any
      one tier or programming model. It is specifically not tied to either the
      web tier or the persistence tier, and is available for both server-side
      application programming, as well as rich client Swing application
      developers. This API is seen as a general extension to the JavaBeans
      object model, and as such is expected to be used as a core component in
      other specifications, such as JSF, JPA, and Bean Binding.</para>
    </section>
  </chapter>

  <chapter>
    <title>Object graph constraints declaration</title>

    <para>The Bean Validation specification aims at defining a framework for
    JavaBeans constraints definition and validation. Constraints can be
    applied to the object itself or to any of the object's fields or
    properties. The primary declaration mechanism is through the use of
    annotations.</para>

    <para>Constraints are defined per object class, and applied on an object
    or object graph instance.</para>

    <section>
      <title>Requirements on objects to be validated</title>

      <para>Objects that are to be validated need to fulfill the following
      requirements.</para>

      <para>Properties holding constraints declaration have to follow the
      JavaBean specification, the object state to be validated will be access
      either through the JavaBeans style property accessor or via attribute
      access. Getters and field visibility are not restricted.</para>

      <para>It is required that the entity class follows the method signature
      conventions for JavaBeans read properties (as defined by the JavaBeans
      Introspector class) for properties holding a constraint
      declaration.</para>

      <para>The objects can support inheritance, interface and
      associations.</para>

      <section>
        <title>field-based and property-based validation</title>

        <para>TODO adapt EJB3 2.1.1?</para>

        <para>Constraint declarations can be applied on both fields and
        properties for the same object type. The same constraint should
        however not be duplicated between a field and its associated property
        (the validation rule would be applied twice). It is recommended for
        objects holding constraint declarations to adhere a single state
        access strategy (either annotated fields or properties).</para>

        <para>When a field is annotated with a constraint definition, field
        access strategy will be used to access the state validated by such
        constraint.</para>

        <para>When a property is annotated with a constraint definition,
        property access strategy will be used to access the state validated by
        such constraint.</para>

        <para>A given constraint declaration can be applied to any field,
        property or type (class) provided that:</para>

        <itemizedlist>
          <listitem>
            <para>the annotation <classname>TARGET</classname> supports
            it</para>
          </listitem>

          <listitem>
            <para>the constraint validator implementation supports the return
            type of the given field or property, or the object type</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Associated objects validation</title>

        <para>An object B associated to a object A can be requested to be
        validated by cascade when object A is validated. Object B is accessed
        through the previously describe mechanisms.</para>

        <para>Collection-valued or array-valued fields and properties can hold
        constraint declarations. If cascade validation is requested on such a
        field or property, all the objects contained in the collection-valued
        or array-valued field or property will be validated. Collection-valued
        fields and properties targeted for cascaded validation must be defined
        in terms of one of the following collection-valued interfaces
        regardless of whether the entity class otherwise adheres to the
        JavaBeans method conventions noted above and whether field or
        property-based access is used:
        <classname>java.util.Collection</classname>,
        <classname>java.util.Set</classname>,
        <classname>java.util.List</classname>,
        <classname>java.util.Map</classname>.</para>
      </section>
    </section>

    <section>
      <title>Constraint declaration</title>

      <para>Constraint declarations are defined on classes (or interfaces see
      XXX), primarily through annotations. The annotation target dictates
      which piece of data is validated. A constraint annotation (see XXX
      constraint definition), can be applied on the object type itself (class
      level), on any of the object fields or on any of the JavaBeans compliant
      properties.</para>

      <para>When a constraint declaration is set on the object type (class
      level), the object being validated is passed to the validation routine
      associated to the constraint. When a constraint declaration is set on a
      field, the field value is passed to the validation routine. When a
      constraint declaration is set on a getter, the result of the getter
      invocation is passed to the validation routine.</para>
    </section>

    <section>
      <title>Constraint validation execution</title>

      <para>For a given object to validate, the Bean Validation provider is
      expected to execute the constraint validations in the following
      order:</para>

      <itemizedlist>
        <listitem>
          <para>execute all class level validations</para>
        </listitem>

        <listitem>
          <para>execute all field level validations</para>
        </listitem>

        <listitem>
          <para>execute all getter level validations</para>
        </listitem>
      </itemizedlist>

      <para>The object validation routine is described as such. For each
      constraint declaration and in the previously defined order:</para>

      <itemizedlist>
        <listitem>
          <para>execute the <methodname>isValid</methodname> operation
          (validation routine) on the appropriate data (see XXX)</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns true, continue to
          the next constraint,</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns false, the Bean
          Validation provider populate an
          <classname>InvalidConstraint</classname> object and queue it for
          return</para>
        </listitem>

        <listitem>
          <para>if the failing constraint declaration is shortcircuit = true,
          or if there is no more constraint declaration to process, return all
          the <classname>InvalidConstraint</classname> objects</para>
        </listitem>

        <listitem>
          <para>otherwise, continue to the next constraint</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>Object graph validation</title>

        <para>The Bean Validation spec supports the ability to validate
        associated objects by cascade. Instead of manually validate several
        related (associated) objects one by one, a unified list of invalid
        values is returned.</para>

        <para>The <classname>@Valid</classname> annotation on a given
        association (ie object reference or collection / array of objects),
        dictates the Bean Validator implementation to apply the bean
        validation routine on each of the associated object(s) when the field
        or the getter is processed. This mechanism is recursive (an associated
        object can itself contains cascaded references). The Bean Validation
        implementation must ignore the cascading operation if the associated
        object has already been validated by the current validation routine,
        thus preventing infinite loops.</para>

        <para>The <classname>InvalidConstraint</classname> objects, built when
        a failing constraint on an associated object is found, reflects the
        path to reach the object (See XXX).</para>
      </section>
    </section>

    <section>
      <title>Inheritance (interface and superclass)</title>

      <para>A constraint declaration can be defined on an interface.
      Constraint declarations held on superclasses (recursively) as well as
      interfaces (or super interfaces recursively) have to be honored by the
      constraint validation routine. Constraints declared on the superclasses
      have to be checked before the constraints declared on the subclasses.
      Constraints declared on interfaces have to be checked before constraints
      declared on the implementation class. Ordering between constraints from
      different interfaces is undefined.</para>

      <para>The constraints are additive. This especially means that
      constraints declared on a superclass getter will be checked as well as
      any constraints defined on an overridden version of the getter.</para>
    </section>
  </chapter>

  <chapter>
    <title>Constraints definition</title>

    <para>Constraints are defined through annotations. Constraint annotations
    can be held at the field level, property level as well as the JavaBean
    level (ie class level).</para>

    <section>
      <title>Constraint declaration</title>

      <para>A constraint is expressed through annotations. An annotation is
      considered a constraint declaration if the annotation itself is
      annotated with <literal>javax.validation.ValidatorClass</literal>. The
      annotation target can be FIELD, METHOD and/or TYPE.</para>

      <para>A given constraint usually targets one or several specific types
      (eg a String length validation constraint targets String objects): the
      constraint annotation JavaDoc should clearly state which type the
      validation routine supports. Using a constraint on an incompatible type
      is considered an application error.</para>

      <section>
        <title>Parameters</title>

        <para>A constraint declaration can have several parameters that a user
        can (or might have to) define when using the constraint. The
        parameters are mapped as annotation parameters. Parameters can be on
        any type supported by annotations. The parameter names can be anything
        but <literal>message</literal> and <literal>context</literal>.</para>

        <section>
          <title>message</title>

          <para><literal>message</literal> is a String parameter that any
          constraint annotation must implement.</para>

          <programlisting>    String message() default "{beancheck.myConstraintFailure}";</programlisting>

          <para>The <methodname>message</methodname> parameter value will be
          used to build the (localized) error message, see XXX for more
          information.</para>
        </section>

        <section>
          <title>context</title>

          <para>TODO define if we go that road ie a String[], the API has to
          be adjusted too.</para>
        </section>

        <section>
          <title>shortcircuit</title>

          <para>This parameter is a boolean defaulted to false. When a
          validation failure happens for the given constraint, the Bean
          Validation provider stop executing the validation process and return
          immediately if <parameter>shortcircuit</parameter> is true.
          Otherwise the next constraints are processed. See XXX.</para>
        </section>

        <section>
          <title>Constraint specific parameter</title>

          <para>The constraint annotation can support any additional
          parameters needed to refine the way the constraint will be applied.
          Those parameters will be provided to the constraint validation
          implementation by the Bean Validation provider.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Constraint validator implementation</title>

      <para>A constraint validator implementation class, for a given
      constraint is described by the <parameter>value</parameter> parameter of
      <classname>javax.validation.ValidatorClass</classname> held by the
      constraint annotation</para>

      <para>A constraint validator implementation implements the following
      interface</para>

      <programlisting>/**
 * Define the logic to validate a given constraint
 *
 * @author Emmanuel Bernard
 */
public interface Constraint {
    /**
     * Validator parameters for a given constraint definition
     * Annotations parameters are passed as key/value into parameters
     *
     * @param parameters parameters for a given constraint definition
     * FIXME should it be the actual annotation passed (using generics Validator&lt;A extends Annotation&gt;
     * FIXME it would provide type safety, but complicate (slightly) the code for XML parsing
     * FIXME ebernard +1 for the change
     */
    void initialize(Map parameters);
    /**
     * Implement the validation constraint
     *
     * @param object object to validate
     * @return true if object pass the constraint
     */
    boolean isValid(Object object);
}</programlisting>

      <para>The <methodname>isValid</methodname> implementation has to assume
      it will be called concurrently, it has to be thread-safe in that
      respect.</para>

      <para>The lifecycle of a constraint implementation instances are
      undefined, but the Bean Validation provider guaranties that the
      constraint validation implementation used for a given constraint
      definition has been initialized with the constraint definition
      parameters. TODO: are we OK for such a constraint? reusing the
      implementation make sense?</para>

      <para><methodname>isValid</methodname> will be executed by the Bean
      Validation provider each time a given state needs to be validated
      against the associated constraint. <literal>true</literal> must be
      returned if the object validate the constraint, <literal>false</literal>
      otherwise.</para>

      <note>
        <para>While not mandatory, it is considered a good practice to split
        the core constraint validation from the object nullability (for
        example, an @Email constraint will return true on a null object, ie
        will not take care of the @NotNull validation)</para>
      </note>

      <para>If the Constraint validation routine retrieve an object of an
      unexpected type an <literal>IllegalArgumentException</literal> should be
      raised.</para>
    </section>
  </chapter>

  <chapter>
    <title>Validation APIs</title>

    <para>TODO make something to smooth that. Validation.createValidator(Class
    type)??</para>

    <para>TODO make something to smooth that. Validation.createValidator(Class
    type)??</para>

    <para>The default package for the Bean Validation APIs is
    <classname>javax.validation</classname>.</para>

    <section>
      <title>Validator&lt;T&gt; API</title>

      <para>The main Bean Validation API is the
      <classname>javax.validation.Validator&lt;T&gt;</classname> interface and
      the Bean Validation provider implementation. The besides implementing
      the Validator&lt;T&gt; API, the Bean Validation provider implementation
      class must have a constructor Constructor(Class&lt;T&gt;).</para>

      <para>A Validator&lt;T&gt; instance is able to validate instances of T
      classes (and the associated objects if any). It is recommended to cache
      Validator&lt;T&gt; instances. The Bean Validation provider has to
      guarantee that concurrent, multi-threaded access to a Validator&lt;T&gt;
      implementation is safe.</para>

      <programlisting>/**
 * Validate a given object type
 *
 * FIXME should Serializable be part of the definition.
 * 
 * @author Emmanuel Bernard
 */
public interface Validator&lt;T&gt; extends Serializable {
    /**
     * validate all constraints on object (unless shortcutted)
     *
     * @param object object to validate
     * @return array of invalid constrains or an empty array if none
     * @throws IllegalArgumentException e if object is null TODO should it just be ignored?
     */
    InvalidConstraint[] validate(T object);

    /**
     * validate all constraints on propertyname property of object (unless shortcutted)
     *
     * TODO do we keep it?
     *
     * @param object object to validate
     * @param propertyName property to validate
     * @return array of invalid constrains or an empty array if none
     * @throws IllegalArgumentException e if object is null TODO should it just be ignored?
     */
    InvalidConstraint[] validate(T object, String propertyName);

    /**
     * validate all constraints on propertyname property if the property value is value
     *
     * FIXME do we keep it?
     * TODO express limitations of InvalidConstraint in this case
     *
     * @param propertyName property to validate
     * @param value property value to validate
     * @return array of invalid constrains or an empty array if none
     */
    InvalidConstraint[] validateValue(String propertyName, Object value);

    [...]

}</programlisting>

      <para>TODO do something to smooth that. Validation.createValidator(Class
      type)??</para>

      <section>
        <title>validate an object</title>

        <para><methodname>InvalidConstraint[] validate(T object)</methodname>
        is used to validate a given object of type T from a Validator&lt;T&gt;
        instance. An array of <classname>InvalidConstraint</classname> is
        returned.</para>

        <para><methodname>InvalidConstraint[] validate(T object, String
        propertyName)</methodname> validates a given field or property of a
        given object. The property name is the JavaBeans property name (as
        defined by the JavaBeans Introspector class). This method is useful
        for partial object validation. TODO do we keep it? TODO should we
        ignore @Valid for such methods?</para>

        <para><methodname>InvalidConstraint[] validateValue(String
        propertyName, Object value)</methodname> validate the property
        referenced by <parameter>propertyName</parameter>, if the property
        value were <parameter>value</parameter>. This method is useful for
        ahead of time validation. TODO do we keep it? TODO should we ignore
        @Valid for such methods?</para>
      </section>
    </section>

    <section>
      <title>InvalidConstraint</title>

      <para><classname>InvalidConstraint</classname> is the class describing a
      single constraint failure. An array of InvalidConstraint is returned
      from an object validation.</para>

      <programlisting>/**
 * Describe a contraint validation defect
 *
 * FIXME the rational behind rootBean and propertyPath is to keep the context available to the user
 * TODO add pointers to the metadata? 
 *
 * @author Emmanuel Bernard
 */
public interface InvalidConstraint {
    
    /**
     * Error message
     */
    String getMessage();

    /**
     * Root bean being validated validated
     */
    Object getRootBean();

    /**
     * Bean type being validated
     */
    Class getBeanClass();

    /**
     * the value failing to pass the constraint
     */
    Object getValue();

    /**
     * the property path to the value from &lt;code&gt;rootBean&lt;/code&gt;
     * Null if the value is the rootBean itself
     */
    String getPropertyPath();

}</programlisting>

      <para><methodname>message</methodname> return the expanded (localized)
      message for the failing constraint (See XXX) for more
      information.</para>

      <para><methodname>rootBean</methodname> returns the root object being
      validated that leaded to the failing constraint (ie the object the
      client code passed to the <methodname>Validator.validate</methodname>
      method.</para>

      <para><methodname>beanClass</methodname> returns the type of the current
      bean being validated and leading to the failure.</para>

      <para><methodname>value</methodname> returns the value (field, property
      or validated object) being passed to <methodname>isValid</methodname>
      and returning false.</para>

      <para><methodname>propertyPath</methodname> is defined by the following
      rules:</para>

      <itemizedlist>
        <listitem>
          <para>if the constraint is a class level constraint, then the empty
          string is used</para>
        </listitem>

        <listitem>
          <para>if the constraint is a field level constraint, the field name
          is the propertyPath</para>
        </listitem>

        <listitem>
          <para>if the constraint is a property, the JavaBeans property name
          (as defined by the JavaBeans Introspector class) is the
          propertyPath</para>
        </listitem>

        <listitem>
          <para>if an associated object is validated, add the association
          field or JavaBeans property name and a dot ('.') as a prefix to the
          previous rules. This rule is recursive.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>From <methodname>rootBean</methodname> and
        <methodname>propertyPath</methodname>, it is possible to rebuild the
        context of the failure</para>
      </note>
    </section>

    <section>
      <title>Message</title>

      <para>TODO Introduce MessageResolver</para>

      <para>The default message resolver can resolve properties based on a
      user defined <filename>/ValidationMessages.properties</filename> file
      (which supports properties localization) backed up by a Bean Validation
      provider embedded property file.</para>

      <para>The error message for a given constraint failure is built from the
      following rules:</para>

      <orderedlist>
        <listitem>
          <para>the message string is taken from the
          <parameter>message</parameter> parameter of the currently failing
          constraint (while defaulted, such a message can be overridden by the
          user through the constraint annotation) See XXX</para>
        </listitem>

        <listitem>
          <para>any <literal>{property}</literal> pattern (open bracket -
          property name - close bracket) is extended to the value of property
          in the constraint parameters if such a parameter name is present,
          otherwise it is ignored</para>
        </listitem>

        <listitem>
          <para>any <literal>{property}</literal> pattern is extended from the
          matching name in <filename>/ValidationMessages.properties</filename>
          if such a property is present in the properties file. If not,
          <literal>{property}</literal> is extended from the matching name in
          the Bean Validation provider embedded property file.</para>
        </listitem>

        <listitem>
          <para>step 2 and 3 are executed until no more matching can be found
          for step 2 and 3 in a row.</para>
        </listitem>
      </orderedlist>
    </section>
  </chapter>

  <chapter>
    <title>Constraint metadata request APIs</title>

    <para>The Bean Validation specification provides a way to query the
    constraint repository. This API is expected to be used for tooling support
    as well as integration with other frameworks, library and JSRs: the Bean
    Validation is expected to be the main object oriented constraint
    declaration repository, whose metadata are consumed by all component
    oriented or domain model oriented frameworks avoiding duplication at the
    platform level (EE or SE).</para>

    <section>
      <title>Validator&lt;T&gt;</title>

      <para>The main API to access all metadata related to a given object is
      <classname>Validator&lt;T&gt;</classname> (see XX for more information
      on how to retrieve a <classname>Validator</classname> instance).</para>

      <para>A <classname>Validator&lt;T&gt;</classname> instance is the
      metadata repository for <parameter>T</parameter> classes. It is
      recommended to cache <classname>Validator&lt;T&gt;</classname>
      instances. The Bean Validation provider has to guarantee that
      concurrent, multi-threaded access to a
      <classname>Validator&lt;T&gt;</classname> implementation is safe.</para>

      <programlisting>/**
 * Describe a contraint validation defect
 *
 * FIXME the rational behind rootBean and propertyPath is to keep the context available to the user
 * TODO add pointers to the metadata? 
 *
 * @author Emmanuel Bernard
 */
public interface InvalidConstraint {

    [...]

    /**
     * return true if at least one constraint declaration is present for the given bean
     * or if one property is marked for validation cascade
     */
    boolean hasConstraints();

    /**
     * return the class level constraints
     */
    ElementDescriptor getBeanConstraints();

    /**
     * return the property level constraints for a given propertyName
     * or null if either the property does not exist or has no constraint
     */
    ElementDescriptor getConstraintsForProperty(String propertyName);

    /**
     * return the property names having at least a constraint defined
     */
    String[] getValidatedProperties();

}</programlisting>

      <para><methodname>hasConstraints</methodname> returns true if the given
      <parameter>T</parameter> class has at least one constraint
      declared.</para>

      <para><methodname>getBeanConstraints</methodname> returns an
      <classname>ElementDescriptor</classname> object describing the bean
      level constraints (See XXX).</para>

      <para><methodname>getConstraintsForProperty</methodname> returns an
      <classname>ElementDescriptor</classname> object describing the property
      level constraints (See XXX). The property is uniquely identified by its
      name as per the JavaBeans convention: field level and getter level
      constraints of the given name are all returned.</para>

      <para><methodname>getValidatedProperties</methodname> returns the names
      of the bean properties having at least one constraint or being cascaded
      (<classname>@Valid</classname> annotation)</para>

      <para></para>
    </section>

    <section>
      <title>ElementDescriptor</title>

      <para><classname>ElementDescriptor</classname> is the object used to
      describe the list of constraints for a given element (whether it be a
      field, a method or a class).</para>

      <programlisting>/**
 * Describe a validated element (class, field or property)
 * //TODO interface or class
 *
 * @author Emmanuel Bernard
 */
public class ElementDescriptor {
    
    [...]

    /**
     * Element type
     */
    public ElementType getElementType() {
        return elementType;
    }

    /**
     * statically defined returned type
     * //TODO should it be Type or even completly removed
     */
    public Class getReturnType() {
        return returnType;
    }

    /**
     * is the association cascaded
     */
    public boolean isCascaded() {
        return cascaded;
    }

    /**
     * all the constraint descriptors for the given element
     * @return
     */
    public ConstraintDescriptor[] getConstraintDescriptors() {
        return constraintDescriptors;
    }

    /**
     * Property path from the root entity validated.
     * //FIXME there is a problem in describing cyclic dependencies
     */
    public String getPropertyPath() {
        return propertyPath;
    }
}</programlisting>

      <para><methodname>getElementType</methodname> returns the
      <classname>java.lang.annotations.ElementType</classname> the constraint
      is declared on. The expected types for the current version of the Bean
      Validation spec are:</para>

      <itemizedlist>
        <listitem>
          <para>TYPE</para>
        </listitem>

        <listitem>
          <para>FIELD</para>
        </listitem>

        <listitem>
          <para>METHOD</para>
        </listitem>
      </itemizedlist>

      <para><methodname>getReturnType</methodname> returns either the object
      type for a class, or the returned type for a property (TODO problem of
      generics resolution).</para>

      <para><methodname>isCascaded</methodname> returns
      <literal>true</literal> of the property is marked with
      <classname>@Valid</classname>. Class level element descriptors always
      return <literal>false</literal>.</para>

      <para><methodname>getPropertyPath</methodname> returns the property path
      as described in XXX (TODO what about circularity)</para>

      <para><classname>getConstraintDescriptors</classname> return an array of
      <classname>ConstraintDescriptor</classname> (see XXX), each
      <classname>ConstraintDescriptor</classname> describing one of the
      constraints declared on the given element.</para>
    </section>

    <section>
      <title>ConstraintDescriptor</title>

      <para>A <classname>ConstraintDescriptor</classname> object describes a
      given constraint declaration (ie a constraint annotation).</para>

      <programlisting>/**
 * Describe a single constraint
 * //TODO interface or class
 * 
 * @author Emmanuel Bernard
 */
public class ConstraintDescriptor {
    
    /**
     * Constraint declaration annotation
     */
    public Annotation getAnnotation() {
        return annotation;
    }

    /**
     * constraint parameters
     */
    public Map&lt;String, Object&gt; getParameters() {
        return parameters;
    }

    /**
     * Does the constraint enables short circuit
     */
    public boolean isShortCircuited() {
        return shortCircuited;
    }

    /**
     * What are the contexts the constraint is applied on
     */
    public String[] getContexts() {
        return contexts;
    }

    //TODO keep that?
    public String getPartiallyResolvedMessage() {
        return partiallyResolvedMessage;
    }

    /**
     * Return the constraint implementation routine
     */
    public Constraint getConstraintImplementation() {
        return constraintImplementation;
    }
}</programlisting>

      <para><methodname>getAnnotation</methodname> returns the annotation
      instance (or an annotation instance representing the given constraint
      declaration)</para>

      <para><methodname>getParameters</methodname> returns a map containing
      the annotation parameter names as a key, and the annotation parameter
      values as a value (this API is anticipated to be simpler to use by tools
      that reflection over the annotation instance)</para>

      <para><methodname>isShortCircuited</methodname> returns
      <literal>true</literal> if the annotation's
      <parameter>shortCircuit</parameter> parameter (if any) is set to
      <literal>true</literal>.</para>

      <para><methodname>getContexts</methodname> returns the context names,
      the constraint is supposed to be applied upon.</para>

      <para><methodname>getPartiallyResolvedMessage</methodname> returns the
      interpolated message as defined in XXX (TODO minor the pluggable
      messageResolver) TODO is this somewhat useful?</para>

      <para><methodname>getConstraintImplementation</methodname> returns the
      initialized and ready to use
      <classname>javax.validator.Constraint</classname> implementation for the
      given constraint declaration.</para>
    </section>
  </chapter>

  <chapter>
    <title>Metadata descriptors</title>

    <section>
      <title>Annotations</title>

      <para></para>
    </section>

    <section>
      <title>XML descriptor</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>TODOs</title>

    <para>Talk about XML</para>

    <para>Port my TODO list to this chapter :)</para>

    <para>Provide some examples in the spec</para>

    <para>What about chapter reordering, specifically put chapter 3
    (definition) before chapter 2 (declaration and lifecycles)</para>
  </chapter>
</book>