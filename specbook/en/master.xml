<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <title>JSR 303: Bean Validation</title>

  <bookinfo>
    <title>JSR 303: Bean Validation</title>

    <releaseinfo>1.0.Beta3</releaseinfo>

    <pubdate>2009-02-11</pubdate>

    <copyright>
      <year>2007-2009</year>

      <holder>Red Hat Middleware, LLC and Steve Peterson</holder>
    </copyright>

    <authorgroup>
      <corpauthor>Bean Validation Expert Group</corpauthor>

      <author>
        <firstname>Emmanuel</firstname>

        <surname>Bernard</surname>

        <affiliation>
          <orgname>Red Hat Middleware, LLC</orgname>
        </affiliation>
      </author>

      <author>
        <firstname>Steve</firstname>

        <surname>Peterson</surname>
      </author>
    </authorgroup>
  </bookinfo>

  <preface>
    <title>Disclaimer</title>

    <para>This specification is in public final draft stage. The content of
    this specification is expected to be very stable and don't change unless
    minor adjustment are needed or uncovered when writing the reference
    implementation.</para>

    <para>The JSR 303 expert group is seeking for feedbacks from the community
    on this specification. Direct feedbacks to <ulink
    url="http://forum.hibernate.org/viewforum.php?f=26">http://forum.hibernate.org/viewforum.php?f=26</ulink>.
    If privacy is a concern, consider using jsr-303-comments@jcp.org.</para>
  </preface>

  <chapter>
    <title>Introduction</title>

    <para>This document is the specification of the Java API for JavaBean
    validation in Java EE and Java SE. The technical objective of this work is
    to provide a class level constraint declaration and validation facility
    for the Java application developer, as well as a constraint metadata
    repository and query API.</para>

    <section>
      <title>Expert group</title>

      <para>This work is being conducted as part of JSR-303 under the Java
      Community Process Program. This specification is the result of the
      collaborative work of the members of the JSR 303 Expert Group. These
      include the following present and former expert group members:</para>

      <itemizedlist>
        <listitem>
          <para>Geert Bevin</para>
        </listitem>

        <listitem>
          <para>Emmanuel Bernard (Red Hat Middleware LLC) - Specification
          Lead</para>
        </listitem>

        <listitem>
          <para>Uri Boness</para>
        </listitem>

        <listitem>
          <para>Erik Brakkee (Ericsson AB)</para>
        </listitem>

        <listitem>
          <para>Ed Burns (Sun Microsystems, Inc.)</para>
        </listitem>

        <listitem>
          <para>Jason Carreira</para>
        </listitem>

        <listitem>
          <para>Robert Clevenger (Oracle - retired)</para>
        </listitem>

        <listitem>
          <para>Linda DeMichiel (Sun Microsystems, Inc.)</para>
        </listitem>

        <listitem>
          <para>Tim Fennel</para>
        </listitem>

        <listitem>
          <para>Bharath Ganesh (Pramati Technologies)</para>
        </listitem>

        <listitem>
          <para>Romain Guy (Google Inc.)</para>
        </listitem>

        <listitem>
          <para>Robert Harrop</para>
        </listitem>

        <listitem>
          <para>Jacob J. Hookom</para>
        </listitem>

        <listitem>
          <para>Bob Lee (Google Inc.)</para>
        </listitem>

        <listitem>
          <para>Craig R. McClanahan (Sun Microsystems, Inc.)</para>
        </listitem>

        <listitem>
          <para>Niall K. Pemberton</para>
        </listitem>

        <listitem>
          <para>Steve Peterson</para>
        </listitem>

        <listitem>
          <para>Dhanji R. Prasanna (individual initially and then Google
          Inc.)</para>
        </listitem>

        <listitem>
          <para>Gerhard Petracek</para>
        </listitem>

        <listitem>
          <para>Matt Raible</para>
        </listitem>

        <listitem>
          <para>Michael Nascimento Santos</para>
        </listitem>

        <listitem>
          <para>Sebastian Thomschke</para>
        </listitem>

        <listitem>
          <para>Jon Wetherbee (Oracle)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Specification goals</title>

      <para>Validating data is a common task that occurs throughout an
      application, from the presentation layer to the persistence layer. Often
      the same validation logic is implemented in each layer, proving time
      consuming and error-prone. To avoid duplication of these validations in
      each layer, developers often bundle validation logic directly into the
      domain model, cluttering domain classes with validation code that is, in
      fact, metadata about the class itself.</para>

      <para>This JSR defines a metadata model and API for JavaBean validation.
      The default metadata source is annotations, with the ability to override
      and extend the meta-data through the use of XML validation
      descriptors.</para>

      <para>The validation API developed by this JSR is not intended for use
      in any one tier or programming model. It is specifically not tied to
      either the web tier or the persistence tier, and is available for both
      server-side application programming, as well as rich client Swing
      application developers. This API is seen as a general extension to the
      JavaBeans object model, and as such is expected to be used as a core
      component in other specifications. Ease of use and flexibility have
      influenced the design of this specification.</para>
    </section>

    <section>
      <title>How this document is organized</title>

      <para>This document describes each aspect of the bean validation
      specification in a separate chapter. One should remember that the
      specification is a consistent whole.</para>

      <para><xref linkend="constraintsdefinitionimplementation" /> describes
      how constraints are defined.</para>

      <para><xref linkend="constraintdeclarationvalidationprocess" />
      describes how a JavaBean class is decorated with annotations to describe
      constraints.</para>

      <para><xref linkend="validationapi" /> describes how to programmatically
      validate a JavaBean.</para>

      <para><xref linkend="constraintmetadata" /> describes how the metadata
      query API works.</para>

      <para>In <xref linkend="terminology" />, key concepts are summarized.
      Some reviewers have found that reading the terminology section first
      helps to better understand the specification.</para>

      <para>JPA, JSF and EE integration proposals are present at <xref
      linkend="appendix-jpa" />, <xref linkend="appendix-jsf" /> and <xref
      linkend="appendix-ee" />.</para>
    </section>

    <section>
      <title>How to comment</title>

      <para>The expert group is eager to receive feedbacks from readers. Feel
      free to contact us at <ulink
      url="http://forum.hibernate.org/viewforum.php?f=26">http://forum.hibernate.org/viewforum.php?f=26</ulink>.
      If privacy is a concern, consider using jsr-303-comments@jcp.org.</para>
    </section>
  </chapter>

  <chapter id="constraintsdefinitionimplementation">
    <title>Constraint Definition</title>

    <!--[SCP: "declaration" is creating a new kind of constraint; "definition" is applying a constraint to a class, method, or field.]
EBE I started a thread on the ML => I don't think I like the move.-->

    <!--[SCP: consider moving this chapter after the next one] // EBE:I tried earlier but this order make more sense-->

    <para>Constraints are defined by the combination of a constraint
    annotation and a list of constraint validation implementations. The
    constraint annotation is applied on types, methods, or fields.</para>

    <para>Unless stated otherwise the default package name for the Bean
    Validation APIs is <classname>javax.validation</classname>.</para>

    <section id="constraintsdefinitionimplementation-constraintdefinition">
      <title>Constraint annotation</title>

      <para>A constraint on a JavaBean is expressed through one or more
      annotations. An annotation is considered a constraint definition if its
      retention policy contains <literal>RUNTIME</literal> and if the
      annotation itself is annotated with
      <literal>javax.validation.Constraint</literal>.</para>

      <programlisting>/**
 * Link between a constraint annotation and its constraint validation implementations.
 * &lt;p/&gt;
 * A given constraint annotation should be annotated by a @Constraint
 * annotation which refers to its list of constraint validation implementations.
 *
 * @author Emmanuel Bernard (emmanuel at hibernate.org)
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {
    /**
     * ConstraintValidator classes must reference distinct target types.
     * If two validators refer to the same type, an exception will occur.
     * 
     * @return array of ConstraintValidator classes implementing the constraint
     */
    public Class&lt;? extends ConstraintValidator&lt;?,?&gt;&gt;[] validatedBy();
}</programlisting>

      <para>Constraint annotations can target any of the following
      <classname>ElementType</classname>s:</para>

      <itemizedlist>
        <listitem>
          <para><literal>FIELD</literal> for constrained attributes</para>
        </listitem>

        <listitem>
          <para><literal>METHOD</literal> for constrained getters</para>
        </listitem>

        <listitem>
          <para><literal>TYPE</literal> for constrained beans</para>
        </listitem>

        <listitem>
          <para><literal>ANNOTATION_TYPE</literal> for constraints composing
          other constraints</para>
        </listitem>
      </itemizedlist>

      <para>While other <classname>ElementType</classname>s are not forbidden,
      the provider does not have to recognize and process constraints placed
      on such types.</para>

      <para>Since a given constraint definition applies to one or more
      specific Java types, the JavaDoc for the constraint annotation should
      clearly state which types are supported. Applying a constraint
      annotation to an incompatible type will raise a
      <classname>UnexpectedTypeForConstraintException</classname>. Care should
      be taken on defining the list of
      <classname>ConstraintValidator</classname>. The type resolution
      algorithm (see <xref linkend="typevalidatorresolution" />) could lead to
      exceptions due to ambiguity.</para>

      <section>
        <title>Constraint definition properties</title>

        <para>A constraint definition may have properties that can be
        specified at the time the constraint is applied to a JavaBean. The
        properties are mapped as annotation elements. The annotation element
        names <literal>message</literal> and <literal>groups</literal> are
        considered reserved names; annotation elements starting with
        <literal>valid</literal> are not allowed; a constraint may use any
        other element name for its parameters.<!--[SCP: reserve a prefix for future use?] EBE: I think I have a smarter approach check the "Constraint definition elements" email from 2007/11/26--></para>

        <section id="constraintsdefinitionimplementation-constraintdefinition-parameters-message">
          <title>message</title>

          <para>Every constraint annotation must define a
          <literal>message</literal> element of type
          <literal>String</literal>.</para>

          <programlisting>String message() default "{constraint.myConstraintFailure}";</programlisting>

          <para>The <methodname>message</methodname> element value is used to
          create the error message. See <xref
          linkend="validationapi-message" /> for a detailed
          explanation.</para>
        </section>

        <section id="constraintsdefinitionimplementation-constraintdefinition-groups">
          <title>groups</title>

          <para>Every constraint annotation must define a
          <literal>groups</literal> element that specifies which processing
          groups the constraint definition is associated with.</para>

          <programlisting>    Class&lt;?&gt;[] groups() default {};</programlisting>

          <para>The default value must be an empty array.</para>

          <para>When using the constraint declaration, if no group is
          specified, the <literal>Default</literal> group is considered
          declared. The validation will be evaluated if:</para>

          <itemizedlist>
            <listitem>
              <para>no group was specified at validation time (which defaults
              to the <literal>Default</literal> group) and the annotation
              declares implicitly or explicitly the <literal>Default</literal>
              group</para>
            </listitem>

            <listitem>
              <para>or if one of the groups specified at validation time
              matches one of the groups specified on the constraint annotation
              declaration</para>
            </listitem>
          </itemizedlist>

          <para>See <xref linkend="validationapi-validatorapi-groups" /> for
          more information.</para>

          <para>Groups are typically used to control the order of Validator
          evaluation, or perform validation of the partial state of a
          JavaBean.</para>
        </section>

        <section>
          <title>Constraint specific parameter</title>

          <para>The constraint annotation definitions may define additional
          elements to parameterize the constraint. For example, a constraint
          that validates the length of a string can use an annotation element
          named <literal>length</literal> to specify the maximum length at the
          time the constraint is declared.</para>
        </section>
      </section>

      <section>
        <title>Examples</title>

        <example id="example-definition-notnull">
          <title>@NotNull constraint definition</title>

          <programlisting>@Documented
@Constraint(validatedBy = NotNullConstraintValidator.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE})
@Retention(RUNTIME)
public @interface NotNull {
    String message() default "{constraint.notNull}";
    Class&lt;?&gt;[] groups() default {};
}</programlisting>
        </example>

        <para><xref linkend="example-definition-notnull" /> defines a not null
        constraint with a specific default message. The constraint Validator
        is implemented by <classname>NotNullConstraint</classname>.</para>

        <example id="example-definition-length">
          <title>@Length constraint definition</title>

          <programlisting>@Documented
@Constraint(validatedBy = LengthConstraintValidator.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE})
@Retention(RUNTIME)
public @interface Length {
    int min() default 0;
    int max() default Integer.MAX_VALUE;
    String message() default "{constraint.length}";
    Class&lt;?&gt;[] groups() default {};
}</programlisting>
        </example>

        <para><xref linkend="example-definition-length" /> defines a length
        constraint. The constraint definition includes two optional properties
        that may be specified when the constraint is applied.</para>

        <example id="example-definition-min">
          <title>@Min constraint definition</title>

          <programlisting>@Documented
@Constraint(validatedBy = MinConstraintValidator.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE})
@Retention(RUNTIME)
public @interface Min {
    int value();
    String message() default "{constraint.min}";
    Class&lt;?&gt;[] groups() default {};
}</programlisting>
        </example>

        <para><xref linkend="example-definition-min" /> defines a min
        constraint: the <methodname>value</methodname> property must be
        specified when the constraint is applied.</para>
      </section>
    </section>

    <section id="constraintsdefinitionimplementation-multipleconstraints">
      <title>Applying multiple constraints of the same type</title>

      <para>It is often useful to apply the same constraint more than once to
      the same target, with different properties. A common example is the
      <literal>@Pattern</literal> constraint, which validates that its target
      matches a specified regular expression.</para>

      <para>To support this, the bean validation provider treats regular
      annotations (annotations not annotated by
      <classname>@Constraint</classname>) whose <literal>value</literal>
      element has a return type of an array of constraint annotations in a
      special way. Each element in the <literal>value</literal> array are
      processed by the Bean Validation implementation as regular constraint
      annotations. This means that each constraint specified in the value
      element is applied to the target. The annotation must have retention
      <literal>RUNTIME</literal> and can be applied on a type, field, property
      or an other annotation. It is recommended to use the same set of targets
      than the initial constraint.</para>

      <para>Note to constraint designers. Each constraint annotation should be
      coupled with its corresponding multi-valued annotation.</para>

      <programlisting>@Documented
@Constraint(validatedBy = PatternValidator.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE})
@Retention(RUNTIME)
public @interface Pattern {
    /** regular expression */
    String regex();

    /** Flags parameter for Pattern.compile() */
    int flags() default 0;

    String message() default "{constraint.pattern}";
    Class&lt;?&gt;[] groups() default {};
}

@Documented
@Target({METHOD, FIELD, ANNOTATION_TYPE})
@Retention(RUNTIME)
public @interface Patterns {
    Pattern[] value();
<!--SCP:  will we ever need to distinguish this type of annotation from other arrays of constraints?
EBE anything specific in mind?--><!--SCP:  what order are these evaluated in? 
EBE: this is not specified, I don't think there is a need for-->}</programlisting>

      <example>
        <title>Multi-valued constraint</title>

        <programlisting>public class Engine {
    @Patterns( {
            @Pattern(regex = "^[A-Z0-9-]+$", 
                message = "must contain alphabetical characters only"),
            @Pattern(regex = "^....-....-....$", message="must match ....-....-....")
            } )
    private String serialNumber;
}</programlisting>
      </example>

      <para>In this example, both constraints (<literal>^[A-Z0-9-]+$</literal>
      and <literal>^....-....-....$</literal>) will be applied on the
      <literal>serialNumber</literal> field.</para>
    </section>

    <section id="constraintsdefinitionimplementation-constraintcomposition">
      <title>Constraint composition</title>

      <para>The specification allows to compose constraints from other
      constraints.</para>

      <para>Constraint composition is useful in several ways:</para>

      <itemizedlist>
        <listitem>
          <para>Avoid duplication and facilitate reuse of more primitive
          constraints.</para>
        </listitem>

        <listitem>
          <para>Expose primitive constraints as part of a composed constraint
          in the metadata API and enhance tool awareness.</para>
        </listitem>
      </itemizedlist>

      <para>Composition is done by annotating a constraint annotation with the
      composing constraint annotations.</para>

      <example>
        <title>Composition consists of annotating the composed
        constraint</title>

        <programlisting>@NotNull
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
}</programlisting>
      </example>

      <para>Annotating an element with <classname>@FrenchZipcode</classname>
      is equivalent to annotating it with <classname>@NotNull</classname>,
      <classname>@Size(min=5, max=5)</classname> and
      <classname>@FrenchZipcode</classname>. More formally, each constraint
      annotation hosted on a constraint annotation is applied to the target
      element and this recursively. Note that the main annotation and its
      constraint validation implementation is also applied. By default, each
      failing constraint generates an error report. Groups from the main
      constraint annotation are inherited by the composing annotations. Any
      <methodname>groups</methodname> definition on a composing annotation is
      ignored.</para>

      <para>The property type a composed composition is placed on must be
      compatible with all constraints (composing and composed). A constraint
      designer should ensure that such a type exists and list in the JavaDoc
      the all the compatible types.</para>

      <para>It is possible to ensure that composing annotations do not raise
      individual error reports. In this scenario, if one or more composing
      annotations are invalid, the main annotation is automatically considered
      invalid and the corresponding error report is generated. To mark a
      constraint as raising only the main constraint error report despite its
      use of composing constraints, use the
      <classname>@ReportAsSingleViolation</classname> annotation.</para>

      <example>
        <title>If any of the composing constraint fails, the error report
        corresponding to @FrenchZipcode is raised and none other.</title>

        <programlisting>@NotNull
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
}</programlisting>
      </example>

      <para>The definition of <classname>@ReportAsSingleViolation</classname>
      is as followed.</para>

      <programlisting>/**
 * A constraint annotation annotated with this annotation
 * will return the composed annotation error report if any of the composing annotations
 * fail. The error reports of each individual composing constraint is ignored.
 * 
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}</programlisting>

      <para>Composing annotations can define parameters and message (aside
      from <methodname>groups</methodname>) but these are fixed for a given
      main annotation.</para>

      <example>
        <title>Composing annotations can use parameters. They are fixed for a
        given main annotation. All @FrenchZipcode constraints have a @Size
        restricted to 5.</title>

        <programlisting>@NotNull
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
}</programlisting>
      </example>

      <para>It is possible to override parameters and messages defined on a
      composing annotation. A parameter from the main annotation is used to
      override one or more parameters of the composing annotations. Such a
      parameter is annotated with the
      <classname>@OverridesParameter</classname> annotation or its multivalued
      equivalent <classname>@OverridesParameters</classname>.</para>

      <example id="example-composing-overridden">
        <title>Parameters from composing annotations can be overridden by
        parameters from the main annotation.</title>

        <programlisting>@NotNull
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};

    @OverridesParameters( {
        @OverridesParameter(constraint=Size.class, parameter="min"),
        @OverridesParameter(constraint=Size.class, parameter="max") } )
    int size() default 5;

    @OverridesParameter(constraint=Size.class, parameter="message")
    String sizeMessage() default "{beancheck.zipcode.size}";
}</programlisting>
      </example>

      <para>The parameter value from the main annotation annotated with
      <classname>@OverridesParameter</classname> is applied to the parameter
      named after <methodname>OverridesParameter.parameter</methodname> of the
      composing constraint of type
      <methodname>OverridesParameter.constraint</methodname>. If not
      specified, the name of the targeted parameter equals the name of the
      parameter the <classname>@OverridesParameter</classname> is on The types
      of the overridden and overriding parameters must be identical.</para>

      <para>Using <xref linkend="example-composing-overridden" />,</para>

      <programlisting>@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</programlisting>

      <para>is equivalent to</para>

      <programlisting>@FrenchZipcode</programlisting>

      <para>using the following definition</para>

      <programlisting>@NotNull
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
}</programlisting>

      <para>If a constraint type is used more than once as a composing
      constraint, the multi value constraints model as described in <xref
      linkend="constraintsdefinitionimplementation-multipleconstraints" /> is
      used. To select the appropriate composing constraint targeted,
      <methodname>OverridesParameter.index</methodname> is used. It represents
      the constraint index in the <methodname>value</methodname> array. If
      <literal>index</literal> is undefined, the single constraint declaration
      is targeted.</para>

      <example>
        <title>@OverridesParameter annotation definition</title>

        <programlisting>/**
 * Mark a parameter as overriding the parameter of a composing constraint.
 * Both parameter must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesParameter {
	/**
	 * @return Constraint type the parameter is overriding
	 */
	Class&lt;? extends Annotation&gt; constraint();

	/**
	 * @return name of constraint parameter overridden.
	 * Defaults to the name of the parameter hosting the annotation.
	 */
	String parameter();

	/**
	 * @return The index of the targeted constraint declaration when using
	 * multiple constraints of the same type.
	 * The index represents the index of the constraint in the value() array.
	 *
	 * By default, no index is defined and the single constraint declaration
	 * is targeted
	 */
	int index() default -1;
}</programlisting>
      </example>

      <para>The following elements uniquely identify an overridden constraint
      parameter:</para>

      <itemizedlist>
        <listitem>
          <para><methodname>OverridesParameter.constraint</methodname></para>
        </listitem>

        <listitem>
          <para><methodname>OverridesParameter.parameter</methodname></para>
        </listitem>

        <listitem>
          <para><methodname>OverridesParameter.index</methodname></para>
        </listitem>
      </itemizedlist>

      <para>Constraint designers are encouraged to make use of composition
      (recursively or not) based on the built-in constraints defined by the
      specification. The composing constraints are exposed through the Bean
      Validation metadata API (<xref
      linkend="constraintmetadata-constraintdescriptor" />). This metadata is
      particularly useful for third-party metadata consumers like persistence
      frameworks generating database schemas (such as Java Persistence) or
      presentation frameworks.</para>
    </section>

    <section id="constraintsdefinitionimplementation-validationimplementation">
      <title>Constraint validation implementation</title>

      <para>A constraint validation implementation performs the validation of
      a given constraint annotation for a given type. The implementation
      classes are specified by the <literal>validatedBy</literal> element of
      the <classname>@Contraint</classname> annotation that decorates the
      constraint definition. The constraint validation implementation
      implements the <classname>ConstraintValidator</classname>
      interface.</para>

      <example>
        <title>ConstraintValidator interface</title>

        <programlisting>/**
 * Defines the logic to validate a given constraint A
 * for a given object type T.
 * Implementations must comply to the following restriction:
 * T must resolve to a non parameterized type
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator&lt;A extends Annotation, T&gt; {
	/**
	 * Validator parameters for a given constraint declaration
	 * Annotations parameters are passed as key/value into parameters
	 * &lt;p/&gt;
	 * This method is guaranteed to be called before any of the other Constraint
	 * implementation methods
	 *
	 * @param constraintAnnotation parameters for a given constraint declaration
	 */
	void initialize(A constraintAnnotation);

	/**
	 * Implement the validation logic.
	 * &lt;code&gt;value&lt;/code&gt; state must not be changed by a Constraint implementation
	 *
	 * @param value object to validate
	 * @param constraintValidatorContext context in which the constraint is evaluated
	 *
	 * @return false if &lt;code&gt;value&lt;/code&gt; does not pass the constraint
	 */
	boolean isValid(T value, ConstraintValidatorContext constraintValidatorContext);
}</programlisting>
      </example>

      <para>Some restrictions apply on the generic type
      <classname>T</classname> (used in the <methodname>isValid</methodname>
      method). <classname>T</classname> must resolve in a non parameterized
      type:</para>

      <itemizedlist>
        <listitem>
          <para>the type is not using generics</para>
        </listitem>

        <listitem>
          <para>because the raw type is used instead of the generic
          version</para>
        </listitem>
      </itemizedlist>

      <warning>
        <para>Should we support unbounded wildcards?</para>
      </warning>

      <para>Here are some examples of valid definitions in <xref
      linkend="example-constraintsdefinitionimplementation-validationimplementation-validdef" />.</para>

      <example id="example-constraintsdefinitionimplementation-validationimplementation-validdef">
        <title>Valid ConstraintValidator definitions</title>

        <programlisting>//String is not making use of generics
public class SizeValidatorForString implements&lt;Size, String&gt; {...}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements&lt;Size, Collection&gt; {...}</programlisting>
      </example>

      <para>And some invalid definitions in <xref
      linkend="example-constraintsdefinitionimplementation-validationimplementation-invaliddef" />.</para>

      <example id="example-constraintsdefinitionimplementation-validationimplementation-invaliddef">
        <title>Invalid ConstraintValidator definitions</title>

        <programlisting>//parameterized type
public class SizeValidatorForString implements&lt;Size, Collection&lt;String&gt;&gt; {...}

//parameterized type using unbounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;?&gt;&gt; {...}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;? extends Address&gt;&gt; {...}</programlisting>
      </example>

      <note>
        <para>This restriction is not a theoretical limitation and a future
        version of the specification will likely allow that in the
        future.</para>
      </note>

      <para>The life cycle of a constraint validation implementation instance
      is undefined. Compliant implementations are allowed to cache
      <classname>ConstraintValidator</classname> instances retrieved from the
      <classname>ConstraintValidatorFactory</classname> or request them every
      time it is needed.</para>

      <!--EBE should we make explicit that instances cannot be shared if the annotations attributes are not the same?-->

      <para>The <methodname>initialize</methodname> method is called by the
      Bean validation provider prior to any use of the constraint
      implementation.</para>

      <para>The <methodname>isValid</methodname> method is evaluated by the
      Bean Validation provider each time a given value is validated. It
      returns <literal>false</literal> if the value is not valid,
      <literal>true</literal> otherwise. <literal>isValid</literal>
      implementations must be thread-safe.</para>

      <para>If the property is of an unanticipated type, an
      <literal>UnexpectedTypeForConstraintException</literal> should be
      raised. <classname>ConstraintValidator</classname> implementations
      should raise this exception themselves if the type is not supported.
      However, constraint designer are encouraged to make use of specialized
      <classname>ConstraintValidator</classname> implementations and delegate
      the type routing to the type matching algorithm described in <xref
      linkend="typevalidatorresolution" />.</para>

      <para>The constraint validation implementation is not allowed to change
      the state of the value passed to
      <methodname>isValid</methodname>.</para>

      <note>
        <para>While not mandatory, it is considered a good practice to split
        the core constraint validation from the not null constraint validation
        (for example, an <classname>@Email</classname> constraint will return
        true on a null object, i.e. will not take care of the
        <classname>@NotNull</classname> validation)</para>

        <para><code>null</code> can have multiple meanings but is commonly
        used to express that a value does not make sense, is not available or
        is simply unknown. Those constraints on the value are orthogonal in
        most cases to other constraints. For example a String, if present,
        must be an email but can be null. Separating both concerns is a good
        practice.</para>

        <!--[SCP: I think this should be mandatory.] I don't think you can: for once, it would prevent from implementing @NotNull or @NotEmpty-->
      </note>

      <para>The <classname>ConstraintValidatorContext</classname> object
      passed to the <methodname>isValid</methodname> method carries
      information and operations available in the context the constraint is
      validated to.</para>

      <example>
        <title>ConstraintValidatorContext interface passed to
        ConstraintValidator.isValid()</title>

        <programlisting>/**
 * Provide contextual data and operation when applying a given constraint validator implementation
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {
	/**
	 * Disable default error message and default ConstraintViolation object generation.
	 * Useful to set a different error message or generate an ConstraintViolation based on
	 * a different property
	 *
	 * @see #addError(String)
	 * @see #addError(String, String)
	 */
	void disableDefaultError();

	/**
	 * @return the current uninterpolated default message
	 */
	String getDefaultErrorMessage();

	/**
	 * Add a new error message. This error message will be interpolated.
	 * &lt;p/&gt;
	 * If isValid returns false, a ConstraintViolation object will be built per error message
	 * including the default one unless #disableDefaultError() has been called.
	 * &lt;p/&gt;
	 * Aside from the error message, ConstraintViolation objects generated from such a call
	 * contains the same contextual information (root bean, path and so on)
	 * &lt;p/&gt;
	 * This method can be called multiple time. One ConstraintViolation instance per
	 * call is created.
	 *
	 * @param message new uninterpolated error message
	 */
	void addError(String message);

	/**
	 * Add a new error message to a given sub property &lt;code&gt;property&lt;/code&gt;.
	 * This error message will be interpolated.
	 * &lt;p/&gt;
	 * If isValid returns false, a ConstraintViolation object will be built
	 * per error message including the default one unless #disableDefaultError()
	 * has been called.
	 * &lt;p/&gt;
	 *
	 * @param message new uninterpolated error message
	 * @param property property name the ConstraintViolation is targeting
	 */
	void addError(String message, String property);
}</programlisting>
      </example>

      <para>The <classname>ConstraintValidatorContext</classname> interface
      allows to redefine the default message error generated when a constraint
      is not valid. By default, each invalid constraint leads to the
      generation of one error object represented by a
      <classname>ConstraintViolation</classname> object. This object is build
      from the default error message as defined by the constraint declaration
      and the context in which the constraint declaration is placed on (bean,
      property, attribute).</para>

      <para>The <classname>ConstraintValidatorContext</classname> methods let
      the constraint implementation disable the default error object
      generation and create one or more custom ones. The uninterpolated
      message passed as a parameter is used to build the
      <classname>ConstraintViolation</classname> object (the message
      interpolation operation is applied to it). The property on which the
      error object is applied is defined as following:</para>

      <itemizedlist>
        <listitem>
          <para>if property is not overridden, the current context the
          constraint is declared on is used (bean or property)</para>
        </listitem>

        <listitem>
          <para>if the property is overridden, the current context the
          constraint is declared on the property passed as a parameter
          relative to the constraint declaration being evaluated</para>
        </listitem>
      </itemizedlist>

      <para>The property can be overridden by calling
      <methodname>ConstraintValidatorContext.addError(String,
      String)</methodname>.</para>

      <section id="constraintsdefinitionimplementation-validationimplementation-example">
        <title>Example</title>

        <example>
          <title>Length constraint Validator</title>

          <programlisting>/**
 * Check that a string length is between min and max
 *
 */
public class LengthConstraintValidator implements ConstraintValidator&lt;Length, String&gt; {
    private int min;
    private int max;
<!--SCP: does this take a Map as its input to support XML descriptor, or do we map the XML descriptor into a Length instance?
EBE: The second option-->
    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Length constraint) {
        min = constraint.min();
        max = constraint.max();
<!--SCP: is best practice here to just keep a reference to the Length? Since there will be one LengthConstraint for each Length instance
EBE in real life, I expect some preprocessing anyway, so keeping the annotations as a data container probably does not make a lot of sense generally speaking
Note that generally speaking one "LengthConstraint for each Length instance" is not guaranteed. -->
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        
        int length = value.length();
        return length &gt;= min &amp;&amp; length &lt;= max;
    }
}</programlisting>
        </example>

        <para>This constraint Validator checks that the string's length is
        between min and max. It also demonstrates an interesting best
        practice: return <literal>true</literal> on a null parameter</para>

        <para>The next example shows how to use
        <classname>ConstraintValidatorContext</classname>.</para>

        <example>
          <title>Use of ConstraintValidatorContext</title>

          <programlisting>/**
 * Check that a string length is between min and max
 * Error messages are using either key:
 *  - constraint.length.min if the min limit is reached
 *  - constraint.length.max if the max limit is reached
 */
public class FineGrainedLengthConstraintValidator 
             implements ConstraintValidator&lt;Length, String&gt; {
    private int min;
    private int max;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Length constraint) {
        min = constraint.min();
        max = constraint.max();
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        int length = value.length();

        //remove default error
        context.disableDefaultError();

        if (length &lt; min) {
            //add min specific error
            context.addError( "{constraint.length.min}" );
            return false;
        }
        if (length &gt; max) {
            //add max specific error
            context.addError( "{constraint.length.max}" );
            return false;
        }
        return true;
    }
}</programlisting>
        </example>

        <para>The default error message is disabled and replaced by a specific
        error message depending on the type of constraint violation detected.
        In this case, only one error report is returned at a given time but a
        constraint validation implementation can return several error
        reports.</para>
      </section>
    </section>

    <section id="constraintsdefinitionimplementation-constraintfactory">
      <title>The ConstraintValidatorFactory</title>

      <para>Constraint validation implementation instances are created by a
      <classname>ConstraintValidatorFactory</classname>.</para>

      <programlisting>/**
 * Instantiate a &lt;code&gt;ConstraintValidator&lt;/code&gt; instance from its class.
 * The &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate.
     *
     * @return A constraint validator instance of the specified class.
     */
    &lt;T extends ConstraintValidator&lt;?,?&gt;&gt; T getInstance(Class&lt;T&gt; key);
}</programlisting>

      <para>The default <classname>ConstraintValidatorFactory</classname>
      provided by the Bean Validation provider implementation uses the public
      constraint no-arg constructor. A custom constraint Validator factory can
      be provided for example to benefit from dependency injection control in
      constraint implementations. Any constraint implementation relying on
      <classname>ConstraintValidatorFactory</classname> behaviors specific to
      an implementation (dependency injection, no no-arg constructor and so
      on) are not considered portable, hence great care should be given before
      walking that path.</para>

      <para><classname>ConstraintValidatorFactory</classname> should not cache
      instances as the state of each instance can be altered in the initialize
      method.</para>
    </section>
  </chapter>

  <chapter id="constraintdeclarationvalidationprocess">
    <title>Constraint declaration and validation process</title>

    <para>The Bean Validation specification defines a framework for declaring
    constraints on JavaBean classes, fields and properties.</para>

    <para>Constraints are declared on types and evaluated against instances or
    graphs of instances.</para>

    <section id="constraintdeclarationvalidationprocess-requirements">
      <title>Requirements on classes to be validated</title>

      <para>Objects that are to be validated must fulfill the following
      requirements.</para>

      <para>Properties to be validated must follow the method signature
      conventions for JavaBeans read properties, as defined by the JavaBeans
      specification.</para>

      <para>Static fields and static methods are excluded from
      validation.</para>

      <para>Constraints can be applied to interfaces and superclasses.</para>

      <para>The target of an annotation definition can be a field, property,
      or type, provided that:</para>

      <itemizedlist>
        <listitem>
          <para>the constraint definition supports the specified target
          (<classname>java.lang.annotation.Target</classname>)</para>
        </listitem>

        <listitem>
          <para>the constraint supports the declared type of the target (see
          <xref linkend="typevalidatorresolution" />).</para>
        </listitem>
      </itemizedlist>

      <section id="constraintdeclarationvalidationprocess-requirements-object">
        <title>Object validation</title>

        <para>Constraint declarations can be applied to a class or an
        interface. Applying a constraint to a class or interface expresses a
        validation over the state of the class or interface.</para>
      </section>

      <section id="constraintdeclarationvalidationprocess-requirements-property">
        <title>Field and property validation</title>

        <para>Constraint declarations can be applied on both fields and
        properties for the same object type. The same constraint should
        however not be duplicated between a field and its associated property
        (the constraint validation would be applied twice). It is recommended
        for objects holding constraint declarations to adhere to a single
        state access strategy (either annotated fields or properties).</para>

        <para>When a field is annotated with a constraint declaration, field
        access strategy is used to access the state validated by such
        constraint.</para>

        <para>When a property is annotated with a constraint declaration,
        property access strategy is used to access the state validated by such
        constraint.</para>

        <para>When using field access strategy, the bean validation provider
        accesses the instance variable directly. When using the property
        access strategy, the bean validation provider accesses the state via
        the property accessor method. It is required that the class follows
        the method signature conventions for JavaBeans read properties (as
        defined by the JavaBeans <classname>Introspector</classname> class)
        for constrained properties when constrained properties are used. In
        this case, for every constraint property of type
        <classname>T</classname>, there is a getter method,
        <methodname>get&lt;Property-name&gt;</methodname>. For
        <code>boolean</code> properties,
        <methodname>is&lt;Property-name&gt;</methodname> is an alternative
        name for the getter method. Specifically, if
        <methodname>getX</methodname> is the name of the getter method, where
        <classname>X</classname> is a string, the name of the persistent
        property is defined by the result of
        <code>java.beans.Introspector.decapitalize(X)</code>.</para>

        <para>The fields or methods visibility are not constrained.</para>
      </section>

      <section>
        <title>Graph validation</title>

        <para>In addition to supporting instance validation, validation of
        graphs of object is also supported. The result of a graph validation
        is returned as a single list of constraint violations.</para>

        <para>Consider the situation where bean <classname>X</classname>
        contains a field of type <classname>Y</classname>. By annotating field
        <classname>Y</classname> with the <classname>@Valid</classname>
        annotation, the Validator will validate <classname>Y</classname> (and
        its properties) when <classname>X</classname> is validated. The exact
        type <classname>Z</classname> of the value contained in the field
        declared of type <classname>Y</classname> (subclass, implementation)
        is determined at runtime. The constraint definitions of
        <classname>Z</classname> are used. This ensures proper polymorphic
        behavior.</para>

        <para>Collection-valued or array-valued fields and properties may also
        be decorated with the <classname>@Valid</classname> annotation. This
        causes the contents of the collection or array to be validated. The
        following types are supported:</para>

        <itemizedlist>
          <listitem>
            <para>any array of object</para>
          </listitem>

          <listitem>
            <para><classname>java.util.Collection</classname></para>
          </listitem>

          <listitem>
            <para><classname>java.util.Set</classname></para>
          </listitem>

          <listitem>
            <para><classname>java.util.List</classname></para>
          </listitem>

          <listitem>
            <para><classname>java.util.Map</classname></para>
          </listitem>
        </itemizedlist>

        <para>Each object stored in the array or collection is validated. For
        <classname>Map</classname>, the value of each entry is validated (the
        key is not validated). Like regular references, it's type is
        determined at runtime and the constraint definitions for this
        particular type are used.</para>

        <para>The <classname>@Valid</classname> annotation is applied
        recursively. A conforming implementation avoids infinite loops by
        validating an object the first time it is encountered in the graph,
        and ignores it if it is encountered again via a different path.</para>

        <warning>
          <para>Question: this rule does not guarantee a full deterministic
          behavior if an object is present several times in the graph. Should
          we adjust the rule to ensure deterministic behavior at the risk of
          validating an object more than one time, but still preventing
          infinite loop?</para>
        </warning>
      </section>
    </section>

    <section>
      <title>Constraint declaration</title>

      <para>Constraint declarations are placed on classes or interfaces
      primarily through annotations. A constraint annotation (see <xref
      linkend="constraintsdefinitionimplementation-constraintdefinition" />),
      can be applied to a type, on any of the type's fields or on any of the
      JavaBeans-compliant properties.</para>

      <para>When a constraint is defined on a class, the class instance being
      validated is passed to the constraint Validator. When a constraint is
      defined on a field, the value of the field is passed to the constraint
      Validator. When a constraint is defined on a getter, the result of the
      getter invocation is passed to the constraint Validator.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-inheritance">
      <title>Inheritance (interface and superclass)</title>

      <para>A constraint declaration can be placed on an interface. For a
      given class, constraint declarations held on superclasses as well as
      interfaces are evaluated by the Validator. Rules are formally described
      in <xref
      linkend="constraintdeclarationvalidationprocess-groupsequence-formaldefinition" />.</para>

      <para>The effect of constraint declarations is cumulative. Constraints
      declared on a superclass getter will be validated along with any
      constraints defined on an overridden version of the getter.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-groupsequence">
      <title>Group and group sequence</title>

      <para>A group defines a subset of constraints. Instead of validating all
      constraints for a given object graph, only a subset is validated
      depending on the group targeted. Each constraint declaration defines the
      list of groups it belongs to. If no group is explicitly declared, a
      constraint belongs to the <classname>Default</classname> group.</para>

      <para>Groups are represented by interfaces.</para>

      <example>
        <title>Definition of groups</title>

        <programlisting>/**
 * Validation group checking a user is billable
 */
public interface Billable {}

/**
 * customer can buy without harrassing checking process
 */
public interface BuyInOneClick {
}</programlisting>
      </example>

      <para>A constraint can belong to one or more groups.</para>

      <example id="example-assigngrouptoconstraints">
        <title>Assign groups to constraints</title>

        <programlisting>/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class, BuyInOneClick.class})
    private CreditCard defaultCreditCard;
}</programlisting>
      </example>

      <para>During the validation call, one or more groups are validated. All
      the constraints belonging to this set of group is evaluated on the
      object graph. In <xref linkend="example-assigngrouptoconstraints" />,
      <classname>@NotNull</classname> is checked on
      <literal>defaultCreditCard</literal> when either the
      <classname>Billable</classname> or <classname>BuyInOneClick</classname>
      group is validated. <classname>@NotNull</classname> on
      <literal>firstname</literal> and on <literal>lastname</literal> are
      validated when the <classname>Default</classname> group is validated.
      Reminder: constraints held on superclasses and interfaces are
      considered.</para>

      <para><classname>Default</classname> is a group predefined by the
      specification</para>

      <programlisting>package javax.validation.groups;

/**
 * Default Bean Validation group
 *
 * @author Emmanuel Bernard
 */
public interface Default {
}</programlisting>

      <section id="constraintdeclarationvalidationprocess-groupsequence-groupinheritance">
        <title>Group inheritance</title>

        <para>In some situations, a group is a super set of one or more
        groups. This can be described by Bean Validation. A group can inherit
        one or more groups by using interface inheritance.</para>

        <example>
          <title>Groups can inherit other groups</title>

          <programlisting>/**
 * Customer can buy without harrassing checking process
 */
public interface BuyInOneClick extends Default, Billable {
}</programlisting>
        </example>

        <para>For a given interface <classname>Z</classname>, constraints
        marked as belonging to the group <classname>Z</classname> (ie where
        the annotation <methodname>groups</methodname> property contains the
        interface <classname>Z</classname>) or any of the super interfaces of
        <classname>Z</classname> (inherited groups) are considered part of the
        group <classname>Z</classname>.</para>

        <para>In the following example:</para>

        <example>
          <title>Use of a inherited group</title>

          <programlisting>/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class})
    private CreditCard defaultCreditCard;
}</programlisting>
        </example>

        <para>validating the group <classname>BuyInOneClick</classname> will
        lead to the following constraints checking:</para>

        <itemizedlist>
          <listitem>
            <para><classname>@NotNull</classname> on
            <literal>firstname</literal> and
            <literal>lastname</literal></para>
          </listitem>

          <listitem>
            <para><classname>@NotNull</classname> on
            <literal>defaultCreditCard</literal></para>
          </listitem>
        </itemizedlist>

        <para>because <classname>Default</classname> and
        <classname>Billable</classname> are subinterfaces of
        <classname>BuyInOneClick</classname>.</para>
      </section>

      <section id="constraintdeclarationvalidationprocess-groupsequence-groupsequence">
        <title>Group sequence</title>

        <para>By default, constraints are evaluated in no particular order and
        this regardless of which groups they belong to. It is however useful
        in some situations to to control the order of constraints evaluation.
        There are often scenarios where a preliminary set of constraints
        should be evaluated prior to other constraints. Here are two
        examples:</para>

        <itemizedlist>
          <listitem>
            <para>The second group depends on a stable state to run properly.
            This stable state is verified by the first previous group.</para>
          </listitem>

          <listitem>
            <para>The second group is a heavy consumer of time, CPU or memory
            and its evaluation should be avoided if possible.</para>
          </listitem>
        </itemizedlist>

        <para>To implement such ordering, a group can be defined as a sequence
        of other groups. Each group in a group sequence must be processed
        sequentially in the order defined by
        <methodname>@GroupSequence.sequence</methodname> when the group
        defined as a sequence is requested. Processing a group is defined in
        <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />
        ; if one of the groups processed in the sequence generates one or more
        constraint violation, the groups following in the sequence must not be
        processed. This ensure that a set of constraint is evaluated only if
        another set of constraint is valid.</para>

        <para>Groups defining a sequence and groups composing a sequence must
        not be involved in a cyclic dependency either directly or indirectly,
        either through cascaded sequence definition or group
        inheritance.</para>

        <warning>
          <para>Should we constraint group defining a sequence? Ie. can group
          defining a sequence be used in constraint declarations explicitly?
          Think about implications in the resolution algorithm.</para>
        </warning>

        <para>To define a group as a sequence, the interface must be annotated
        with the <classname>@GroupSequence</classname> annotation.</para>

        <programlisting>@Target({TYPE})
@Retention(RUNTIME)
public @interface GroupSequence {
    Class&lt;?&gt;[] sequence();
}</programlisting>

        <para>Here is a usage example</para>

        <example id="example-groupsequence">
          <title>Make use of group sequence</title>

          <programlisting>@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check conherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}

    /**
     * check both basic constraints and high level ones.
     * high level constraints are not cheked if basic constraints fail
     */
    @GroupSequence(sequence = {Default.class, HighLevelCoherence.class})
    public interface Complete {}
}</programlisting>
        </example>

        <para>In <xref linkend="example-groupsequence" />, when the
        <classname>Address.Complete</classname> group is validated, all
        constraints belonging to the <classname>Default</classname> group are
        validated. If any of them fail, the validation skips the
        <classname>HighLevelCoherence</classname> group. If all
        <classname>Default</classname> constraints pass,
        <classname>HighLevelCoherence</classname> constraints are
        evaluated.</para>

        <note>
          <para>A given constraint can belong to two groups ordered by a
          sequence. In this case, the constraint is evaluated as part of the
          first group and ignored in the subsequent group(s). See <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine" />
          for more informations.</para>
        </note>

        <!--Make explicit what happens if a group is part of a group sequence and also explicitly called in validator.validate()-->
      </section>

      <section id="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup">
        <title>Redefining the Default group for a class</title>

        <para>In <xref linkend="example-groupsequence" />, validating the
        <classname>Default</classname> group does not validate
        <classname>HighLevelCoherence</classname> constraints. To ensure a
        complete validation, a user must use the
        <classname>Complete</classname> group. This breaks some of the
        encapsulation you could expect. You can work around this by redefining
        what the <classname>Default</classname> group means for a given class.
        To redefine <classname>Default</classname> for a class, place a
        <classname>@GroupSequence</classname> annotation on the class ; this
        sequence expresses the sequence of groups that does substitute
        <classname>Default</classname> for this class.</para>

        <example id="example-overridedefaultgroup">
          <title>Redefining Default group for Address</title>

          <programlisting>@GroupSequence(sequence={Address.class, HighLevelCoherence.class})
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check conherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}
}</programlisting>
        </example>

        <para>In <xref linkend="example-overridedefaultgroup" />, when an
        address object is validated for the group
        <classname>Default</classname>, all constraints belonging to the group
        <classname>Default</classname> and hosted on
        <classname>Address</classname> are evaluated. If none fails, all
        <classname>HighLevelCoherence</classname> constraints present on
        <classname>Address</classname> are evaluated. In other words, when
        validating the <classname>Default</classname> group for
        <classname>Address</classname>, the group sequence defined on the
        <classname>Address</classname> class is used.</para>

        <para>Since sequences cannot have circular dependencies, using
        <classname>Default</classname> in the declaration of a sequence is not
        an option. Constraints hosted on a class <classname>A</classname> and
        belonging to the <classname>Default</classname> group (by default or
        explicitly) implicitly belong to the group
        <classname>A</classname>.</para>

        <para>A sequence defined on a class <classname>A</classname> (ie.
        redefining the <classname>Default</classname> groups for the class)
        must contain the group <classname>A</classname>. In other words, the
        default constraints hosted on a class must be part of the sequence
        definition.</para>
      </section>

      <section id="constraintdeclarationvalidationprocess-groupsequence-implicitgrouping">
        <title>Implicit grouping</title>

        <para>It is possible to implicitly group some constraints in the same
        group without explicitly listing such a group in the constraint
        declaration. Every constraint hosted on an interface
        <classname>Z</classname> and part of the
        <classname>Default</classname> group (implicitly or explicitly)
        belongs to the group <classname>Z</classname>. This is useful to
        validate the partial state of an object based on a role represented by
        an interface.</para>

        <example>
          <title>Example of interface / group hosting constraints</title>

          <programlisting>/**
 * Auditable object contract
 */
public interface Auditable {
    @NotNull String getCreationDate();
    @NotNull String getLastUpdate();
    @NotNull String getLastModifier();
    @NotNull String getLastReader();
}

/**
 * Represents an order in the system
 */
public class Order implements Auditable {
    private String creationDate;
    private String lastUpdate;
    private String lastModifier;
    private String lastReader;

    private String orderNumber;

    public String getCreationDate() {
        return this.creationDate;
    }

    public String getLastUpdate() {
        return this.lastUpdate;
    }

    public String getLastModifier() {
        return this.lastModifier;
    }

    public String getLastReader() {
        return this.lastReader;
    }

    @NotNull @Size(min=10, max=10)
    public String getOrderNumber() {
        return this.orderNumber;
    }
}</programlisting>
        </example>

        <para>When an <classname>Order</classname> object is validated on the
        <classname>Default</classname> group, the following constraints are
        validated: <classname>@NotNull</classname> on
        <methodname>getCreationDate</methodname>,
        <methodname>getLastUpdate</methodname>,
        <methodname>getLastModifier</methodname>,
        <methodname>getLastReader</methodname>,
        <methodname>getOrderNumber</methodname> and
        <classname>@Size</classname> on
        <methodname>getOrderNumber</methodname> as all belong to the
        <classname>Default</classname> group.</para>

        <para>When an <classname>Order</classname> object is validated on the
        <classname>Auditable</classname> group, the following constraints are
        validated: <classname>@NotNull</classname> on
        <methodname>getCreationDate</methodname>,
        <methodname>getLastUpdate</methodname>,
        <methodname>getLastModifier</methodname>,
        <methodname>getLastReader</methodname>. Only the constraints present
        on <classname>Auditable</classname> (and any of its super interfaces)
        and belonging to the <classname>Default</classname> group are
        validated when the group <classname>Auditable</classname> is
        requested. It allows the caller to validate that a given object can be
        safely audited even if the object state itself is not valid.</para>
      </section>

      <section id="constraintdeclarationvalidationprocess-groupsequence-formaldefinition">
        <title>Formal definitions</title>

        <para>The formal rules defining groups are as followed. <emphasis>Text
        in italic are comments about the rules.</emphasis></para>

        <para>For every class <classname>X</classname>:</para>

        <itemizedlist>
          <listitem>
            <para>A. For each superclass <classname>Y</classname> of
            <classname>X</classname>, the group <classname>Y</classname>
            contains all constraints of the group <classname>Y</classname> of
            <classname>Y</classname></para>

            <para><emphasis>this rule prepares formal concepts for recursive
            discovery</emphasis></para>
          </listitem>

          <listitem>
            <para>B. The group <classname>X</classname> contains the following
            constraints:</para>

            <para><emphasis>group <classname>X</classname> is a group used on
            sequences redefining the default group on a class (see <xref
            linkend="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" />)</emphasis></para>

            <orderedlist>
              <listitem>
                <para>every constraint declared by the class
                <classname>X</classname> which does not declare a group or
                does declare the group <classname>Default</classname>
                explicitly.</para>

                <para><emphasis>all <classname>Default</classname> constraints
                hosted on <classname>X</classname></emphasis></para>
              </listitem>

              <listitem>
                <para>every constraint declared by any interface implemented
                by <classname>X</classname> and not annotated
                <classname>@GroupSequence</classname> which does not
                explicitly declare a group or does declare the group
                <classname>Default</classname> explicitly.</para>

                <para><emphasis>all <classname>Default</classname> constraints
                hosted on interfaces of <classname>X</classname>: constraints
                are inherited by the class hierarchy</emphasis></para>
              </listitem>

              <listitem>
                <para>if <classname>X</classname> has a direct superclass
                <classname>Y</classname>, every constraint in the group
                <classname>Y</classname></para>

                <para><emphasis>all <classname>Default</classname> constraints
                hosted on the superclasses of <classname>X</classname>:
                constraints are inherited by the class
                hierarchy</emphasis></para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>C. If <classname>X</classname> has no
            <classname>@GroupSequence</classname> annotation, the group
            <classname>Default</classname> contains the following
            constraints:</para>

            <para><emphasis>this rule defines which constraints are evaluated
            when validating <classname>Default</classname> on
            <classname>X</classname>.</emphasis></para>

            <orderedlist>
              <listitem>
                <para>every constraint in the group
                <classname>X</classname></para>
              </listitem>

              <listitem>
                <para>if <classname>X</classname> has a direct superclass
                <classname>Y</classname>, every constraint in the group
                <classname>Default</classname> of
                <classname>Y</classname></para>

                <para><emphasis>this rule is necessary in case
                <classname>Y</classname> redefines the group
                <classname>Default</classname></emphasis></para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>D. If <classname>X</classname> does have a
            <classname>@GroupSequence</classname> annotation, the group
            <classname>Default</classname> contains every constraint belonging
            to every group declared by the
            <classname>@GroupSequence</classname> annotation.</para>

            <para><emphasis>this rule describes how a class can redefine the
            group <classname>Default</classname> for itself (see <xref
            linkend="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" />)</emphasis></para>

            <itemizedlist>
              <listitem>
                <para>the <classname>@GroupSequence</classname> annotation
                must declare the group <classname>X</classname></para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>E. For every interface <classname>Z</classname>, the group
            <classname>Z</classname> contains the following
            constraints:</para>

            <para><emphasis>this rule defines how non
            <classname>Default</classname> groups are
            defined</emphasis></para>

            <orderedlist>
              <listitem>
                <para>every constraint declared by the interface
                <classname>Z</classname> which does not explicitly declare a
                group or does declare the group <classname>Default</classname>
                explicitly.</para>

                <para><emphasis>all <classname>Default</classname> constraints
                hosted on <classname>Z</classname>: this rule formally defines
                implicit grouping per interface (see <xref
                linkend="constraintdeclarationvalidationprocess-groupsequence-implicitgrouping" />)</emphasis></para>
              </listitem>

              <listitem>
                <para>every constraint declared by any superinterface not
                annotated <classname>@GroupSequence</classname> of the
                interface <classname>Z</classname> which does not explicitly
                declare a group</para>

                <para><emphasis>all <classname>Default</classname> constraints
                hosted on interfaces of <classname>Z</classname>: groups can
                be inherited (see <xref
                linkend="constraintdeclarationvalidationprocess-groupsequence-groupinheritance" />)</emphasis></para>
              </listitem>

              <listitem>
                <para>every constraint declared by the class
                <classname>X</classname> which explicitly declares the group
                <classname>Z</classname></para>

                <para><emphasis>every constraint hosted by
                <classname>X</classname> and marked as belonging to the group
                <classname>Z</classname></emphasis></para>
              </listitem>

              <listitem>
                <para>every constraint declared by any interface implemented
                by <classname>X</classname> and not annotated
                <classname>@GroupSequence</classname> which explicitly
                declares the group <classname>Z</classname></para>

                <para><emphasis>every constraint hosted by any interface of
                <classname>X</classname> and marked as belonging to the group
                <classname>Z</classname></emphasis></para>
              </listitem>

              <listitem>
                <para>if <classname>X</classname> has a direct superclass
                <classname>Y</classname>, every constraint in the group
                <classname>Z</classname> of <classname>Y</classname></para>

                <para><emphasis>every constraint hosted by any superclass of
                <classname>X</classname> and marked as belonging to the group
                <classname>Z</classname></emphasis></para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>F. For every interface <classname>Z</classname> annotated
            <classname>@GroupSequence</classname>, the group
            <classname>Z</classname> contains every constraint belonging to
            every group declared by the <classname>@GroupSequence</classname>
            annotation.</para>

            <para><emphasis>defines the composition side of group sequence but
            does not define the ordering behavior of sequence (see <xref
            linkend="constraintdeclarationvalidationprocess-groupsequence-groupsequence" />)</emphasis></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="constraintdeclarationvalidationprocess-validationroutine">
      <title>Validation routine</title>

      <para>For a given group to validate, the validation routine applied on a
      given bean instance is expected to execute the constraint validations in
      no particular order unless specified:</para>

      <itemizedlist>
        <listitem>
          <para>for all traversable fields, execute all field level
          validations (including the ones expressed on interfaces and
          superclasses) matching the targeted group unless the given
          validation constraint has already been processed during this
          validation routine (as part of a previous group match)</para>
        </listitem>

        <listitem>
          <para>for all traversable getters, execute all getter level
          validations (including the ones expressed on interfaces and
          superclasses) matching the targeted group unless the given
          validation constraint has already been processed during this
          validation routine (as part of a previous group match)</para>
        </listitem>

        <listitem>
          <para>execute all class level validations (including the ones
          expressed on interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine (as part of a previous
          group match)</para>
        </listitem>

        <listitem>
          <para>for all traversable associations, execute all cascading
          validations (see <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation" />)
          including the ones expressed on interfaces and superclasses</para>
        </listitem>
      </itemizedlist>

      <para>Traversable fields, getters and associations are defined in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine-traversable" />.</para>

      <para>Note that it implies that a given validation constraint will not
      be processed more than once per validation. More than one group can be
      validated according to the above rules provided that the ordering rules
      defined by sequence definitions are respected.</para>

      <!--SCP: note that grouping, as currently defined cannot control depth of search in the graph
EBE: correct, so far I don't think it's useful-->

      <para>The object validation routine is described as such. For each
      constraint declaration:</para>

      <itemizedlist>
        <listitem>
          <para>determine for the constraint declaration, the appropriate
          <classname>ConstraintValidator</classname> to use (see <xref
          linkend="typevalidatorresolution" />).</para>
        </listitem>

        <listitem>
          <para>execute the <methodname>isValid</methodname> operation (from
          the constraint validation implementation) on the appropriate data
          (see <xref
          linkend="constraintsdefinitionimplementation-validationimplementation" />)</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns true, continue to
          the next constraint,</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns false, the Bean
          Validation provider populates
          <classname>ConstraintViolation</classname> object(s) according to
          the rules defined in <xref
          linkend="constraintsdefinitionimplementation-validationimplementation" />
          and appends these objects to the list of returned invalid
          violations.</para>

          <!--SCP: note that this implies that validation issues are returned in the order they are discovered
EBE: is that a problem?-->
        </listitem>
      </itemizedlist>

      <para>Bean Validation is a fully polymorphic framework. Constraints are
      gathered according to the object type determined at runtime.</para>

      <section id="constraintdeclarationvalidationprocess-validationroutine-graphvalidation">
        <title>Object graph validation</title>

        <para>The <classname>@Valid</classname> annotation on a given
        association (i.e. object reference or collection / array of objects),
        dictates the Bean Validator implementation to apply recursively the
        bean validation routine on (each of) the associated object(s). This
        mechanism is recursive: an associated object can itself contain
        cascaded references. The Bean Validation implementation must ignore
        the cascading operation if the associated object instance has already
        been validated by the current validation routine, thus preventing
        infinite loops.</para>

        <para>The <classname>ConstraintViolation</classname> objects, built
        when a failing constraint on an associated object is found, reflects
        the path to reach the object from the root validated object (See <xref
        linkend="validationapi-constraintviolation" />).</para>
      </section>

      <section id="constraintdeclarationvalidationprocess-validationroutine-traversable">
        <title>Traversable property</title>

        <para>In some cases, the state of some properties should not be
        accessed. For example, if a property loaded by a Java Persistence
        provider is a lazy property or a lazy association, accessing its state
        would trigger a load from the database. An undesired behavior.</para>

        <para>Bean Validation offers a way to control which property can and
        cannot be accessed via the <classname>TraversableResolver</classname>
        contract.</para>

        <programlisting>/**
 * Contract determining if a property can be accessed by the Bean Validation provider
 * This contract is called for each property either validated or traversed.
 *
 * A traversable resolver implementation must me thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface TraversableResolver {
    /**
     * Determine if a property can be traversed by Bean Validation.
     *
     * @param traversableObject object hosting &lt;code&gt;traversableProperty&lt;/code&gt;.
     * @param traversableProperty name of the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to the &lt;code&gt;traversableProperty&lt;/code&gt;
     *        (using the path specification defined by Bean Validator).
     * @param elementType either &lt;code&gt;FIELD&lt;/code&gt; or &lt;code&gt;METHOD&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the property is traversable by Bean Validation, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isTraversable(Object traversableObject,
                          String traversableProperty,
                          Class&lt;?&gt; rootBeanType,
                          String pathToTraversableObject,
                          ElementType elementType);
}</programlisting>

        <para><literal>traversableObject</literal> is the object instance
        being evaluated.</para>

        <para><literal>traversableProperty</literal> is the name of the
        property hosted by the <methodname>traversableObject</methodname>
        being considered for traversal. The name of a property is defined in
        <xref
        linkend="constraintdeclarationvalidationprocess-requirements-property" />.</para>

        <para><literal>rootBeanType</literal> is the class of the root being
        validated (and passed to the <methodname>validate</methodname>
        method).</para>

        <para><literal>pathToTraversableObject</literal> is the path from the
        <methodname>rootBeanType</methodname> down to the
        <methodname>traversableObject</methodname> (it is an empty string if
        the <methodname>rootBeanPath</methodname> is the
        <methodname>traversableObject</methodname>). The path is described
        following the conventions described in <xref
        linkend="validationapi-constraintviolation" />
        (<methodname>getPropertyPath</methodname>).</para>

        <para><literal>elementType</literal> is the
        <classname>java.lang.annotation.ElementType</classname> the annotation
        is placed on. It can be either <literal>FIELD</literal> or
        <literal>METHOD</literal>. Any other value is not expected.</para>

        <para>The Bean Validation provider must not access the state of a
        property, nor validate its constraints if the property is not
        traversable. A property is traversable if
        <classname>TraversableResolver</classname> returns true for this
        property.</para>

        <para>The example assumes the following object graph</para>

        <programlisting>public class Country {
    @NotNull private String name;
    @Length(max=2) private String ISO2Code;
    @Length(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Length(max=30)
    private String addressline1;
    @Length(max=30)
    private String addressline2;
    @Length(max=11)
    private String zipCode;
    @NotNull @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Length(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</programlisting>

        <para>and assumes the validation operation is applied on an address
        object. When the Bean Validation provider is about to check
        constraints of <literal>ISO3Code</literal>, it calls the
        <classname>TraversableResolver</classname> instance to ensure that the
        <literal>ISO3Code</literal> property is traversable with the following
        parameter values:</para>

        <itemizedlist>
          <listitem>
            <para><literal>traversableObject</literal>: country. The instance
            returned by <code>address.getCountry()</code>.</para>
          </listitem>

          <listitem>
            <para><literal>traversableProperty</literal>: "ISO3Code". The name
            of the property of <literal>traversableObject</literal> being
            verified.</para>
          </listitem>

          <listitem>
            <para><methodname>rootBeanType</methodname>: Address.class. The
            type of the root object being validated.</para>
          </listitem>

          <listitem>
            <para><literal>pathtoTraversableObject</literal>: "country". The
            path from address to the country instance.</para>
          </listitem>

          <listitem>
            <para><literal>elementType</literal>:
            <classname>ElementType.FIELD</classname>. The country property is
            annotated on the field.</para>
          </listitem>
        </itemizedlist>

        <example>
          <title>Java Persistence aware TraversableResolver</title>

          <programlisting>public class JPATraversableResolver implements TraversableResolver {

    boolean isTraversable(Object traversableObject,
                          String traversableProperty,
                          Class&lt;?&gt; rootBeanType,
                          String pathToTraversableObject,
                          ElementType elementType) {

        return Persistence.isLoaded(traversableObject, traversableProperty);
    }
}</programlisting>
        </example>

        <para>The traversable resolver used by default in a Bean Validation
        behaves as followed:</para>

        <itemizedlist>
          <listitem>
            <para>if Java Persistence is available in the runtime environment,
            a property is considered traversable if Java Persistence considers
            the property as loaded. A typical implementation will use
            <code>Persistence.isLoaded(Object, String)</code> to implement
            such contract.</para>
          </listitem>

          <listitem>
            <para>if Java Persistence is not available in the runtime
            environment, all properties are considered traversable.</para>
          </listitem>
        </itemizedlist>

        <para>See <xref linkend="bootstrapping" /> to know how to pass a
        custom <classname>TraversableResolver</classname>.</para>
      </section>

      <section id="typevalidatorresolution">
        <title>ConstraintValidator resolution algorithm</title>

        <para>A constraint is associated to one or more
        <classname>ConstraintValidator</classname> implementations. Each
        <classname>ConstraintValidator&lt;A, T&gt;</classname> accepts the
        type <classname>T</classname>. The
        <classname>ConstraintValidator</classname> executed depends on the
        type declared by the target hosting the constraint. For a given
        constraint evaluation, a single
        <classname>ConstraintValidator</classname> is considered.</para>

        <para>If the constraint is hosted on a class or an interface, the
        targeted type is the class or the interface. If the constraint is
        hosted on a class attribute, the type of the attribute is the targeted
        type. If the constraint is hosted on a getter, the return type of the
        getter is the targeted type.</para>

        <para>The rules written below describe formally the following
        statement: the <classname>ConstraintValidator</classname> chosen to
        validate a declared type <classname>T</classname> is the one where the
        type supported by the <classname>ConstraintValidator</classname> is a
        supertype of <classname>T</classname> and where there is no other
        <classname>ConstraintValidator</classname> whose supported type is a
        supertype of <classname>T</classname> and not a supertype of the
        chosen <classname>ConstraintValidator</classname> supported
        type.</para>

        <para>When validating a constraint A placed on a target declaring the
        type <classname>T</classname>, the following resolution rules
        apply.</para>

        <itemizedlist>
          <listitem>
            <para>Primitive types are considered equivalent to their
            respective primitive wrapper class.</para>
          </listitem>

          <listitem>
            <para>A <classname>ConstraintValidator&lt;A, U&gt;</classname> is
            said to be <emphasis>compliant</emphasis> with
            <classname>T</classname> if <classname>T</classname> is a subtype
            of <classname>U</classname> (according to the<ulink
            url="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10">
            Java Language Specification 3rd edition chapter 4.10
            Subtyping</ulink>). Note that <classname>T</classname> is a
            subtype of <classname>U</classname> if <classname>T</classname> =
            <classname>U</classname>.</para>
          </listitem>

          <listitem>
            <para>If no <classname>ConstraintValidator</classname> compliant
            with <classname>T</classname> is found amongst the
            <classname>ConstraintValidator</classname>s listed by the
            constraint <classname>A</classname>, a
            <classname>UnexpectedTypeForConstraintException</classname> is
            raised.</para>
          </listitem>

          <listitem>
            <para>A <classname>ConstraintValidator&lt;A, U&gt;</classname>
            compliant with <classname>T</classname> is considered
            <emphasis>strictly more specific</emphasis> than a
            <classname>ConstraintValidator&lt;A, V&gt;</classname> compliant
            with <classname>T</classname> if <classname>U</classname> is a
            strict subtype of <classname>V</classname>.
            <classname>U</classname> is a strict subtype of
            <classname>V</classname> if <classname>U</classname> is a subtype
            of <classname>V</classname> and <classname>U</classname> !=
            <classname>V</classname> (according to the<ulink
            url="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10">Java
            Language Specification 3rd edition chapter 4.10
            Subtyping</ulink>).</para>
          </listitem>

          <listitem>
            <para>A <classname>ConstraintValidator&lt;A, U&gt;</classname>
            compliant with <classname>T</classname> is considered maximally
            specific if no other <classname>ConstraintValidator&lt;A,
            V&gt;</classname> compliant with <classname>T</classname> is
            strictly more specific than <classname>ConstraintValidator&lt;A,
            U&gt;</classname>.</para>
          </listitem>

          <listitem>
            <para>If more than one maximally specific
            <classname>ConstraintValidator</classname> is found, a
            <classname>AmbiguousConstraintUsageException</classname> is
            raised.</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>While the Java compiler itself cannot determine if a
          constraint declaration will lead to a
          <classname>UnexpectedTypeForConstraintException</classname> or a
          <classname>AmbiguousConstraintUsageException</classname>, rules can
          be statically checked. A tool such as an IDE or a Java 6 annotation
          processor can apply these rules and prevent a compilation in case of
          ambiguity. The specification encourages Bean Validation provider to
          provide such a tool to their users.</para>
        </note>

        <para>Let's see a couple of declaration their respective
        <classname>ConstraintValidator</classname> resolution. Assuming the
        following definitions:</para>

        <programlisting>[...]
@Constraint(validatedBy={
    SizeValidatorForCollection.class,
    SizeValidatorForSet.class,
    SizeValidatorForSerializable.class })
public @interface Size { ...}

public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&gt; { ... }
public class SizeValidatorForSet implements ConstraintValidator&lt;Size, Set&gt; { ... }
public class SizeValidatorForSerializable implements ConstraintValidator&lt;Size, Serializable&gt; { ... }

public interface SerializableCollection extends Serializable,  Collection {}</programlisting>

        <para>The following resolutions occur.</para>

        <table>
          <title>Resolution of ConstraintValidator for various constraints
          declarations</title>

          <tgroup cols="2">
            <colspec align="center" />

            <thead>
              <row>
                <entry>Declaration</entry>

                <entry>Resolution</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><code>@Size Collection getAddresses() { ...
                }</code></entry>

                <entry><classname>SizeValidatorForCollection</classname>:
                direct match</entry>
              </row>

              <row>
                <entry><code>@Size Collection&lt;?&gt; getAddresses() { ...
                }</code></entry>

                <entry><classname>SizeValidatorForCollection</classname>:
                <classname>Collection</classname> is a direct supertype of
                <classname>Collection&lt;?&gt;</classname></entry>
              </row>

              <row>
                <entry><code>@Size Collection&lt;Address&gt; getAddresses() {
                ... }</code></entry>

                <entry><classname>SizeValidatorForCollection</classname>:
                <classname>Collection</classname> is a direct supertype of
                <classname>Collection&lt;Address&gt;</classname></entry>
              </row>

              <row>
                <entry><code>@Size Set&lt;Address&gt; getAddresses() { ...
                }</code></entry>

                <entry><classname>SizeValidatorForSet</classname>: direct
                supertype of <classname>Set&lt;Address&gt;</classname></entry>
              </row>

              <row>
                <entry><code>@Size SortedSet&lt;Address&gt; getAddresses() {
                ... }</code></entry>

                <entry><classname>SizeValidatorForSet</classname>:
                <classname>Set</classname> is the closest supertype of
                <classname>SortedSet&lt;Address&gt;</classname></entry>
              </row>

              <row>
                <entry><code>@Size SerializableCollection getAddresses() { ...
                }</code></entry>

                <entry><classname>AmbiguousConstraintUsageException</classname>
                <classname>SerializableCollection</classname> is a subtype of
                both <classname>Collection</classname> and
                <classname>Serializable</classname> and neither
                <classname>Collection</classname> nor
                <classname>Serializable</classname> are subtypes of each
                other.</entry>
              </row>

              <row>
                <entry><code>@Size String getName() { ... }</code></entry>

                <entry><classname>UnexpectedTypeForConstraintException</classname>
                none of the <classname>ConstraintValidator</classname> types
                are supertypes of <classname>String</classname>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>Examples</title>

      <para>The first example demonstrates how beans, fields and getters are
      annotated to express some constraints.</para>

      <example>
        <title>Place constraint declarations on the element to
        validate</title>

        <programlisting>@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Length(max=30)
    private String addressline1;

    @Length(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Length(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}</programlisting>
      </example>

      <para>During the validation routine execution on an
      <classname>Address</classname> object,</para>

      <itemizedlist>
        <listitem>
          <para><methodname>addressline1</methodname> field value is passed to
          the <classname>@NotNull</classname> as well as
          <classname>Length</classname> constraint validation
          implementation.</para>
        </listitem>

        <listitem>
          <para><methodname>addressline2</methodname> field value is passed to
          the <classname>@Length</classname> constraint validation
          implementations.</para>
        </listitem>

        <listitem>
          <para><methodname>getCity</methodname> value is passed to the
          <classname>Length</classname> and <classname>@NotNull</classname>
          constraint validation implementations</para>
        </listitem>

        <listitem>
          <para><classname>@ZipCodeCoherenceChecker</classname> is a
          constraint whose validation implementation's
          <methodname>isValid</methodname> method receives the
          <classname>Address</classname> object</para>
        </listitem>
      </itemizedlist>

      <para>The second example demonstrates object graph validation</para>

      <example>
        <title>Define object graph validation</title>

        <programlisting>public class Country {
    @NotNull
    private String name;
    @Length(max=2) private String ISO2Code;
    @Length(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Length(max=30)
    private String addressline1;
    @Length(max=30)
    private String addressline2;
    @Length(max=11)
    private String zipCode;
    <emphasis role="bold">@NotNull @Valid</emphasis>
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Length(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</programlisting>
      </example>

      <para>During the validation routine execution on an
      <classname>Address</classname> object, constraints on
      <methodname>addressLine1</methodname>,
      <methodname>addressLine2</methodname>, <methodname>zipCode</methodname>
      and <methodname>country</methodname> are processed as well as the
      validation of the <classname>Country</classname> object itself, more
      specifically <methodname>country.name</methodname> is checked for
      <classname>@NotNull</classname>, <methodname>ISO2Code</methodname> and
      <methodname>ISO3Code</methodname> are checked for
      <classname>@Length</classname>.</para>

      <para>Assuming that <classname>@NotEmpty</classname> is defined as
      such</para>

      <programlisting>@Documented
@NotNull
@Size(min=1)
@Constraint(validatedBy = NotEmptyConstraintValidator.class)
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
public @interface NotEmpty {
    ...
}</programlisting>

      <para>The third example demonstrates superclass, inheritance and
      composite constraints.</para>

      <example>
        <title>Use inheritance, constraints on superclasses and composite
        constraints</title>

        <programlisting>public interface Person {
    @NotEmpty
    String getFirstName();

    String getMiddleName();
    
    @NotEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}

public class CommonGuest extends customer {}</programlisting>
      </example>

      <para>When validating a <classname>PreferredGuest</classname> the
      following constraints are processed:</para>

      <itemizedlist>
        <listitem>
          <para><classname>@NotEmpty</classname>,
          <classname>@NotNull</classname> and
          <classname>@Size(min=1)</classname> on
          <methodname>firstName</methodname></para>
        </listitem>

        <listitem>
          <para><classname>@NotEmpty</classname>,
          <classname>@NotNull</classname> and
          <classname>@Size(min=1)</classname> on
          <methodname>lastName</methodname></para>
        </listitem>

        <listitem>
          <para><classname>@NotNull</classname> on
          <methodname>customerId</methodname>,
          <classname>@Password</classname> on
          <methodname>password</methodname></para>
        </listitem>

        <listitem>
          <para><classname>@CreditCard</classname> on
          <methodname>guestCreditCardNumber</methodname></para>
        </listitem>
      </itemizedlist>

      <para>When validating <classname>CommonGuest</classname>, the following
      constraints are processed:</para>

      <itemizedlist>
        <listitem>
          <para><classname>@NotEmpty</classname>,
          <classname>@NotNull</classname> and
          <classname>@Size(min=1)</classname> on
          <methodname>firstName</methodname></para>
        </listitem>

        <listitem>
          <para><classname>@NotEmpty</classname>,
          <classname>@NotNull</classname> and
          <classname>@Size(min=1)</classname> on
          <methodname>lastName</methodname></para>
        </listitem>

        <listitem>
          <para><classname>@NotNull</classname> on
          <methodname>customerId</methodname>,
          <classname>@Password</classname> on
          <methodname>password</methodname></para>
        </listitem>
      </itemizedlist>

      <para>The fourth example demonstrates the influence of group
      sequence.</para>

      <example>
        <title>Use groups and group sequence to define constraint
        ordering</title>

        <programlisting><emphasis role="bold">@GroupSequence(sequence={First.class, Second.class, Last.class})</emphasis>
public interface Complete {}

public class Book {
    @NotEmpty(groups=First.class)
    private String title;

    @Length(max=30, groups=Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups=First.class)
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NotEmpty(groups=Last.class)
    private String firstName;
    
    @NotEmpty(groups=First.class)
    private String lastName;

    @Length(max=30, groups=Last.class)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}</programlisting>
      </example>

      <para>Assuming the validation of the <classname>Complete</classname>
      group on the following book instance:</para>

      <programlisting>Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );</programlisting>

      <para>the validation routine will return the following failure:</para>

      <itemizedlist>
        <listitem>
          <para><classname>@NotNull</classname> failure (from
          <classname>@NotEmpty</classname>) on the <literal>title</literal>
          field</para>
        </listitem>
      </itemizedlist>

      <para>As both <methodname>title</methodname> and
      <methodname>author.lastname</methodname> are checked as part of the
      <literal><classname>First</classname></literal> group. If the instance
      is updated:</para>

      <programlisting>book.setTitle( "Les fleurs du mal" );
author.setCompany("Some random publisher with a very very very long name");</programlisting>

      <para>the validation routine will return the following failures:</para>

      <itemizedlist>
        <listitem>
          <para><methodname>author.firstName</methodname> fails to pass the
          <classname>@Size(min=1)</classname> (from
          <classname>NotEmpty</classname>) constraint</para>
        </listitem>

        <listitem>
          <para><methodname>author.company</methodname> fails to pass the
          <classname>Length</classname> constraint</para>
        </listitem>
      </itemizedlist>

      <para>As the <classname>First</classname> and
      <classname>Second</classname> groups pass without failure, the
      <classname>Last</classname> group is going through validation.</para>
    </section>
  </chapter>

  <chapter id="validationapi">
    <title>Validation APIs</title>

    <para>The default package for the Bean Validation APIs is
    <classname>javax.validation</classname></para>

    <section id="validationapi-validatorapi">
      <title>Validator API</title>

      <para>The main Bean Validation API is the
      <classname>javax.validation.Validator</classname> interface.</para>

      <para>A <classname>Validator</classname> instance is able to validate
      instances of beans and their associated objects if any. It is
      recommended to leave the caching of <classname>Validator</classname>
      instances to the <classname>ValidatorFactory</classname>.
      <classname>Validator</classname> implementations are thread-safe.</para>

      <programlisting>/**
 * Validate bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @todo Should Serializable be part of the definition?
 */
public interface Validator {
	/**
	 * Validates all constraints on object.
	 *
	 * @param object object to validate
	 * @param groups groups targeted for validation
	 *               (default to {@link javax.validation.groups.Default})
	 *
	 * @return constraint violations or an empty Set if none
	 *
	 * @throws IllegalArgumentException if object is null
	 */
	&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);

	/**
	 * Validates all constraints on &amp;lt;code&amp;gt;propertyName&amp;lt;/code&amp;gt; property of object
	 *
	 * @param object object to validate
	 * @param propertyName property to validate (ie field and getter constraints)
	 * @param groups groups targeted for validation
	 *               (default to {@link javax.validation.groups.Default})
	 *
	 * @return constraint violations or an empty Set if none
	 *
	 * @throws IllegalArgumentException if object is null or if propertyName is not present
	 */
	&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
													 String propertyName,
													 Class&lt;?&gt;... groups);

	/**
	 * Validates all constraints on &lt;code&gt;propertyName&lt;/code&gt; property
	 * if the property value is &lt;code&gt;value&lt;/code&gt;
	 * &lt;p/&gt;
	 * TODO express limitations of ConstraintViolation in this case
	 *
	 * @param beanType the bean type
	 * @param propertyName property to validate
	 * @param value property value to validate
	 * @param groups groups targeted for validation
	 *               (default to {@link javax.validation.groups.Default})
	 *
	 * @return constraint violations or an empty Set if none
	 * @throws IllegalArgumentException if propertyName is not present
	 */
	&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,
												  String propertyName,
												  Object value,
												  Class&lt;?&gt;... groups);

	/**
	 * Return the descriptor object describing bean constraints
	 * The returned object (and associated objects including ConstraintDescriptors)
     * are immutable.
	 *
	 * @param clazz class type evaluated
	 * @return the bean descriptor for the specified class.
	 */
	BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);
}</programlisting>

      <para><methodname>getConstraintsForClass</methodname> is described in
      <xref linkend="constraintmetadata" />.</para>

      <section id="validationapi-validatorapi-validationmethods">
        <title>Validation methods</title>

        <para><methodname>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validate(T object, Class&lt;?&gt;... groups)</methodname> is used to
        validate a given object. This method implements the logic described in
        <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />.
        A <classname>Set</classname> containing all
        <classname>ConstraintViolation</classname> objects representing the
        failing constraints is returned, an empty <classname>Set</classname>
        is returned otherwise.</para>

        <para><methodname>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validateProperty(T object, String propertyName, Class&lt;?&gt;...
        groups)</methodname> validates a given field or property of an object.
        The property name is the JavaBeans property name (as defined by the
        JavaBeans <classname>Introspector</classname> class). This method
        implements the logic described in <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />
        and applies it only to the given property. <literal>@Valid</literal>
        is not honored by this method. This method is useful for partial
        object validation.</para>

        <para><methodname>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validateValue(Class&lt;T&gt; beanType, String propertyName, Object
        value, Class&lt;?&gt;... groups)</methodname> validates the property
        referenced by <parameter>propertyName</parameter> present on
        <literal>beanType</literal> or any of its superclasses, if the
        property value were <parameter>value</parameter>. This method
        implements the logic described in <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />
        and apply it only to the given property and the given value.
        <literal>@Valid</literal> is not honored by this method. This method
        is useful for ahead of time validation before the JavaBean is
        modified.</para>

        <!--SCP: what values come back in ConstraintViolation for the validateValue() case?
EBE the value passed as a parameter. I think the JavaDoc is clear, should it be made explicit?-->

        <section>
          <title>Examples</title>

          <para>All the examples will be based on the following class
          definition, constraint declarations and address instance.</para>

          <programlisting>public class Address {
    <emphasis role="bold">@NotNull @Length(max=30)</emphasis>
    private String addressline1;

    <emphasis role="bold">@Length(max=30)</emphasis>
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    <emphasis role="bold">@Length(max=30) @NotNull</emphasis>
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales</programlisting>

          <para>The following code will return two
          <classname>ConstraintViolation</classname> objects. One for
          <literal>addressline1</literal> violating
          <literal>@NotNull</literal> and one for <literal>city</literal>
          violating <literal>@Length</literal>.</para>

          <programlisting>validator.validate(address).size() == 2</programlisting>

          <para>The following code will return one
          <classname>ConstraintViolation</classname> since
          <literal>city</literal> violates <literal>@Length</literal> and only
          <literal>city</literal> is validated.</para>

          <programlisting>validator.validateProperty(address, "city").size() == 1</programlisting>

          <para>The following code will return no
          <classname>ConstraintViolation</classname> object because the value
          "Paris" for <literal>city</literal> would not raise any constraint
          failure.</para>

          <programlisting>validator.validateValue("city", "Paris").size() == 0</programlisting>
        </section>
      </section>

      <section id="validationapi-validatorapi-groups">
        <title>groups</title>

        <para>Groups allow you to restrict the set of constraints applied
        during validation. Groups targeted are passed as parameters to the
        <methodname>validate</methodname>,
        <methodname>validateProperty</methodname> and
        <methodname>validateValue</methodname> methods. All constraints
        belonging to the targeted group are applied during the <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />.
        If no group is passed, the
        <literal><classname>Default</classname></literal> group is assumed.
        <xref
        linkend="constraintsdefinitionimplementation-constraintdefinition-groups" />
        describes how to define groups on constraints.</para>

        <section>
          <title>Examples</title>

          <programlisting>/** Validates a minimal set of constraints */
public interface Minimal {}

public class Address {

    @NotEmpty(groups = Minimal.class)
    @Length(max=50)
    private String street1;
    
    @NotEmpty
    private String city;

    @NotEmpty(groups = {Minimal.class, Default.class})
    private String zipCode;
    ...
}</programlisting>

          <para>In the previous example, <classname>@NotEmpty</classname> (and
          it's composing constraints) on <methodname>street1</methodname>
          applies to the group
          <literal><classname>Minimal</classname></literal>,
          <classname>@Length</classname> on <methodname>street1</methodname>
          applies to the group <literal>Default</literal> and
          <classname>@NotEmpty </classname>(and it's composing constraints) on
          <methodname>zipCode</methodname> applies to the groups
          <literal><classname>Default</classname></literal> and
          <literal><classname>Minimal</classname></literal>.</para>

          <programlisting>validator.validate(address);</programlisting>

          <para>validates the group <classname>Default</classname>
          (implicitly) and applies <classname>@Length</classname> on
          <methodname>street1</methodname>, <classname>@NotEmpty</classname>
          (and its composing constraints) on <methodname>city</methodname>,
          <classname>@NotEmpty</classname> (and its composing constraints) on
          <methodname>zipCode</methodname>. Particularly,
          <classname>@NotEmpty</classname> (and its composing constraints) on
          <methodname>street1</methodname> are not applied.</para>

          <programlisting>validator.validate(address, Minimal.class);</programlisting>

          <para>applies <classname>@NotEmpty</classname> (and its composing
          constraints) on <methodname>street1</methodname> and
          <classname>@NotEmpty</classname> (and its composing constraints) on
          <methodname>zipCode</methodname> because they belong to the
          <classname>Minimal</classname> group.</para>

          <programlisting>validator.validate(address, Minimal.class, Default.class);</programlisting>

          <para>validates both <classname>Default</classname> and
          <classname>Minimal</classname> groups. The routine applies
          <classname>@NotEmpty</classname> (and its composing constraints) and
          <classname>@Length</classname> on <methodname>street1</methodname>,
          <classname>@NotEmpty</classname> (and its composing constraints) on
          <methodname>city</methodname>, <classname>@NotEmpty</classname> (and
          its composing constraints) on <methodname>zipCode</methodname>. Note
          that if <methodname>zipCode</methodname> is empty, only one
          <classname>ConstraintViolation</classname> object will represent the
          failure and the not empty validation will only be executed
          once.</para>

          <para>Let's look at a more complex example involving group
          sequence.</para>

          <programlisting>public class Address {
    @NotEmpty(groups = Minimal.class)
    @Length(max=50, groups=FirstStep.class)
    private String street1;
    
    @NotEmpty(groups="SecondStep.class)
    private String city;

    @NotEmpty(groups = {Minimal.class, SecondStep.class})
    private String zipCode;
    ...

    public interface FirstStep {}

    public interface SecondStep {}
    
    @GroupSequence(sequence={Firststep.class, SecondStep.class})
    public interface Total {}
}</programlisting>

          <para>When running:</para>

          <programlisting>validator.validate(address, Minimal.class, Total.class);</programlisting>

          <para>the validation process will process
          <classname>@NotEmpty</classname> (and it's composing constraints)
          and <classname>@Length</classname> from
          <methodname>street1</methodname> and
          <classname>@NotEmpty</classname> (and it's composing constraints)
          from <methodname>zipCode</methodname>. If
          <classname>@Length</classname> from <methodname>street1</methodname>
          does not generate a failure, then <classname>@NotEmpty</classname>
          (and it's composing constraints) from <methodname>city</methodname>
          will be processed as part of <classname>SecondStep</classname>. Note
          that <classname>@NotEmpty</classname> (and it's composing
          constraints) from <methodname>zipCode</methodname> are not
          reprocessed as they have already been processed before.</para>

          <para>When running:</para>

          <programlisting>validator.validate(address, Total.class, SecondStep.class);</programlisting>

          <para><classname>@NotEmpty</classname> (and it's composing
          constraints) from <methodname>city</methodname> and
          <classname>@NotEmpty</classname> (and it's composing constraints)
          from <methodname>zipCode</methodname> will be processed even if
          <classname>@Length</classname> from <methodname>street1</methodname>
          fails: while <literal><classname>SecondStep</classname></literal> is
          in the <literal><classname>Total</classname></literal> group
          sequence and hence should not be triggered if
          <literal><classname>FirstStep</classname></literal> has a failure,
          it also has been requested outside the sequence (in this case
          explicitly).</para>
        </section>
      </section>
    </section>

    <section id="validationapi-constraintviolation">
      <title>ConstraintViolation</title>

      <para><classname>ConstraintViolation</classname> is the class describing
      a single constraint failure. A set of
      <classname>ConstraintViolation</classname> is returned for an object
      validation.</para>

      <programlisting>/**
 * Describe a constraint violation. This object describe the error context as
 * well as the message describing the violation.
 *
 * @author Emmanuel Bernard
 * @todo the rational behind rootBean and propertyPath is to keep the context 
 *       available to the user
 */
public interface ConstraintViolation&lt;T&gt; {

    /**
     * @return The interpolated error message for this constraint violation.
     */
    String getInterpolatedMessage();

    /**
     * @return The non-interpolated error message for this constraint violation.
     */
    String getRawMessage();

    /**
     * @return The root bean being validated.
     */
    T getRootBean();

    /**
     * If a bean constraint, the bean instance the constraint is applied on
     * If a property constraint, the bean instance hosting the property the
     * constraint is applied on
     * 
     * @return the leaf bean the constraint is applied on or null if Validator#validateValue
     * is used
     */
    Object getLeafBean();

    /**
     * @return the property path to the value from &lt;code&gt;rootBean&lt;/code&gt;
     *         &lt;code&gt;null&lt;/code&gt; if the value is the &lt;code&gt;rootBean&lt;code&gt; itself.
     */
    String getPropertyPath();

    /**
     * @return the value failing to pass the constraint.
     */
    Object getInvalidValue();

    /**
     * @return the list of groups that the triggered constraint applies on and which also are
     *         within the list of groups requested for validation.
     *
     * TODO: considering removal, if you think it's important, speak up
     */
    Set&lt;Class&lt;?&gt;&gt; getGroups();

    /**
     * Constraint metadata reported to fail.
     * The returned instance is immutable.
     * 
     * @return constraint metadata
     */
    ConstraintDescriptor getConstraintDescriptor();
}</programlisting>

      <para>The <methodname>getInterpolatedMessage</methodname> method returns
      the inerpolated (localized) message for the failing constraint (see
      <xref linkend="validationapi-message" /> for more information on message
      interpolator). This can be used by clients to expose user friendly
      messages.</para>

      <para>The <methodname>getRawMessage</methodname> method returns the
      non-interpolated error message (usually the <literal>message</literal>
      attribute on the constraint declaration). Frameworks can use this as an
      error code key.</para>

      <para>The <methodname>getRootBean</methodname> method returns the root
      object being validated that led to the failing constraint (i.e. the
      object the client code passes to the
      <methodname>Validator.validate</methodname> method.</para>

      <para>The <methodname>getInvalidValue</methodname> method returns the
      value (field, property or validated object) being passed to
      <methodname>isValid</methodname>.</para>

      <para><methodname>groups</methodname> returns the intersection of the
      groups the triggered constraint applies on and the groups requested for
      validation.<!--EBE: this notion is quite vague with the recursive group sequence--></para>

      <para><methodname>getConstraintDescriptor</methodname> provides access
      to the failing constraint metadata (see <xref
      linkend="constraintmetadata-constraintdescriptor" />).</para>

      <para>The <methodname>getPropertyPath</methodname> is built according to
      the following rules:</para>

      <itemizedlist>
        <listitem>
          <para>When an association is traversed:</para>

          <itemizedlist>
            <listitem>
              <para>if the association is not hosted by the root object (ie
              hosted on an associated object) a dot (<literal>.</literal>) is
              concatenated to the <literal>propertyPath</literal></para>
            </listitem>

            <listitem>
              <para>the name of the association property (field name or Java
              Bean property name) is concatenated to the
              <literal>propertyPath</literal>.</para>
            </listitem>

            <listitem>
              <para>if the association is a <classname>List</classname> or an
              array, the index value surrounded by square brackets
              (<literal>[index]</literal>) is concatenated to the
              <literal>propertyPath</literal> (for example
              <literal>order.orderLines[1]</literal>)</para>
            </listitem>

            <listitem>
              <para>if the association is a <classname>Map</classname>, for a
              given map entry, the result of <code>key.toString()</code>
              surrounded by square brackets and quotes
              (<literal>["key.toString()"]</literal>) is concatenated to the
              <literal>propertyPath</literal> (for example
              <literal>item.evaluation["quality"]</literal>)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>For property level constraint (field and getter):</para>

          <itemizedlist>
            <listitem>
              <para>if the property level constraint is not hosted by the root
              object (ie hosted on an associated object) a dot
              (<literal>.</literal>) is concatenated to the
              <literal>propertyPath</literal></para>
            </listitem>

            <listitem>
              <para>the name of the property (field name or Java Bean property
              name) is concatenated to the
              <literal>propertyPath</literal></para>
            </listitem>

            <listitem>
              <para>the <literal>propertyPath</literal> is considered
              complete</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>For class level constraint:</para>

          <itemizedlist>
            <listitem>
              <para>nothing is concatenated to the
              <literal>propertyPath</literal>, it is considered complete. If
              the <literal>propertyPath</literal> is empty, "" is returned
              (typically a class-level constraint on the root object)</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <note>
        <para>the collection notation is following the Unified Expression
        Language conventions.</para>
      </note>

      <note>
        <para>From <methodname>rootBean</methodname> and
        <methodname>propertyPath</methodname>, it is possible to rebuild the
        context of the failure</para>
      </note>

      <para>Assuming the following object definitions and when book is
      validated:</para>

      <programlisting>@SecurityChecking
public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Length(max=30)
    private String company;
    ...
}

@PresentInAmazon
public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private List&lt;Author&gt; authors;

    @Valid
    private Map&lt;String, Review&gt; reviewsPerSource;
    ...
}

public class Review {
    @Min(0) private int rating;
    ...
}</programlisting>

      <para><literal>propertyPath</literal> evaluations are described in <xref
      linkend="table-propertypath" />:</para>

      <table id="table-propertypath">
        <title>propertyPath examples</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Constraint</entry>

              <entry>propertyPath</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><classname>@PresentInAmazon</classname> on
              <classname>Book</classname></entry>

              <entry>"" (empty string)</entry>
            </row>

            <row>
              <entry><classname>@NotEmpty</classname> on
              <classname>Book.title</classname></entry>

              <entry>title</entry>
            </row>

            <row>
              <entry><classname>@NotNull</classname> on
              <classname>Book.authors</classname></entry>

              <entry>authors</entry>
            </row>

            <row>
              <entry><classname>@SecurityChecking</classname> on the fourth
              author, <classname>Author</classname></entry>

              <entry>authors[3]</entry>
            </row>

            <row>
              <entry><classname>@Length</classname> on the fourth author,
              <classname>Author.lastname</classname></entry>

              <entry>authors[3].lastname</entry>
            </row>

            <row>
              <entry><classname>@NotEmpty</classname> on the first author,
              <classname>Author.company</classname></entry>

              <entry>authors[0].company</entry>
            </row>

            <row>
              <entry><classname>@Min</classname> on the review associated to
              Consumer Report, <classname>Review.rating</classname></entry>

              <entry>reviewsPerSource["Consumer Report"].rating</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section>
        <title>Examples</title>

        <para>These examples assume the following definition of
        <classname>@NotEmpty</classname>.</para>

        <programlisting>@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmptyConstraintValidator.class)
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
public @interface NotEmpty {
    ...
}</programlisting>

        <para>and the following class definitions</para>

        <programlisting>public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Length(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

Author author = new Author();
author.setCompany("ACME");
Book book = new Book();
book.setTitle("");
book.setAuthor(author);

Set&lt;ConstraintViolation&gt; constraintViolations = validator.validate(book);</programlisting>

        <para><classname>ConstraintViolations</classname> is a set of size 2.
        One of the entries represents the failure of
        <literal>@NotEmpty</literal> (or more precisely
        <classname>@Size(min=1)</classname> a composing constraint of
        <classname>@NotEmpty</classname>) on the <literal>title</literal>
        property.</para>

        <para>The <classname>ConstraintViolation</classname> object for this
        failure passes the following assertions:</para>

        <programlisting>//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getInterpolatedMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();
//the offending value
assert book.getTitle().equals( constraintViolation.getInvalidValue() );
//the offending property
assert "title".equals( constraintViolation.getPropertyPath() );
assert constraintViolation.getGroups().length == 1 

List expectedGroups = new ArrayList(1);
expectedGroups.add(Default.class);
for ( Class&lt;?&gt; group : constraintViolation.getGroups() ) {
    assert expectedGroups.contains(group);
}</programlisting>

        <para>The second failure, <literal>@NotEmpty</literal> (or more
        precisely <classname>@NotNull</classname> a composing constraint of
        <classname>NotEmpty</classname>) on the author's
        <methodname>lastname</methodname>, will produce the
        <classname>ConstraintViolation</classname> object satisfying the
        following assertions:</para>

        <programlisting>assert "lastname must not be null".equals( constraintViolation.getInterpolatedMessage() );
assert book == constraintViolation.getRootBean();
assert author == constraintViolation.getLeafBean();
//the offending value
assert book.getAuthor().getLastName() == constraintViolation.getInvalidValue();
//the offending property
assert "author.lastName".equals( constraintViolation.getPropertyPath() );
assert constraintViolation.getGroups().length == 0</programlisting>
      </section>
    </section>

    <section id="validationapi-message">
      <title>Message interpolation</title>

      <para>A message interpolator is responsible for talking the message
      string from the constraint and return a human readable error
      message.</para>

      <section id="default-messageresolver">
        <title>Default message interpolation</title>

        <para>A conforming implementation includes a default message
        interpolator. This message interpolator shall use the algorithm
        defined here to interpolate message descriptors into human-readable
        messages.</para>

        <para>Each constraint defines a message descriptor via its
        <methodname>message</methodname> property. Every constraint definition
        shall define a default message descriptor for that constraint.
        Messages can be overridden at declaration time in constraints by
        setting the <methodname>message</methodname> property on the
        constraint.</para>

        <para>The message descriptor is a string literal and may contain one
        or more message parameters. Message parameters are string literals
        enclosed in braces.<!--SCP need to define the string literal here--></para>

        <example>
          <title>Message using parameters</title>

          <programlisting>Value must be between {min} and {max}</programlisting>
        </example>

        <section id="default-resolution-algorithm">
          <title>Default message interpolation algorithm</title>

          <para>The default message interpolator uses the following steps:<!--SCP: Do we want to allow MessageFormat style formatting here?--></para>

          <orderedlist>
            <listitem>
              <para>Message parameters are extracted from the message string
              and used as keys to search the
              <classname>ResourceBundle</classname> named
              <literal>ValidationMessages</literal> (often materialized as the
              property file
              <filename>/ValidationMessages.properties</filename> and its
              locale variations) using the defined locale (see below). If a
              property is found, the message parameter is replaced with the
              property value in the message string. Step 1 is applied
              recursively until no replacement is performed (ie. a message
              parameter value can itself contain a message parameter).</para>
            </listitem>

            <listitem>
              <para>Message parameters are extracted from the message string
              and used as keys to search the Bean Validation provider's
              built-in <classname>ResourceBundle</classname> using the defined
              locale (see below). If a property is found, the message
              parameter is replaced with the property value in the message
              string. Contrary to step 1, step 2 is not processed
              recursively.</para>
            </listitem>

            <listitem>
              <para>If step 2 triggers a replacement, then step 1 is applied
              again. Otherwise step 4 is performed.</para>
            </listitem>

            <listitem>
              <para>Message parameters are extracted from the message string.
              Those matching the name of an attribute of the constraint
              declaration are replaced by the value of that attribute.<!--SCP: The {value} message parameter is replaced by the value being validated, using the result of invoking the toString method onvalue. 
If the value being valudated is null, the string 'null' is used as a replacement string
EBE: hummm, relying on toString sucks. Not sure I like the {value} idea. and it conflicts with value the default annotation name--></para>
            </listitem>
          </orderedlist>

          <para>The defined locale is as followed:</para>

          <itemizedlist>
            <listitem>
              <para>if the locale is passed to the interpolator method
              i<methodname>nterpolate(String, CosntraintDescriptor, Object,
              Locale)</methodname>, this <classname>Locale</classname>
              instance is used.</para>
            </listitem>

            <listitem>
              <para>otherwise, the default <classname>Locale</classname> as
              provided by <methodname>Locale.getDefault()</methodname> is
              used.</para>
            </listitem>
          </itemizedlist>

          <para>The proposed algorithm ensures that custom resource bundle
          always have priority over built-in resource bundle at all level of
          the recursive resolution. It also ensures that constraint
          declarations attributes values are not interpolated further.</para>
        </section>
      </section>

      <section id="custom-message-resolution">
        <title>Custom message interpolation</title>

        <para>A custom message interpolator may be provided (e.g., to
        interpolate contextual data, or to adjust the default
        <classname>Locale </classname>used). A message interpolator implements
        the <classname>MessageInterpolator</classname> interface.</para>

        <programlisting>/**
 * Interpolate a given constraint violation message.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface MessageInterpolator {
    /**
     * Interpolate the message from the constraint parameters and the actual validated object.
     * The locale is defaulted according to the &lt;code&gt;MessageInterpolator&lt;/code&gt; implementation
     * See the implementation documentation for more detail.
     *
     * @param message The message to interpolate.
     * @param constraintDescriptor The constraint descriptor.
     * @param value The object being validated
     *
     * @return Interpolated error message.
     */
    String interpolate(String message,
                       ConstraintDescriptor constraintDescriptor,
                       Object value);

    /**
     * Interpolate the message from the constraint parameters and the actual validated object.
     * The Locale used is provided as a parameter
     *
     * @param message The message to interpolate.
     * @param constraintDescriptor The constraint descriptor.
     * @param value The object being validated
     * @param locale the locale targeted for the message
     *
     * @return Interpolated error message.
     */
    String interpolate(String message,
                       ConstraintDescriptor constraintDescriptor,
                       Object value,
                       Locale locale);
}</programlisting>

        <para><parameter>message</parameter> is the message descriptor as seen
        in <literal>@ConstraintAnnotation.message</literal> or provided to the
        <classname>ConstraintContext</classname> methods.</para>

        <para><parameter>constraintDescriptor</parameter> is the
        <classname>ConstraintDescriptor</classname> object representing the
        metadata of the failing constraint (see <xref
        linkend="constraintmetadata" />).</para>

        <para><parameter>value</parameter> is the value being
        validated.</para>

        <para><methodname>MessageInterpolator.interpolate(String,
        ConstraintDescriptor, Object)</methodname> is invoked for each
        constraint violation report generated. The default
        <classname>Locale</classname> is implementation specific.</para>

        <para><methodname>MessageInterpolator.interpolate(String,
        ConstraintDescriptor, Object, Locale)</methodname> can be invoked by a
        wrapping <classname>MessageInterpolator</classname> to enforce a
        specific <classname>Locale</classname> value by bypassing or
        overriding the default <classname>Locale</classname> strategy.</para>

        <para>A message interpolator implementation shall be
        thread-safe.</para>

        <para>The message interpolator is provided to the
        <classname>ValidatorFactory</classname> at construction time using
        <methodname>Configuration.messageInterpolator(MessageInterpolator)</methodname>.
        This message interpolator is shared by all validators generated by
        this <classname>ValidatorFactory</classname>.</para>

        <para>It is possible to override the
        <classname>MessageInterpolator</classname> implementation for a given
        <classname>Validator</classname> instance by invoking
        <methodname>ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator()</methodname>.</para>

        <para>It is recommended that
        <classname>MessageInterpolator</classname> implementations delegate
        final interpolation to the Bean Validation default
        <classname>MessageInterpolator</classname> to ensure standard Bean
        Validation interpolation rules are followed, The default
        implementation is accessible through
        <methodname>Configuration.getDefaultMessageInterpolator()</methodname>.</para>
      </section>

      <section id="validationapi-message-examples">
        <title>Examples</title>

        <para>These examples describe message interpolation based on the
        default message interpolator's built-in messages (see <xref
        linkend="standard-resolver-messages" />), and the
        <filename>ValidationMessages.properties</filename> file shown in table
        <xref linkend="table-messageinterpolation" />. The current locale is
        assumed English.</para>

        <programlisting>//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid</programlisting>

        <para></para>

        <table id="table-messageinterpolation">
          <title>message interpolation</title>

          <tgroup cols="2">
            <colspec align="center" />

            <tbody>
              <row>
                <entry>Failing constraint declaration</entry>

                <entry>interpolated message</entry>
              </row>

              <row>
                <entry>@NotNull</entry>

                <entry>must not be null</entry>
              </row>

              <row>
                <entry>@Max(30)</entry>

                <entry>must be less than or equal to 30</entry>
              </row>

              <row>
                <entry>@Size(min=5, max=15, message="Key must have between
                {min} and {max} characters")</entry>

                <entry>Key must have between 5 and 15 characters</entry>
              </row>

              <row>
                <entry>@Digits(integer=9, fraction=2)</entry>

                <entry>numeric value out of bounds (&lt;9 digits&gt;.&lt;2
                digits&gt; expected)</entry>
              </row>

              <row>
                <entry>@CreditCard(message={myapp.creditcard.error})</entry>

                <entry>credit card number not valid</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <!--SCP: add example of {value} here. Add use of MessageFormat style formatting-->

        <para>Here is an approach to specify the <classname>Locale</classname>
        value to choose on a given <classname>Validator</classname>.
        <classname>Locale</classname> aware
        <classname>MessageInterpolator</classname>. See <xref
        linkend="bootstrapping" /> for more details on the APIs.</para>

        <example id="validationapi-message-examples-specificlocale">
          <title>Use MessageInterpolator to use a specific Locale
          value</title>

          <programlisting>/**
 * delegates to a MessageInterpolator implementation but enforce a given Locale
 */
public class LocaleSpecificMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator defaultInterpolator;
    private final Locale defaultLocale;

    public LocaleSpecificMessageInterpolator(MessageInterpolator interpolator, Locale locale) {
        this.defaultLocale = locale;
        this.defaultInterpolator = interpolator;
    }

    /**
     * enforece the locale passed to the interpolator
     */
    public String interpolate(String message, 
                              ConstraintDescriptor constraintDescriptor, 
                              Object value) {
        return defaultInterpolator.interpolate(message, constraintDescriptor, 
                                           value, this.defaultLocale);
    }

    // no real use, implemented for completeness
    public String interpolate(String message,
                              ConstraintDescriptor constraintDescriptor,
                              Object value,
                              Locale locale) {
        return defaultInterpolator.interpolate(message, constraintDescriptor, value, locale);
    }
}


Locale locale = getMyCurrentLocale();
MessageInterpolator interpolator = new LocaleSpecificMessageInterpolator(
                                       validatorFactory.getMessageInterpolator(),
                                       locale);

Validator validator = validatorFactory.usingContext()
                                      .messageInterpolator(interpolator)
                                      .getValidator();</programlisting>
        </example>

        <para>Most of the time, however, the relevant
        <classname>Locale</classname> will be provided by your application
        framework transparently. This framework will implement its own version
        of <classname>MessageInterpolator</classname> and pass it during the
        <classname>ValidatorFactory</classname> configuration. The application
        will not have to set the <classname>Locale</classname> itself. This
        example shows how a container framework would implement
        <classname>MessageInterpolator</classname> to provide a user specific
        default locale.<!--TODO Rework this example as it is not reality--></para>

        <example id="validationapi-message-examples-jsflocale">
          <title>Contextual container possible MessageInterpolator
          implementation</title>

          <programlisting>public class ContextualMessageInterpolator {
    private final MessageInterpolator delegate;

    public ContextualMessageInterpolator(MessageInterpolator delegate) { 
        this.delegate = delegate; 
    }

    public String interpolate(String message, ConstraintDescriptor constraintDescriptor, 
                              Object value) {
        Locale locale = Container.getManager().getUserLocale();
        return this.delegate.interpolate(
                        message, constraintDescriptor, value, locale );
    }

    public String interpolate(String message, ConstraintDescriptor constraintDescriptor, 
                              Object value, Locale locale) {
        return this.delegate.interpolate(message, constraintDescriptor, value, locale);
    }
}


//Build the ValidatorFactory
Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    .messageInterpolator( new ContextualMessageInterpolator( configuration.getDefaultMessageInterpolator() ) )
    .buildValidatorFactory();

//The container uses the factory to validate constraints using the specific MessageInterpolator
Validator validator = factory.getValidator();</programlisting>
        </example>
      </section>
    </section>

    <section id="bootstrapping">
      <title>Bootstrapping</title>

      <para>The bootstrapping API aims at providing a
      <classname>ValidatorFactory</classname> object which is used to create
      <classname>Validator</classname> instances. The bootstrap process is
      decoupled from the provider implementation initialization: a bootstrap
      implementation must be able to bootstrap any Bean Validation provider
      implementation. The bootstrap sequence has been designed to achieve
      several goals:</para>

      <itemizedlist>
        <listitem>
          <para>plug multiple implementations</para>
        </listitem>

        <listitem>
          <para>choose a specific implementation</para>
        </listitem>

        <listitem>
          <para>extensibility: an application using a specific provider
          implementation can use specific configurations</para>
        </listitem>

        <listitem>
          <para>share and reuse of metadata across validators</para>
        </listitem>

        <listitem>
          <para>leave as much freedom as possible to implementations</para>
        </listitem>

        <listitem>
          <para>provide integration mechanisms to Java EE 6 and other
          containers</para>
        </listitem>

        <listitem>
          <para>type safety</para>
        </listitem>
      </itemizedlist>

      <para>The main artifacts involved in the bootstrap process are:</para>

      <itemizedlist>
        <listitem>
          <para><classname>Validation</classname>: API entry point. Lets you
          optionally define the Bean Validation provider targeted as well as a
          provider resolution strategy. Validation generates
          <classname>Configuration</classname> objects and can bootstrap any
          provider implementation.</para>
        </listitem>

        <listitem>
          <para><classname>ValidationProvider</classname>: contract between
          the bootstrap procedure and a Bean Validation provider
          implementation.</para>
        </listitem>

        <listitem>
          <para><classname>ValidationProviderResolver</classname>: returns a
          list of all Bean Validation providers available in the execution
          context (generally the classpath).</para>
        </listitem>

        <listitem>
          <para><classname>Configuration</classname>: collects the
          configuration details that will be used to build
          <classname>ValidatorFactory</classname>. A specific sub interface of
          <classname>Configuration</classname> must be provided by Bean
          Validation providers as a unique identifier. This sub interface
          typically hosts provider specific configurations.</para>
        </listitem>

        <listitem>
          <para><classname>ValidatorFactory</classname>: result of the
          bootstrap process. Build <classname>Validator</classname> instances
          from a given Bean Validation provider.</para>
        </listitem>

        <listitem>
          <para><filename>META-INF/validation.xml</filename>: a configuration
          file, Bean Validation users can use to customize the configuration
          of the default <classname>ValidatorFactory</classname>.</para>
        </listitem>
      </itemizedlist>

      <para>Let's first see the API in action through some examples before
      diving into the concrete definitions.</para>

      <section>
        <title>Examples</title>

        <para>The most simple approach is to initialize the default Bean
        Validation provider or the one defined in the XML configuration file.
        The <classname>ValidatorFactory</classname> is then ready to provide
        <classname>Validator</classname> instances.</para>

        <example>
          <title>Simple Bean Validation bootstrap sequence</title>

          <programlisting>ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();</programlisting>
        </example>

        <para>The <classname>ValidatorFactory</classname> object is
        thread-safe. Building <classname>Validator</classname> instances is
        typically a cheap operation. Building a
        <classname>ValidatorFactory</classname> is typically more expensive.
        Make sure to check your Bean Validation implementation documentation
        for more accurate details.</para>

        <para>The second example shows how a container can customize some Bean
        Validator resource handling to match its own behavior.</para>

        <example>
          <title>Customize message resolution, traversable resolver and
          constraint Validator factory implementation</title>

          <programlisting>//some customization from a container
ValidatorFactory factory = Validation
       .byDefaultProvider().configure()
          .messageInterpolator( new ContainerMessageInterpolator() )
          .constraintValidatorFactory( new ontainerComponentConstraintValidatorFactory() )
          .traversableResolver( new JPAAwareTraversableResolver() )
          .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();</programlisting>
        </example>

        <para>The third example shows how to bootstrap Bean Validation in an
        environment not following the traditional Java classloader strategies
        (such as tools or alternative service containers like OSGi). They can
        provider some alternative provider resolution strategy to discover
        Bean Validation providers.</para>

        <example>
          <title>Customize the Bean Validation provider resolution
          mechanism</title>

          <programlisting>//osgi environment
ValidatorFactory factory = Validation
       .byDefaultProvider()
          .providerResolver( new OSGiServiceDiscoverer() )
          .configure()
             .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();</programlisting>
        </example>

        <para>The next example shows how a client can choose a specific Bean
        Validation provider and configure provider specific properties
        programmatically in a type-safe way.</para>

        <example>
          <title>Use a specific provider and add specific
          configuration</title>

          <programlisting>ValidatorFactory factory = Validation
       .byProvider( ACMEConfiguration.class )  //chose a specific provider
       .configure()
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConsttaint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

//same initialization decomposing calls
ACMEConfiguration acmeConfiguration = Validation
       .byProvider( ACMEConfiguration.class )
       .configure();

ValidatorFactory factory = acmeConfiguration
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();


/**
 * ACME specific validator configuration and configuration options
 */
public interface ACMEConfiguration 
                    extends Configuration&lt;ACMEConfiguration&gt; {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     *r
    ACMEConfiguration addConstraint(Class&lt;?&gt; entity, 
                                    ACMEConstraintDescriptor constraintDescriptor);
}</programlisting>
        </example>

        <para>The last example shows how a <classname>Validator</classname>
        can use a specific <classname>MessageInterpolator</classname>
        implementation</para>

        <example>
          <title>Use a specific MessageInterpolator instance for a given
          Validator</title>

          <programlisting>ValidatorFactory factory = ...;
MessageInterpolator customInterpolator = new LocaleSpecificMessageInterpolator(
    locale, 
    factory.getMessageInterpolator()
);

Validator localizedValidator = 
    factory.usingContext()
                   .messageInterpolator(customInterpolator)
                   .getValidator();</programlisting>
        </example>

        <para>In the same flow, a custom
        <classname>TraversableResolver</classname> can be passed.</para>

        <para>We will now explore the various interfaces, their constraints
        and usage. We will go from the <classname>ValidatorFactory</classname>
        to the <classname>Validation</classname> class walking up the
        bootstrap chain.</para>
      </section>

      <section>
        <title>ValidatorFactory</title>

        <para><classname>ValidatorFactory</classname> objects build and
        provide initialized instances of <classname>Validator</classname> to
        Bean Validation clients. Each <classname>Validator</classname>
        instance is configured for a given context (message interpolator,
        traversable resolver). Clients should cache
        <classname>ValidatorFactory</classname> objects and reuse them for
        optimal performances. The API is designed to allow implementors to
        share constraint metadata in
        <classname>ValidatorFactory</classname>.</para>

        <para><classname>ValidatorFactory</classname> implementations must be
        thread-safe. <classname>ValidatorFactory</classname> implementations
        can cache <classname>Validator</classname> instances if needed.</para>

        <example>
          <title>ValidatorFactory interface</title>

          <programlisting>/**
 * Factory returning initialized Validator instances.
 * Implementations are thread-safe
 * This object is typically cached and reused.
 *
 * @author Emmanuel Bernard
 */
public interface ValidatorFactory {
    /**
     * return an initialized Validator instance using the default factory instances
     * for message interpolator and traversable resolver.
     *
     * Validator instances can be pooled and shared by the implementation
     */
    Validator getValidator();

    /**
     * Define the validator context and return a
     * Validator compliant with this state
     *
     * @return a ValidatorContext
     */
    ValidatorContext usingContext();

    /**
     * Returns the MessageInterpolator instance configured at initialization time
     * for the ValidatorFactory
     * This is the instance used by #getValidator(Class)
     *
     * @return MessageInterpolator instance
     */
    MessageInterpolator getMessageInterpolator();
}</programlisting>
        </example>

        <para>A <classname>ValidatorFactory</classname> is provided by a
        <classname>Configuration</classname>.</para>

        <para><classname>ValidatorContext</classname> returned by
        <methodname>usingContext</methodname> can be used to customize the
        state in which the <classname>Validator</classname> must be
        initialized. This is used to customize the
        <classname>MessageInterpolator</classname> or the
        <classname>TraversableResolver</classname>.</para>

        <example>
          <title>ValidatorContext interface</title>

          <programlisting>/**
 * Return a Validator corresponding to the initialized state.
 * 
 * @author Emmanuel Bernard
 */
public interface ValidatorContext {
	/**
	 * Defines the message interpolator implementation used by the Validator.
	 * If not set or if null is passed as a parameter,
	 * the message interpolator of the ValidatorFactory is used.
	 *
	 * @return self following the chaining method pattern
	 */
	ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator);

	/**
	 * Defines the traversable resolver implementation used by the Validator.
	 * If not set or if null is passed as a parameter,
	 * the traversable resolver of the ValidatorFactory is used.
	 *
	 * @return self following the chaining method pattern
	 */
	ValidatorContext traversableResolver(TraversableResolver traversableResolver);

	/**
	 * @return an initialized &lt;code&gt;Validator&lt;/code&gt; instance respecting the defined state.
	 * Validator instances can be pooled and shared by the implementation.
	 */
	Validator getValidator();
}</programlisting>
        </example>

        <para>The <classname>MessageInterpolator</classname> or the
        <classname>TraversableResolver</classname> passed to the
        <classname>ValidatorContext</classname> are used instead of the
        <classname>ValidatorFactory</classname>'s
        <classname>MessageInterpolator</classname> or
        <classname>TraversableResolver</classname> instances.</para>

        <para><methodname>getMessageInterpolator()</methodname> returns the
        <classname>MessageInterpolator</classname> instance configured during
        the initialization of the <classname>ValidatorFactory</classname>. It
        is particularly useful to build a <classname>Validator</classname>
        specific <classname>MessageInterpolator</classname> wrapping the one
        from the <classname>ValidatorFactory</classname>.</para>

        <example>
          <title>Use of ValidatorFactory</title>

          <programlisting>ValidatorFactory factory = ...
Validator validatorUsingDefaults = factory.getValidator();
Validator validatorUsingCustomTraversable = factory
                     .usingContext()
                     .traversableResolver( new JPATraversableResolver() )
                     .getValidator();</programlisting>
        </example>

        <para>See <xref
        linkend="validationapi-message-examples-specificlocale" /> for an
        example using
        <methodname>getMessageInterpolator()</methodname>.</para>
      </section>

      <section>
        <title>Configuration</title>

        <para><classname>Configuration</classname> collects configuration
        informations, determines the correct provider implementation and
        delegates it the <classname>ValidatorFactory</classname> creation.
        This class lets you define:</para>

        <itemizedlist>
          <listitem>
            <para>the message interpolator strategy instance</para>
          </listitem>

          <listitem>
            <para>the traversable resolver strategy instance</para>
          </listitem>

          <listitem>
            <para>the constraint validator factory instance</para>
          </listitem>

          <listitem>
            <para>XML constraint mappings</para>
          </listitem>

          <listitem>
            <para>provider specific properties</para>
          </listitem>

          <listitem>
            <para>whether or not
            <classname>META-INF/validation.xml</classname> is
            considered.</para>
          </listitem>
        </itemizedlist>

        <para>A <classname>Configuration</classname> does provide a
        <classname>MessageInterpolator</classname> implementation following
        the default Bean Validation <classname>MessageInterpolator</classname>
        rules as defined in <xref linkend="default-messageresolver" /> by
        calling <methodname>getDefaultMessageInterpolator()</methodname>. Such
        an implementation is useful to let a custom
        <classname>MessageInterpolator</classname> delegates to the standard
        <classname>MessageInterpolator</classname> (see <xref
        linkend="custom-message-resolution" /> and an example making use of
        <methodname>getDefaultMessageInterpolator()</methodname> in <xref
        linkend="validationapi-message-examples-jsflocale" />).</para>

        <para>Clients call
        <methodname>Configuration.buildValidatorFactory()</methodname> to
        retrieve the initialized <classname>ValidatorFactory</classname>
        instance.</para>

        <example>
          <title>Configuration interface</title>

          <programlisting>/**
 * Receives configuration information, selects the appropriate
 * Bean Validation provider and build the appropriate
 * ValidatorFactory.
 * &lt;p/&gt;
 * Usage:
 * &lt;pre&gt;
 * Configuration&lt;?&gt; configuration = //provided by one of the Validation bootstrap methods
 *     ValidatorFactory = configuration
 *         .messageInterpolator( new CustomMessageInterpolator() )
 *         .buildValidatorFactory();
 * &lt;/pre&gt;
 * &lt;p/&gt;
 * &lt;p/&gt;
 * By default, the configuration information is retrieved from
 * META-INF/validation.xml
 * It is possible to override the configuration retrieved from the XML file
 * by using one or more of the Configuration methods.
 * &lt;p/&gt;
 * The ValidationProviderResolver is specified at Configuration time
 * (see {@link javax.validation.spi.ValidationProvider}).
 * If none is explicitely requested, the default ValidationProviderResolver is used.
 * &lt;p/&gt;
 * The provider is selected in the following way:
 * - if a specific Configuration subclass is requested programmatically using
 * Validation.byProvider(Class), find the first provider matching it
 * - if a specific Configuration subclass is defined in META-INF/validation.xml,
 * find the first provider matching it
 * - otherwise, use the first provider returned by the ValidationProviderResolver
 * &lt;p/&gt;
 * Implementations are not meant to be thread-safe
 *
 * @author Emmanuel Bernard
 */
public interface Configuration&lt;T extends Configuration&lt;T&gt;&gt; {

	/**
	 * Ignore data from the META-INF/validation.xml file if this
	 * method is called.
	 * This method is typically useful for containers that parse
	 * META-INF/validation.xml themselves and pass the information
	 * via the Configuration methods.
	 *
	 * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
	 */
	T ignoreXmlConfiguration();

	/**
	 * Defines the message interpolator used. Has priority over the configuration
	 * based message interpolator.
	 * If null is passed, the default message interpolator 
	 * (defined in XML or the specification default)
	 * is used.
	 *
	 * @param interpolator message interpolator implementation.
	 *
	 * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
	 */
	T messageInterpolator(MessageInterpolator interpolator);

	/**
	 * Defines the traversable resolver used. Has priority over the configuration
	 * based traversable resolver.
	 * If null is passed, the default traversable resolver
	 * (defined in XML or the specification default)
	 * is used.
	 *
	 * @param resolver traversable resolver implementation.
	 *
	 * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
	 */
	T traversableResolver(TraversableResolver resolver);

	/**
	 * Defines the constraint validator factory. Has priority over the configuration
	 * based constraint factory.
	 * If null is passed, the default constraint validator factory
	 * (defined in XML or the specification default)
	 * is used.
	 *
	 * @param constraintValidatorFactory constraint factory inmplementation.
	 *
	 * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
	 */
	T constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory);

	/**
	 * Add a stream describing constraint mapping in the Bean Validation
	 * XML format.
	 * &lt;p/&gt;
	 * The stream should be closed by the client API after the
	 * &lt;code&gt;ValidatorFactory&lt;/code&gt; has been built. The Bean Validation provider
	 * must not close the stream.
	 *
	 * @param stream XML mapping stream.
	 *
	 * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
	 * @throws IllegalArgumentException if &lt;code&gt;stream&lt;/code&gt; is null
	 */
	T addMapping(InputStream stream);

	/**
	 * Add a provider specific property. This property is equivalent to
	 * XML Configuration properties.
	 * If the underlying provider does not know how to handle the property,
	 * it must silently ignore it.
	 * &lt;p/&gt;
	 * Note: Using this non type-safe method is generally not recommended.
	 * &lt;p/&gt;
	 * It is more appropriate to use, if available, the type-safe equivalent provided
	 * by a specific provider in its Configuration subclass.
	 * &lt;code&gt;ValidatorFactory factory = Validation.byProvider(ACMEConfiguration.class)
	 * .configure()
	 * .providerSpecificProperty(ACMEState.FAST)
	 * .buildValidatorFactory();
	 * &lt;/code&gt;
	 * This method is typically used by containers parsing META-INF/validation.xml
	 * themselves and injecting the state to the Configuration object.
	 * &lt;p/&gt;
	 * If a property with a given name is defined both via this method and in the
	 * XML configuration, the value set programmatically has priority.
	 *
	 * If null is passed as a value, the value defined in XML is used. If no value
	 * is defined in XML, the property is considered unset.
	 *
	 * @param name property name.
	 * @param value property value.
	 * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
	 *
	 * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is null
	 */
	T addProperty(String name, String value);

	/**
	 * Return an implementation of the MessageInterpolator interface following the
	 * default MessageInterpolator defined in the specification:
	 * - use the ValidationMessages resource bundle to load keys
	 * - use Locale.getDefault()
	 *
	 * @return default MessageInterpolator implementation compliant with the specification
	 */
	MessageInterpolator getDefaultMessageInterpolator();

	/**
	 * Build a ValidatorFactory implementation.
	 *
	 * @return ValidatorFactory
	 */
	ValidatorFactory buildValidatorFactory();
}</programlisting>
        </example>

        <para>A Bean Validation provider must define a sub interface of
        <classname>Configuration</classname> uniquely identifying the
        provider. The <methodname>isSuitable()</methodname> method of its
        <classname>ValidationProvider</classname> implementation must return
        true when this sub interface type is passed as a parameter, false
        otherwise. The <classname>Configuration</classname> sub interface
        typically hosts provider specific configuration methods.</para>

        <para>To facilitate the use of provider specific configuration
        methods, <classname>Configuration</classname> uses generics:
        <classname>Configuration&lt;T extends
        Configuration&lt;T&gt;&gt;</classname> ; the generic return type
        <classname>T</classname> is returned by chaining methods. The provider
        specific sub interface must resolve the generic T as itself as shown
        in the following example.</para>

        <example>
          <title>Example of provider specific Configuration sub
          interface</title>

          <programlisting>/**
 * Unique identifier of the ACME provider
 * also host some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEonfiguration&gt; {

    /**
     * Enables contraints implementation dynamic reloading when using ACME
     * default to false
     */
    Configuration enableDynamicReloading(boolean);

}</programlisting>
        </example>

        <para>When
        <methodname>Configuration.buildValidatorFactory()</methodname> is
        called, the initialized <classname>ValidatorFactory</classname> is
        returned. More specifically, the requested Bean Validation provider is
        determined and the result of
        <code>validationProvider.buildValidatorFactory(ConfigurationState)</code>
        is returned. <classname>ConfigurationState</classname> gives access to
        the configuration artifacts defined in
        <filename>META-INF/validation.xml</filename> (unless XML configuration
        is ignored) and provided programmatically to
        <classname>Configuration</classname>. Generally speaking,
        programmatically defined elements have priority over XML defined
        configuration elements (read the Configuration JavaDoc and see <xref
        linkend="xml-config" /> for more information).</para>

        <note>
          <para>A typical implementation of
          <classname>Configuration</classname> also implements
          <classname>ConfigurationState</classname>, hence <code>this</code>
          can be passed to
          <methodname>buildValidatorFactory(ConfigurationState)</methodname>.</para>
        </note>

        <para>Streams represented in the XML configuration and opened by the
        <classname>Configuration</classname> implementation must be closed by
        the <classname>Configuration</classname> implementation after the
        <classname>ValidatorFactory</classname> creation (or if an exception
        occurs). Streams provided programmatically are the responsibility of
        the application.<!--talk about extensibility--></para>

        <example>
          <title>ConfigurationState interface</title>

          <programlisting>/**
 * Contract between a &lt;code&gt;Configuration&lt;/code&gt; and a
 * &lt;/code&gt;ValidatorProvider&lt;/code&gt; to create a &lt;code&gt;ValidatorFactory&lt;/code&gt;.
 * The configuration artifacts defined in the XML configuration and provided to the
 * &lt;code&gt;Configuration&lt;/code&gt; are merged and passed along via ConfigurationState.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConfigurationState {

	/**
	 * returns true if Configuration.ignoreXMLConfiguration() has been called
	 * In this case, the ValiatorFactory must ignore META-INF/validation.xml
	 * @return true if META-INF/validation.xml should be ignored
	 */
	boolean isIgnoreXmlConfiguration();

	/**
	 * Message interpolator as defined in the following decreasing priority:
	 *  - set via the Configuration programmatic API
	 *  - defined in META-INF/validation.xml provided that ignoredXmlConfiguration
	 * is false. In this case the instance is created via its no-arg constructor.
	 *  - null if undefined.
	 *
	 * @return message provider instance or null if not defined
	 */
	MessageInterpolator getMessageInterpolator();

	/**
	 * Returns a set of stream corresponding to:
	 *  - mapping XML streams passed programmatically in Configuration
	 *  - mapping XML stream located in the resources defined in
	 * META-INF/validation.xml (constraint-mapping element)
	 *
	 * Streams represented in the XML configuration and opened by the 
	 * configuration implementation must be closed by the configuration
	 * implementation after the ValidatorFactory creation (or if an exception
	 * occurs).
	 *
	 * @return set of input stream
	 */
	Set&lt;InputStream&gt; getMappingStreams();

	/**
	 * ConstraintValidatorFactory implementation as defined in the following
	 * decreasing priority:
	 *  - set via the Configuration programmatic API
	 *  - defined in META-INF/validation.xml provided that ignoredXmlConfiguration
	 * is false. In this case the instance is created via its no-arg constructor.
	 *  - null if undefined.
	 *
	 * @return factory instance or null if not defined
	 */
	ConstraintValidatorFactory getConstraintValidatorFactory();

	/**
	 * TraversableResolver as defined in the following decreasing priority:
	 *  - set via the Configuration programmatic API
	 *  - defined in META-INF/validation.xml provided that ignoredXmlConfiguration
	 * is false. In this case the instance is created via its no-arg constructor.
	 *  - null if undefined.
	 *
	 * @return traversable provider instance or null if not defined
	 */
	TraversableResolver getTraversableResolver();

	/**
	 * return  non type-safe properties defined via:
	 *  - Configuration.addProperty(String, String)
	 *  - META-INF/validation.xml provided that ignoredXmlConfiguration
	 * is false.
	 *
	 * If a property is defined both programmatically and in XML,
	 * the value defined programmatically has priority 
	 *
	 * @return Map whose key is the property key and the value the property value
	 */
	Map&lt;String, String&gt; getProperties();
}</programlisting>
        </example>

        <para>The requested provider implementation is resolved according to
        the following rules in the following order:</para>

        <itemizedlist>
          <listitem>
            <para>Use the provider implementation requested if
            <classname>Configuration</classname> has been created from
            <classname>Validation.byProvider(Class)</classname>.</para>
          </listitem>

          <listitem>
            <para>Use the provider implementation associated with the
            <classname>Configuration</classname> implementation described in
            the XML configuration (under
            <literal>validation-config.default-provider</literal> see <xref
            linkend="xml-config" />) if defined: the value of this element is
            the fully qualified class name of the
            <classname>Configuration</classname> sub interface uniquely
            identifying the provider.</para>
          </listitem>

          <listitem>
            <para>Use the first provider implementation returned by
            <classname>validationProviderResolver.getValidationProviders()</classname>.</para>
          </listitem>
        </itemizedlist>

        <para>The <classname>ValidationProviderResolver</classname> is
        specified when <classname>Configuration</classname> instances are
        created (see <classname>ValidationProvider</classname>). If no
        <classname>ValidationProviderResolver</classname> instance has been
        specified, the default
        <classname>ValidationProviderResolver</classname> is used.</para>

        <para><classname>Configuration</classname> instances are provided to
        the Bean Validation client through the
        <classname>Validation</classname> methods.
        <classname>Configuration</classname> instances are created by
        <classname>ValidationProvider</classname>.</para>

        <para>Here is an example of <classname>Configuration</classname>
        use.</para>

        <example>
          <title>Use Configuration</title>

          <programlisting>Configuration configuration = ...
ValidatorFactory factory = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</programlisting>
        </example>
      </section>

      <section>
        <title>ValidationProvider and ValidationProviderResolver</title>

        <para><classname>ValidationProvider</classname> is the contract
        between the bootstrap process and a specific Bean Validation provider.
        <classname>ValidationProviderResolver</classname> implements the
        discovery mechanism for Bean Validation provider implementation. Any
        Bean Validation client can implement such a discovery mechanism but it
        is typically implemented by containers having specific classloader
        structures and restrictions.</para>

        <section>
          <title>ValidationProviderResolver</title>

          <para><classname>ValidationProviderResolver</classname> returns the
          list of Bean Validation providers available at runtime and more
          specifically a <classname>ValidationProvider</classname> instance
          for each provider available in the context. This service can be
          customized by implementing
          <classname>ValidationProviderResolver</classname>. Implementations
          must be thread-safe.</para>

          <example>
            <title>ValidationProviderResolver</title>

            <programlisting>/**
 * Determine the list of Bean Validation providers available in the runtime environment
 * &lt;p&gt;
 * Bean Validation providers are identified by the presence of 
 * META-INF/services/javax.validation.spi.ValidationProvider
 * files following the Service Provider pattern described
 * &lt;a href="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider"&gt;here&lt;/a&gt;
 * &lt;p/&gt;
 * Each META-INF/services/javax.validation.spi.ValidationProvider file contains the list of
 * ValidationProvider implementations each of them representing a provider.
 *
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface ValidationProviderResolver {
    /**
     * Returns a list of ValidationProviders available in the runtime environment.
     *
     * @return list of validation providers.
     */
    List&lt;ValidationProvider&gt; getValidationProviders();
}</programlisting>
          </example>

          <para>By default, providers are resolved using the Service Provider
          pattern described in <ulink
          url="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider">http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider</ulink>.
          Each Bean Validation provider should supply a service provider
          configuration file by creating a text file
          <filename>javax.validation.spi.ValidationProvider</filename> and
          placing it in the <filename>META-INF/services</filename> directory
          of one of its jar files. The content of the file should contain the
          name of the provider implementation class of the
          <classname>javax.validation.spi.ValidationProvider</classname>
          interface.</para>

          <para>Persistence provider jars may be installed or made available
          in the same ways as other service providers, e.g. as extensions or
          added to the application classpath according to the guidelines in
          the JAR file specification.</para>

          <para>The default <classname>ValidationProviderResolver</classname>
          implementation will locate all the Bean Validation providers by
          their provider configuration files visible in the classpath. The
          default <classname>ValidationProviderResolver</classname>
          implementation is recommended and custom
          <classname>ValidationProviderResolver</classname> implementations
          should be rarely used. A typical use of a custom resolution is
          resolving providers in a classloader constrained container like OSGi
          or in a tool environment (IDE).</para>

          <para>The default implementation of
          <classname>ValidationProviderResolver</classname> must be available
          at
          <classname>javax.validation.bootstrap.DefaultValidationProviderResolver</classname>.
          It must contain a public no-arg constructor and must not have any
          other non private attribute or method besides the method described
          by <classname>ValidationProviderResolver</classname>.</para>
        </section>

        <section id="id-bootstrap-validationprovider">
          <title>ValidationProvider</title>

          <para><classname>ValidationProvider</classname> represents the SPI
          (Service Provider Interface) defining the contract between the
          provider discovery and initialization mechanism, and the provider. A
          <classname>ValidationProvider</classname> does:</para>

          <itemizedlist>
            <listitem>
              <para>Determine if a provider matches a given
              <classname>Configuration</classname> sub interface. One
              <classname>Configuration</classname> sub interface specifically
              represent one Bean Validation provider.</para>
            </listitem>

            <listitem>
              <para>Provide a provider specific
              <classname>Configuration</classname> implementation. This
              <classname>Configuration</classname> will specifically build
              <classname>ValidatorFactory</classname> instances of the
              provider it comes from.</para>
            </listitem>

            <listitem>
              <para>Build a <classname>ValidatorFactory</classname> object
              from the configuration provided by
              <classname>ConfigurationState</classname>.</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>ValidationProvider</title>

            <programlisting>/**
 * Contract between the validation bootstrap mechanism and the provider engine.
 * &lt;p/&gt;
 * Implementations must have a public no-arg constructor. The construction of a provider
 * should be as "lightweight" as possible.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidationProvider {
    /**
     * This sub interface uniquely identify a provider.
     * 
     * @param configurationClass targeted configuration class.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;configurationClass&lt;/code&gt; is the Bean Validation Provider
     *         sub-interface for Configuration
     */
    boolean isSuitable(Class&lt;? extends Configuration&lt;?&gt;&gt; configurationClass);

    /**
     * Returns a Configuration instance implementing the
     * &lt;code&gt;configurationClass&lt;/code&gt; interface.
     * The Configuration instance uses the current provider (&lt;code&gt;this&lt;/code&gt;)
     * to build the ValidatorFactory instance.
     * &lt;p/&gt;
     * This method can only be called on providers returning true on
     * &lt;code&gt;#isSuitable(configurationClass)&lt;/code&gt;
     *
     * @param configurationClass the Configuration class type
     * @param state bootstrap state
     *
     * @return specific Configuration implementation
     */
    &lt;T extends Configuration&lt;T&gt;&gt; T createSpecializedConfiguration(
            BootstrapState state,
            Class&lt;T&gt; configurationClass);

    /**
     * Returns a Configuration instance. This instance is not bound to
     * use the current provider. The choice of provider follows the algorithm described
     * in {@link javax.validation.Configuration}
     * &lt;p/&gt;
     * The ValidationProviderResolver used is provided by &lt;code&gt;state&lt;/code&gt;.
     * If null, the default ValidationProviderResolver is used.
     *
     * @param state bootstrap state
     *
     * @return Configuration implementation
     */
    Configuration&lt;?&gt; createGenericConfiguration(BootstrapState state);

    /**
     * Build a ValidatorFactory using the current provider implementation. The
     * ValidatorFactory is assembled and follow the configuration passed
     * using ConfigurationState.
     * &lt;p&gt;
     * The returned ValidatorFactory is properly initialized and ready for use.
     * &lt;/p&gt;
     *
     * @param configurationState the configuration descriptor
     *
     * @return the instanciated ValidatorFactory
     */
    ValidatorFactory buildValidatorFactory(ConfigurationState configurationState);
}</programlisting>
          </example>

          <example>
            <title>BootstrapState interface</title>

            <programlisting>/**
 * Defines the state used to bootstrap the Configuration
 *
 * @author Emmanuel Bernard
 */
public interface BootstrapState {
    /**
     * returns the user defined ValidationProviderResolver strategy instance or &lt;code&gt;null&lt;/code&gt;
     * if undefined.
     *
     * @return ValidationProviderResolver instance or null
     */
    ValidationProviderResolver getValidationProviderResolver();
}</programlisting>
          </example>

          <para>A client can request a specific Bean Validation provider by
          using <classname>Validation.byProvider(Class&lt;T exptends
          Configuration&lt;T&gt;&gt;)</classname> or by defining the provider
          in the XML configuration file. The key uniquely identifying a Bean
          Validation provider is a provider specific sub interface of
          <classname>Configuration</classname>. The sub interface does not
          have to add any new method but is the natural holder of provider
          specific methods.</para>

          <example>
            <title>Example of provider specific Configuration sub
            interface</title>

            <programlisting>/**
 * Unique identifier of the ACME provider
 * also host some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables contraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}</programlisting>
          </example>

          <note>
            <para><classname>Configuration</classname> references itself in
            the generic definition. Methods of
            <classname>Configuration</classname> will return the
            <classname>ACMEConfiguration</classname> making the API easy to
            use even for vendor specific extensions.</para>
          </note>

          <para>The provider discovery mechanism uses the following
          algorithm:</para>

          <itemizedlist>
            <listitem>
              <para>Retrieve available providers using
              <methodname>ValidationProviderResolver.getValidationProviders()</methodname>.</para>
            </listitem>

            <listitem>
              <para>The first <classname>ValidationProvider</classname>
              matching the requested provider is returned. Providers are
              evaluated in the order they are provided by
              <classname>ValidationProviderResolver</classname>. A provider is
              considered matching if
              <methodname>ValidationProvider.isSuitable(Class&lt;T extends
              Configuration&lt;T&gt;&gt;)</methodname> returns true when the
              requested provider specific <classname>Configuration</classname>
              sub interface is passed as a parameter.</para>
            </listitem>
          </itemizedlist>

          <para>When the default Bean Validation provider is requested, the
          first <classname>ValidationProvider</classname> returned by the
          <classname>ValidationProviderResolver</classname> strategy is
          returned.</para>

          <para>Every Bean Validation provider must provide a
          <classname>ValidationProvider</classname> implementation containing
          a public no-arg constructor and add the corresponding
          <filename>META-INF/services/javax.validation.spi.ValidationProvider</filename>
          file descriptor in one of its jars.</para>
        </section>
      </section>

      <section>
        <title>Validation</title>

        <para>The <classname>Validation</classname> class is the entry point
        used to bootstrap Bean Validation providers. The first entry point,
        <methodname>buildDefaultValidatorFactory()</methodname>, returns a
        <classname>ValidatorFactory</classname>. The first provider returned
        by the default <classname>ValidationProviderResolver</classname> is
        used to build the <classname>ValidatorFactory</classname>.
        <code>Validation.buildDefaultValidatorFactory()</code> is equivalent
        to
        <code>Validation.byDefaultProvider().configure().buildValidatorFactory()</code>.</para>

        <warning>
          <para>Should the resolver strategy be configurable by XML</para>
        </warning>

        <example>
          <title>Validation methods available</title>

          <programlisting>/**
 * This class is the entry point for the Bean Validation framework. There are three ways
 * to bootstrap the framework:
 * &lt;ul&gt;
 * &lt;li&gt;
 * The easiest approach is to use the default Bean Validation provider.
 * &lt;pre&gt;
 * ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
 * &lt;/pre&gt;
 * In this case {@link  javax.validation.bootstrap.DefaultValidationProviderResolver}
 * will be used to locate available providers.
 *
 * The chosen provider is defined as followed:
 * &lt;ul&gt;
 * &lt;li&gt;if the XML configuration defines a provider, this provider is used&lt;/li&gt;
 * &lt;li&gt;if the XML configuration does not define a provider or if no XML configuration
 * is present the first provider returned by the ValidationProviderResolver
 * isntance is used.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The second bootstrap approach allows to choose a custom
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt;. The chosen
 * &lt;code&gt;ValidationProvider&lt;/code&gt; is then determined in the same way
 * as in the default bootstrapping case (see above).
 * &lt;pre&gt;
 * Configuration&amp;lt?&amp;gt; configuration = Validation
 *    .byDefaultProvider()
 *    .providerResolver( new MyResolverStrategy() )
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * 
 * &lt;p/&gt;
 * &lt;li&gt;
 * The third approach allows you to specify explicitly and in
 * a type safe fashion the expected provider by
 * using its specific &lt;code&gt;Configuration&lt;/code&gt; sub-interface.
 *
 * Optionally you can choose a custom &lt;code&gt;ValidationProviderResolver&lt;/code&gt;.
 * &lt;pre&gt;
 * ACMEConfiguration configuration = Validation
 *    .byProvider(ACMEConfiguration.class)
 *    .providerResolver( new MyResolverStrategy() )  // optionally set the provider resolver
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * Note:&lt;br/&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * The ValidatorFactory object built by the bootstrap process should be cached
 * and shared amongst Validator consumers.
 * &lt;/li&gt;
 * &lt;li&gt;
 * This class is thread-safe.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Feretnschik
 * @see DefaultValidationProviderResolver
 */
public class Validation {

    /**
     * Build and return a ValidatorFactory instanced based on the
     * default Bean Validation provider and following the
     * XML configuration.
     * &lt;p/&gt;
     * The provider list is resolved using the
     * {@link  javax.validation.bootstrap.DefaultValidationProviderResolver}.
     * &lt;p/&gt; The code is semantically equivalent to
     * &lt;code&gt;Validation.byDefaultProvider().configure().buildValidatorFactory()&lt;/code&gt;
     *
     * @return &lt;code&gt;ValidatorFactory&lt;/code&gt; instance.
     */
    public static ValidatorFactory buildDefaultValidatorFactory() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt;. The provider list is resolved
     * using the strategy provided to the bootstrap state.
     * &lt;pre&gt;
     * Configuration&amp;lt?&amp;gt; configuration = Validation
     *    .byDefaultProvider()
     *    .providerResolver( new MyResolverStrategy() )
     *    .configure();
     * ValidatorFactory factory = configuration.buildValidatorFactory();
     * &lt;/pre&gt;
     * The actual provider choice is given by the XML configuration. If the XML
     * configuration does not exsist the first available provider will be returned.
     *
     * @return instance building a generic &lt;code&gt;Configuration&lt;/code&gt;
     * compliant with the bootstrap state provided.
     */
    public static GenericBootstrap byDefaultProvider() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt; for a particular provider implementation.
     * Optionally override the provider resolution strategy used to determine the provider.
     * &lt;p/&gt;
     * Used by applications targeting a specific provider programmatically.
     * &lt;p/&gt;
     * &lt;pre&gt;
     * ACMEConfiguration configuration =
     *     Validation.byProvider(ACMEConfiguration.class)
     *             .providerResolver( new MyResolverStrategy() )
     *             .configure();
     * &lt;/pre&gt;,
     * where &lt;code&gt;ACMEConfiguration&lt;/code&gt; is the
     * &lt;code&gt;Configuration&lt;/code&gt; sub interface uniquely identifying the
     * ACME Bean Validation provider.
     *
     * @param configurationType the &lt;code&gt;Configuration&lt;/code&gt; sub interface
     * uniquely defining the targeted provider.
     *
     * @return instance building a provider specific &lt;code&gt;Configuration&lt;/code&gt;
     * sub interface implementation.
     *
     */
    public static &lt;T extends Configuration&lt;T&gt;&gt;
    ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;T&gt; configurationType) {
        [...]
    }

    [...]
}</programlisting>
        </example>

        <para>The second entry point lets the client provide a custom
        <classname>ValidationProviderResolution</classname> instance. This
        instance is passed to <classname>GenericBootstrap</classname>.
        <classname>GenericBootstrap</classname> builds a generic
        <classname>Configuration</classname> using the first
        <classname>ValidationProvider</classname> returned by
        <classname>ValidationProviderResolution</classname> and calling
        <code>ValidationProvider.createGenericConfiguration(BootstrapState
        state)</code>. <classname>BootstrapState</classname> holds the
        <classname>ValidationProviderResolution</classname> instance passed to
        <classname>GenericBootstrap</classname> and will be used by the
        <classname>Configuration</classname> instance when resolving the
        provider to use.</para>

        <example>
          <title>GenericBootstrap interface</title>

          <programlisting>/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider agnostic Configuration.
 *
 * @author Emmanuel Bernard
 */
public interface GenericBootstrap {
    /**
     * Defines the provider resolution strategy.
     * This resolver returns the list of providers evaluated
     * to build the Configuration
     * &lt;p/&gt;
     * If no resolver is defined, the default ValidationProviderResolver
     * implementation is used.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    GenericBootstrap providerResolver(ValidationProviderResolver resolver);

    /**
     * Returns a generic Configuration implementation.
     * At this stage the provider used to build the ValidatorFactory is not defined.
     * &lt;p/&gt;
     * The Configuration implementation is provided by the first provider returned
     * by the ValidationProviderResolver strategy.
     *
     * @return a Configuration implementation compliant with the bootstrap state
     */
    Configuration&lt;?&gt; configure();
}</programlisting>
        </example>

        <para>The last entry point lets the client define the specific Bean
        Validation provider requested as well as a custom
        <classname>ValidationProviderResolver</classname> implementation if
        needed. The entry point method,
        <methodname>Validation.byProvider(Class&lt;T&gt;
        configurationClass)</methodname>, takes the provider specific
        <classname>Configuration</classname> sub interface type and returns a
        <classname>ProviderSpecificBootstrap</classname> object that
        guarantees to return an instance of the specific
        <classname>Configuration</classname> sub interface. Thanks to the use
        of generics, the client API does not have to cast to the
        <classname>Configuration</classname> sub interface.</para>

        <para>A <classname>ProviderSpecificBootstrap</classname> object can
        optionally receive a <classname>ValidationProviderResolver</classname>
        instance.</para>

        <example>
          <title>ProviderSpecificBootstrap interface</title>

          <programlisting>/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider specific Configuration. The specific Configuration
 * sub interface uniquely identifying a provider.
 * &lt;p/&gt;
 * The requested provider is the first provider suitable for T (as defined in
 * {@link javax.validation.spi.ValidationProvider#isSuitable(Class)}). The
 * list of providers evaluated is returned by {@link ValidationProviderResolver}.
 * If no ValidationProviderResolver is defined, the
 * default ValidationProviderResolver strategy is used.
 *
 * @author Emmanuel Bernard
 */
public interface ProviderSpecificBootstrap&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Optionally define the provider resolver implementation used.
     * If not defined, use the default ValidationProviderResolver
     *
     * @param resolver ValidationProviderResolver implementation used
     *
     * @return self
     */
    public ProviderSpecificBootstrap&lt;T&gt; providerResolver(ValidationProviderResolver resolver);

    /**
     * Determine the provider implementation suitable for T and delegate
     * the creation of this specific Configuration subclass to the provider.
     *
     * @return a Configuration sub interface implementation
     */
    public T configure();
}</programlisting>
        </example>

        <para><methodname>ProviderSpecificBootstrap.configure()</methodname>
        must return the result of
        <methodname>ValidationProvider.createSpecializedConfiguration(BootstrapState
        state, Class&lt;T extends Configuration&lt;T&gt;&gt;
        configurationType)</methodname>. The state parameter holds the
        <classname>ValidationProviderResolver</classname> passed to
        <classname>ProviderSpecificBootstrap</classname>. The configuration
        type passed as a parameter is the configuration type passed to
        <methodname>Validation.byProvider(Class)</methodname>. The validation
        provider is selected from the configuration type according to the
        algorithm described in (<xref
        linkend="id-bootstrap-validationprovider" />).</para>

        <para>The <classname>Validation</classname> implementation provided by
        the Bean Validation provider must not contain any non private
        attribute or method aside from the three public static bootstrap
        methods:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>public static ValidatorFactory
            buildDefaultValidatorFactory()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>public static GenericBootstrap
            byDefaultProvider()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>public static &lt;T extends
            Configuration&lt;T&gt;&gt; ProviderSpecificBootstrap&lt;T&gt;
            byProvider(Class&lt;T&gt; configurationType)</methodname></para>
          </listitem>
        </itemizedlist>

        <para>The bootstrap API is designed to allow complete portability
        amongst Bean Validation provider implementations. The bootstrap
        implementation must ensure it can bootstrap third party
        providers.</para>
      </section>

      <section id="xml-config">
        <title>XML Configuration: META-INF/validation.xml</title>

        <para>Unless explicitly ignored by calling
        <classname>Configuration.ignoreXMLConfiguration()</classname>, a
        <classname>ValidatorFactory</classname> takes into account the
        configuration available in
        <filename>META-INF/validation.xml</filename>. This configuration file
        is optional but can be used by application to refine some of the Bean
        Validation behavior.</para>

        <para>Unless stated otherwise, XML based configuration settings are
        overridden by values explicitly set via the
        <classname>Configuration</classname> API. For example, the
        <classname>MessageInterpolator</classname> defined via
        <methodname>Configuration.messageInterpolator(MessageInterpolator)</methodname>
        has priority over the <literal>message-interpolator</literal>
        definition.</para>

        <para><literal>default-provider</literal>: represents the class name
        of the provider specific <classname>Configuration</classname>
        sub-interface. If defined, the provider suitable for this interface is
        used (unless a specific provider has been chosen via the programmatic
        approach).</para>

        <para><literal>message-interpolator</literal>: represents the fully
        qualified class name of the <classname>MessageInterpolator</classname>
        implementation. When defined in XML, the implementation must have a
        public no-arg constructor. This element is optional.</para>

        <para><literal>traversable-resolver</literal>: represents the fully
        qualified class name of the <classname>TraversableResolver</classname>
        implementation. This implementation must have a public no-arg
        constructor. This element is optional.</para>

        <para><literal>constraint-validator-factory</literal>: represents the
        fully qualified class name of the
        <classname>ConstraintValidatorFactory</classname> implementation. When
        defined in XML, the implementation must have a public no-arg
        constructor. This element is optional.</para>

        <para><literal>constraint-mapping</literal>: represents the resource
        path of an XML mapping file. More than one
        <literal>constraint-mapping</literal> element can be present. Mappings
        provided via
        <methodname>Configuration.addMapping(InputString)</methodname> are
        added to the list of mappings described via
        <literal>constraint-mapping</literal>.</para>

        <para><literal>property</literal>: represents a key/value pair
        property providing room to provider specific configuration. Vendors
        should use vendor namespaces for properties (e.g.,
        <literal>com.acme.validation.logging</literal>). Entries that make use
        of the namespace <literal>javax.validation</literal> and its
        subnamespaces must not be used for vendor-specific information. The
        namespace <literal>javax.validation</literal> is reserved for use by
        this specification. Properties defined via
        <methodname>Configuration.addProperty(String, String)</methodname> are
        added to the properties defined via <literal>property</literal>. If a
        property with the same name are defined in both XML and via the
        programmatic API, the value provided via programmatic API has
        priority.</para>

        <example>
          <title>Example of META-INF/validation.xml file</title>

          <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/configuration validation-configuration-1.0.xsd"&gt;
    &lt;default-provider&gt;com.acme.ACMEValidatorConfiguration&lt;/default-provider&gt;
    &lt;message-interpolator&gt;com.acme.ACMEAwareMessageInterpolator&lt;/message-interpolator&gt;

    &lt;constraint-mapping&gt;META-INF/validation/order-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/catalog-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/customer-constraints.xml&lt;/constraint-mapping&gt;

    &lt;property name="com.acme.validation.logging"&gt;WARN&lt;/property&gt;
    &lt;property name="com.acme.validation.safetyChecking"&gt;failOnError&lt;/property&gt;

&lt;/validation-config&gt;</programlisting>
        </example>

        <para>The XML schema is described in <xref
        linkend="xml-config-xsd" />.</para>
      </section>

      <section>
        <title>Usage</title>

        <para>The Bean Validation bootstrap API can be used directly by the
        application, through the use of a container or by framework in need
        for validation. In all cases, the following rules apply:</para>

        <itemizedlist>
          <listitem>
            <para><classname>ValidatorFactory</classname> is a thread-safe
            object that should be built once per deployment unit</para>
          </listitem>

          <listitem>
            <para><classname>Validator</classname> is thread-safe too and
            should be considered a lightweight object.
            <classname>ValidatorFactory</classname> would typically implement
            appropriate <classname>Validator</classname> instance caching
            strategies if needed.</para>
          </listitem>
        </itemizedlist>

        <para>Containers such as Java EE, Web Bean, dependency injection
        frameworks, component frameworks are encouraged to propose access to
        <classname>ValidatorFactory</classname> and
        <classname>Validator</classname> objects in a way that respects the
        following rules. For example, injection of
        <classname>Validator</classname> should be possible.</para>
      </section>
    </section>
  </chapter>

  <chapter id="constraintmetadata" xreflabel="Constraint metadata request API">
    <title>Constraint metadata request APIs</title>

    <para>The Bean Validation specification provides a way to query the
    constraint repository. This API is expected to be used for tooling support
    as well as integration with other frameworks, libraries and JSRs. The Bean
    Validation specification aims to provide both a validation engine and a
    metadata repository for object constraints. Frameworks (EE or SE) in need
    for constraint definition, validation and metadata will be able to rely on
    the Bean Validation specification for these services avoiding any
    unnecessary duplication work from an application and infrastructure point
    of view.</para>

    <section>
      <title>Validator</title>

      <para>The main API to access all metadata related to a given object is
      <classname>Validator</classname> (see <xref linkend="bootstrapping" />
      for more information on how to retrieve a
      <classname>Validator</classname> instance).</para>

      <para>A <classname>Validator</classname> instance hosts the method to
      access to the metadata repository for a given class. It is recommended
      to leave the caching of <classname>Validator</classname> instances to
      the <classname>ValidatorFactory</classname>.
      <classname>Validator</classname> implementations are thread-safe.</para>

      <programlisting>/**
 * Validate a given object type
 * Implementations of this interface must be thread-safe
 * 
 * @author Emmanuel Bernard
 */
public interface Validator {

    [...] //See 4.1

    /**
     * Return the descriptor object describing bean constraints
     * The returned object (and associated objects including ConstraintDescriptors)
     * are immutable.
     *
     * @param clazz class type evaluated
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);<!--Add a method to return the GroupSequences-->
}</programlisting>

      <para><methodname>getConstraintsForClass</methodname> returns a
      <classname>BeanDescriptor</classname> object describing the bean level
      constraints (see <xref
      linkend="constraintdeclarationvalidationprocess-requirements-object" />)
      and providing access to the property level constraints metadata.</para>
    </section>

    <section>
      <title>ElementDescriptor</title>

      <para><classname>ElementDescriptor</classname> is the root interface
      describing elements hosting constraints. It is used to describe the list
      of constraints for a given element (whether it be a field, a method or a
      class).</para>

      <programlisting>/**
 * Describes a validated element (class, field or property).
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ElementDescriptor {

	/**
	 * return true if at least one constraint declaration is present on the element.
	 */
	boolean hasConstraints();

	/**
	 * @return Statically defined returned type.
	 *
	 * @todo should it be Type or even completly removed
	 */
	Class&lt;?&gt; getType();

	/**
	 * Return all constraint descriptors for this element or an
	 * empty Set if none are present.
	 *
	 * @return Set of constraint descriptors for this element
	 */
	Set&lt;ConstraintDescriptor&gt; getConstraintDescriptors();
}</programlisting>

      <para><methodname>getType</methodname> returns either the object type
      for a class, or the returned type for a property (TODO problem of
      generics resolution).</para>

      <para><classname>getConstraintDescriptors</classname> returns the
      <classname>ConstraintDescriptor</classname>s (see <xref
      linkend="constraintmetadata-constraintdescriptor" />), each
      <classname>ConstraintDescriptor</classname> describing one of the
      constraints declared on the given element.</para>

      <para><methodname>hasConstraints</methodname> returns true if the
      element (class, field or property) holds at lease one constraint
      declaration.</para>
    </section>

    <section>
      <title>BeanDescriptor</title>

      <para>The <classname>BeanDescriptor</classname> interface describes a
      constrained Java Bean. This interface is returned by
      <methodname>Validator.getConstraintsForClass(Class&lt;?&gt;)</methodname>.</para>

      <programlisting>/**
 * Describe a constrained Java Bean and the constraints associated to it.
 * 
 * @author Emmanuel Bernard
 */
public interface BeanDescriptor extends ElementDescriptor {
	/**
	 * Returns true if the bean involves validation:
	 *  - a constraint is hosted on the bean itself
	 *  - a constraint is hosted on one of the bean properties
	 *  - or a bean property is marked for cascade (@Valid)
	 *
	 * @return true if the bean nvolves validation
	 *
	 */
	boolean isBeanConstrained();

	/**
	 * Return the property descriptor for a given property.
	 * Return null if the property does not exist or has no
	 * constraint nor is marked as cascaded (see {@link #getConstrainedProperties()} )
	 * 
	 * The returned object (and associated objects including ConstraintDescriptors)
     * are immutable.
	 *
	 * @param propertyName property evaludated
	 */
	PropertyDescriptor getConstraintsForProperty(String propertyName);

	/**
	 * return the property names having at least a constraint defined or marked
	 * as cascaded (@Valid)
	 */
	Set&lt;String&gt; getConstrainedProperties();
}</programlisting>

      <para><methodname>isBeanConstrained</methodname> returns true if the
      given class (and superclasses and interfaces) host at least one
      validation declaration (either constraint or
      <classname>@Valid</classname> annotation). If the method returns false,
      the Bean Validation engine can safely ignore the bean as it will not be
      impacted by validation.</para>

      <para><methodname>getConstraintsForProperty</methodname> returns a
      <classname>PropertyDescriptor</classname> object describing the property
      level constraints (See <xref
      linkend="constraintdeclarationvalidationprocess-requirements-property" />).
      The property is uniquely identified by its name as per the JavaBeans
      convention: field level and getter level constraints of the given name
      are all returned.</para>

      <para><methodname>getConstrainedProperties</methodname> returns the
      names of the bean properties having at least one constraint or being
      cascaded (<classname>@Valid</classname> annotation).</para>
    </section>

    <section>
      <title>PropertyDescriptor</title>

      <para>The <classname>PropertyDescriptor</classname> interface describes
      a constrained property of a Java Bean. This interface is returned by
      <methodname>BeanDescriptor.getConstraintsForProperty(String)</methodname>.
      Constraints declared on the attribute and the getter of the same name
      according to the Java Bean rules are returned by this descriptor.</para>

      <programlisting>/**
 * Describes a Java Bean property hosting validation constraints.
 *
 * Constraints placed on the attribute and the getter for a given property
 * are all referenced by this object.
 *
 * @author Emmanuel Bernard
 */
public interface PropertyDescriptor extends ElementDescriptor {
    /**
     * Is the property marked by the &lt;code&gt;@Valid&lt;/code&gt; annotation.
     * @return true if the annotation is present
     */
    boolean isCascaded();

    /**
     * Name of the property acording to the Java Bean specification.
     * @return property name
     */
    String getPropertyName();
}</programlisting>

      <para>The <methodname>isCascaded</methodname> method returns
      <literal>true</literal> if the property is marked with
      <classname>@Valid</classname>.</para>

      <para><methodname>getPropertyName</methodname> returns the property name
      as described in <xref
      linkend="validationapi-constraintviolation" />.</para>
    </section>

    <section id="constraintmetadata-constraintdescriptor">
      <title>ConstraintDescriptor</title>

      <para>A <classname>ConstraintDescriptor</classname> object describes a
      given constraint declaration (i.e. a constraint annotation).</para>

      <programlisting>/**
 * Describes a single constraint and its composing constraints.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintDescriptor {
	/**
	 * Returns the annotation describing the constraint declaration.
	 * If a composing constraint, parameter values are reflecting
	 * the overridden parameters from the main constraint
	 *
	 * @return The annotation for this constraint.
	 */
	Annotation getAnnotation();

	/**
	 * The Set of groups the constraint is applied on.
	 * If the constraint declares no group, the &lt;code&gt;Default&lt;/code&gt; 
	 * group is returned.
	 * 
	 * @return The groups the constraint is applied on.
	 */
	Set&lt;Class&lt;?&gt;&gt; getGroups();

	/**
	 * Immutable list of the constraint validation implementation classes.
	 *
	 * @return list of the constraint validation implementation classes.
	 */
	List&lt;Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;&gt;
	getConstraintValidatorClasses();

	/**
	 * Returns a map containing the annotation parameter names as keys and the
	 * annotation parameter values as value.
	 * If this constraint is used as part of a composed constraint, parameter
	 * values are reflecting the overridden parameters from the main constraint.
	 *
	 * @return a map containing the annotation paramter names as keys
	 *         and the annotation parameter values as value.
	 */
	Map&lt;String, Object&gt; getParameters();

	/**
	 * Return a set of composing &lt;code&gt;ConstraintDescriptor&lt;/code&gt;s where each
	 * descriptor describes a composing constraint. &lt;code&gt;ConstraintDescriptor&lt;/code&gt;
	 * instances of composing constraints reflect overridden parameter values in
	 * {@link #getParameters()}  and {@link #getAnnotation()}.
	 *
	 * @return a set of &lt;code&gt;ConstraintDescriptor&lt;code&gt; objects or an empty set
	 *         in case there are no composing constraints.
	 */
	Set&lt;ConstraintDescriptor&gt; getComposingConstraints();

	/**
	 * @return true if the constraint is annotated with @ReportAsSingleViolation
	 */
	boolean isReportAsSingleViolation();
}</programlisting>

      <para><methodname>getAnnotation</methodname> returns the annotation
      instance (or an annotation instance representing the given constraint
      declaration). If <classname>ConstraintDescriptor</classname> represents
      a composing annotation (see <xref
      linkend="constraintsdefinitionimplementation-constraintcomposition" />),
      the returned annotation must reflect parameter overriding. In other
      words, the annotation parameter values are the overridden values.</para>

      <para><methodname>getParameters</methodname> returns a map containing
      the annotation parameter names as a key, and the annotation parameter
      values as a value (this API is anticipated to be simpler to use by tools
      than reflection over the annotation instance). If
      <classname>ConstraintDescriptor</classname> represents a composing
      annotation (see <xref
      linkend="constraintsdefinitionimplementation-constraintcomposition" />),
      the returned <classname>Map</classname> must reflect parameter
      overriding.</para>

      <para><methodname>getGroups</methodname> returns the groups the
      constraint is supposed to be applied upon. If no group is set on the
      constraint declaration, the <classname>Default</classname> group is
      returned. The groups of a composing constraint are the groups of the
      composed constraint.</para>

      <para><methodname>getConstraintValidatorClasses</methodname> returns the
      <classname>ConstraintValidator</classname> classes associated with the
      constraint.</para>
    </section>

    <section>
      <title>Example</title>

      <para>Assuming the following <classname>@NotEmpty</classname>
      definition</para>

      <programlisting>@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmptyConstraintValidator.class)
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
public @interface NotEmpty {
    ...
}</programlisting>

      <para>and the following class definitions</para>

      <programlisting>public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Length(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    private String title;
    private String description;

    @Valid
    @NotNull
    private Author author;

    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    @Length(max=30)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setAuthor(String description) {
        this.description = description;
    }
}</programlisting>

      <para>The following assertions are true.</para>

      <programlisting>BeanDescriptor bookDescriptor = validator.getConstraintsForClass(Book.class);

assert ! bookDescriptor.hasConstraints();

assert bookDescriptor.isBeanConstrained();

assert bookDescriptor.getConstraintDescriptors().size() == 0 //no bean-level constraint

//more specifically "author" and "title"
assert bookDescriptor.getConstrainedProperties().size() == 2;

//not a property
assert bookDescriptor.getConstraintsForProperty("doesNotExist") == null; 

//property with no constraint
assert bookDescriptor.getConstraintsForProperty("description") == null; 

ElementDescriptor propertyDescriptor = bookDescriptor.getConstraintsForProperty("title");
assert propertyDescriptor.getConstraintDescriptors().size() == 2
assert "title".equals( propertyDescriptor.getPropertyName() );

//assuming the implementation returns the @NotEmpty constraint first
ConstraintDescriptor constraintDescriptor = propertyDescriptor.getConstraintDescriptors()
                                                              .iterator().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( NotEmpty.class );
assert constraintDescriptor.getGroups().size() == 2; //FirstLevelCheck and Default
assert constraintDescriptor.getComposingConstraints().size() == 2;
assert constraintDescriptor.isReportAsSingleViolation() == true

//@NotEmpty cannot be null
boolean notNullPresence = false;
for ( ConstraintDescriptor composingDescriptor : constraintDescriptor.getComposingConstraints() ) {
    if ( composingDescriptor.getAnnotation().getAnnotationType().equals( NotNull.class ) ) {
        notNullPresence = true;
    }
}
assert notNullPresence; 

//assuming the implementation returns the Length constraint second
constraintDescriptor = propertyDescriptor.getConstraintDescriptors().iterator().next().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( Length.class );
assert constraintDescriptor.getParameters().get("max") == 30; 
assert constraintDescriptor.getGroups().length == 1;

propertyDescriptor = bookDescriptor.getConstraintsForProperty("author");
assert propertyDescriptor.getConstraintDescriptors().size() == 1
assert propertyDescriptor.isCascaded()</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Built-in Constraint definitions</title>

    <para>The specification defines a small set of built-in constraints. Their
    usage is encouraged both in regular constraint declarations and as
    composing constraints. Using this set of constraints will enhance
    portability of your constraints across constraint-consuming frameworks
    relying on the metadata API (such as client side validation frameworks or
    database schema generation frameworks).</para>

    <para>All built-in constraints are in the
    <classname>javax.validation.constraints</classname> package. Here is the
    list of constraints and their declaration.</para>

    <example>
      <title>@Null constraint</title>

      <programlisting>/**
 * The annotated element must be null.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Null {
    String message() default "{validator.null}";

    Class&lt;?&gt;[] groups() default { };
}</programlisting>
    </example>

    <example>
      <title>@NotNull constraint</title>

      <programlisting>/**
 * The annotated element must not be &lt;code&gt;null&lt;/code&gt;.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface NotNull {
    String message() default "{validator.notNull}";

    Class&lt;?&gt;[] groups() default { };
}</programlisting>
    </example>

    <example>
      <title>@AssertTrue constraint</title>

      <programlisting>/**
 * The annotated element must be true.
 * Supported types are &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface AssertTrue {
    String message() default "{validator.assertTrue}";

    Class&lt;?&gt;[] groups() default { };
}</programlisting>
    </example>

    <example>
      <title>@AssertFalse constraint</title>

      <programlisting>/**
 * The annotated element must be false.
 * Supported types are &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface AssertFalse {
    String message() default "{validator.assertFalse}";

    Class&lt;?&gt;[] groups() default { };
}</programlisting>
    </example>

    <example>
      <title>@Min constraint</title>

      <programlisting>/**
 * The annotated element must be a number whose value must be greater or
 * equal than the specificed minimum
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, 
 * &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid
 *
 * @author Emmanuel Bernard
 * @todo support byte ?!
 * @todo Is string supported or not?
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Min {
    String message() default "{validator.min}";

    Class&lt;?&gt;[] groups() default { };

    /**
     * @return Value the element must be higher or equal to
     */
    long value();
}</programlisting>
    </example>

    <example>
      <title>@Max constraint</title>

      <programlisting>/**
 * The annotated element must be a number whose value must be lower or
 * equal than the specificed maximum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, 
 * &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid
 *
 * @author Emmanuel Bernard
 * @todo support byte ?!
 * @todo Is string supported or not?
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Max {
    String message() default "{validator.max}";

    Class&lt;?&gt;[] groups() default { };

    /**
     * @return Value the element must be lower or equal to
     */
    long value();
}</programlisting>
    </example>

    <example>
      <title>@Size constraint</title>

      <programlisting>/**
 * The annotated element size must be between the specified boundaries (included).
 *
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt; (string length is evaludated)&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;Collection&lt;/code&gt; (collection size is evaluated)&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;Map&lt;/code&gt; (map size is evaluated)&lt;/li&gt;
 * &lt;li&gt;Array (array length is evaludated)&lt;/li&gt;
 *
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Size {
    String message() default "{validator.min}";
    Class&lt;?&gt;[] groups() default {};

    /**
     * @return size the element must be higher or equal to
     */
    int min() default Integer.MIN_VALUE;

    /**
     * @return size the element must be lower or equal to
     */
    int max() default Integer.MAX_VALUE;
}</programlisting>
    </example>

    <example>
      <title>@Digits constraint</title>

      <programlisting>/**
 * The annotated element must be a number within accepted range
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;,
 * &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid
 *
 * @author Emmanuel Bernard
 * @todo support byte ?!
 * @todo Is string supported or not?
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Digits {
    String message() default "{validator.digits}";

    Class&lt;?&gt;[] groups() default { };

    /**
     * @return maximum number of integral digits accepted for this number
     */
    int integer();

    /**
     * @return maximum number of fractional digits accepted for this numbe
     */
    int fraction();
}</programlisting>
    </example>

    <example>
      <title>@Past constraint</title>

      <programlisting>/**
 * The annotated element must be a date in the past.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type &lt;code&gt;Calendar&lt;/code&gt;
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * TODO what are the implications
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * - TODO new date/time JSR types?
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Past {
    String message() default "{validator.past}";

    Class&lt;?&gt;[] groups() default { };
}</programlisting>
    </example>

    <example>
      <title>@Future constraint</title>

      <programlisting>/**
 * The annotated element must be a date in the future.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type &lt;code&gt;Calendar&lt;/code&gt;
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * TODO what are the implications
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * - TODO new date/time JSR types?
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Future {
    String message() default "{validator.future}";

    Class&lt;?&gt;[] groups() default { };
}</programlisting>
    </example>

    <example>
      <title>@Pattern constraint</title>

      <programlisting>/**
 * The annotated String must match the following regular expression.
 * The regular expression follows the Java regular expression conventions
 * see {@link java.util.regex.Pattern}.
 *
 * Accepts String.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Pattern {
	/**
	 * regular expression to match
	 */
	String regexp();

	/**
	 * Flags considered when resolving the regular expression
	 */
	Flag[] flags() default {};

	/**
	 * error message template
	 */
	String message() default "{validator.past}";

	/**
	 * groups the constraint belongs to
	 */
	Class&lt;?&gt;[] groups() default { };

	/**
	 * Possible Regexp flags
	 */
	public static enum Flag {
		/**
		 * Enables Unix lines mode
		 * @see java.util.regex.Pattern#UNIX_LINES
		 */
		UNIX_LINES,

		/** 
		 * Enables case-insensitive matching
		 * @see java.util.regex.Pattern#CASE_INSENSITIVE
		 */
		CASE_INSENSITIVE,

		/**
		 * Permits whitespace and comments in pattern
		 * @see java.util.regex.Pattern#COMMENTS
		 */
		COMMENTS,

		/**
		 * Enables multiline mode
		 * @see java.util.regex.Pattern#MULTILINE
		 */
		MULTILINE,

		/**
		 * Enables dotall mode
		 * @see java.util.regex.Pattern#DOTALL
		 */
		DOTALL,

		/**
		 * Enables Unicode-aware case folding
		 * @see java.util.regex.Pattern#UNICODE_CASE
		 */
		UNICODE_CASE,

		/**
		 * Enables canonical equivalence
		 * @see java.util.regex.Pattern#CANON_EQ
		 */
		CANON_EQ,
	}
}</programlisting>
    </example>

    <para>Built-in annotations are not annotated with
    <classname>@ConstraintValidator</classname> to avoid any dependency
    between the specification API and a specific implementation. Each Bean
    Validation provider must recognize built-in constraint annotations as
    valid constraint definitions and provide a compliant constraint
    implementation for each.</para>
  </chapter>

  <chapter>
    <title>XML deployment descriptor</title>

    <para>Two kind of XML descriptors are used by Bean Validation. The first
    one describes the Bean Validation configuration provided as
    <filename>META-INF/validation.xml</filename>. The second one describes
    constraints declarations and closely matches the annotations declaration
    approach.</para>

    <section>
      <title>Constraint definition and declaration</title>

      <para>Bean Validation lets you declare constraints via XML rather than
      annotations. You can either ignore constraints declared via annotations
      or consider XML as adding additional constraints on top of annotation
      constraints. While it is not possible to define a new constraint via
      XML, you can redefine the list of
      <classname>ConstraintValidator</classname> classes associated to a given
      constraint definition.</para>

      <para>There is no distinction between an annotation based constraint
      declaration and an XML based constraint declaration: they are considered
      equivalent and should be treaded as such by the Bean Validation
      provider.. Specifically when exploring metadata, the Bean Validation
      provider must ensure that an annotation instance corresponding to the
      XML declaration is provided via
      <classname>ConstraintDescriptor.getAnnnotation()</classname>. The
      annotation elements as well as
      <methodname>ConstraintValidator.getParameters()</methodname> must
      reflect the values described in the XML declaration (see <xref
      linkend="xml-mapping-typeconversion" />). Likewise,
      <methodname>ConstraintDescriptor.getConstraintValidatorClasses()</methodname>
      must reflect XML based constraint definition overriding (see <xref
      linkend="xml-mapping-constraintdefinition" />).</para>

      <para>A given class must not be described more than once amongst the XML
      mapping descriptors. A given field or getter must not be described more
      than once on a given class description. A given constraint definition
      must not be overridden more than once amongst the XML mapping
      descriptors. If any of these rule is violated in a given validation
      deployment, a <classname>DuplicateMappingException</classname> is raised
      during the creation of the
      <classname>ValidatorFactory</classname>.</para>

      <para>The schema is provided in <xref
      linkend="xml-mapping-xsd" />.</para>

      <section>
        <title>Constraint declaration in XML</title>

        <para>If <literal>default-package</literal> is set, all unqualified
        class names (including annotations) are considered part of the package
        described by <literal>default-package</literal>.</para>

        <para>A given JavaBean is described by the <classname>bean</classname>
        element. The name of the class is mandatory. By default, all
        constraint declarations expressed via annotation are ignored for
        classes described in XML. You can force Bean Validation to consider
        both annotation and XML constraint declarations by using
        <code>ignore-annotation="false"</code> on
        <literal>bean</literal>.</para>

        <para>If the name of the class does refer to a class not present in in
        the classpath, a <classname>ConfigurationException</classname> is
        raised.</para>

        <example>
          <title>Example of bean XML declaration</title>

          <programlisting>&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;

    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;

    &lt;bean class="Customer" ignore-annotations="false"&gt;
        [...]
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        [...]
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</programlisting>
        </example>

        <section>
          <title>Class-level overriding</title>

          <para>Class level annotations are described via the
          <literal>class</literal> element. If
          <literal>ignore-annotations</literal> is declared, Bean Validation
          must honor the explicit value for this element. If not declared, the
          default value for the bean is considered.</para>

          <para>When ignore annotations is true, class-level Bean Validation
          annotations are ignored for this class (including the
          <classname>@GroupSequence</classname>). When ignore annotations is
          false:</para>

          <itemizedlist>
            <listitem>
              <para>Constraints declared in XML and constraints declared in
              annotations are added and form the list of class-level declared
              constraints.</para>
            </listitem>

            <listitem>
              <para><classname>@GroupSequence</classname> is considered unless
              <literal>group-sequence</literal> element is explicitly
              used.</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Example of class-level declaration</title>

            <programlisting>&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;class ignore-annotations="true"&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        &lt;class&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</programlisting>
          </example>
        </section>

        <section>
          <title>Field-level overriding</title>

          <para>Field level annotations are described via the
          <literal>field</literal> element. The <literal>name</literal>
          attribute correspond to the name of the field considered. If
          <literal>ignore-annotations</literal> is declared, Bean Validation
          must honor the explicit value for this element. If not declared, the
          default value for the bean is considered.</para>

          <para>When ignore annotations is true, field-level Bean Validation
          annotations on the targeted field are ignored (including the
          <classname>@Valid</classname>). When ignore annotations is
          false:</para>

          <itemizedlist>
            <listitem>
              <para>Constraints declared in XML and constraints declared in
              annotations are added and form the list of field-level declared
              constraints.</para>
            </listitem>

            <listitem>
              <para><classname>@Valid</classname> is considered unless
              <literal>valid</literal> element is explicitly use. Note that
              the only way to disable cascading on a field marked as
              <classname>@Valid</classname> is to use
              <code>ignore-validation=true</code>.</para>
            </listitem>
          </itemizedlist>

          <para>If the name of the field does not correspond to a field in the
          given bean a <classname>ConfigurationException</classname> is
          raised.</para>

          <example>
            <title>Field-level declaration</title>

            <programlisting>&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;field name="firstName"&gt;
            [...]
        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/field&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</programlisting>
          </example>
        </section>

        <section>
          <title>Property-level overriding</title>

          <para>Property-level annotations are described via the
          <literal>getter</literal> element. The <literal>name</literal>
          attribute correspond to the name of the property considered as
          defined in <xref
          linkend="constraintdeclarationvalidationprocess-requirements-property" />
          (for example a getter <code>String getAge()</code> would have
          <code>&lt;getter name="age"/&gt;</code> as a corresponding
          descriptor). If <literal>ignore-annotations</literal> is declared,
          Bean Validation must honor the explicit value for this element. If
          not declared, the default value for the bean is considered.</para>

          <para>When ignore annotations is true, property-level Bean
          Validation annotations on the targeted property are ignored
          (including the <classname>@Valid</classname>). When ignore
          annotations is false:</para>

          <itemizedlist>
            <listitem>
              <para>Constraints declared in XML and constraints declared in
              annotations are added and form the list of property-level
              declared constraints.</para>
            </listitem>

            <listitem>
              <para><classname>@Valid</classname> is considered unless
              <literal>valid</literal> element is explicitly use. Note that
              the only way to disable cascading on a field marked as
              <classname>@Valid</classname> is to use
              <code>ignore-validation=true</code>.</para>
            </listitem>
          </itemizedlist>

          <para>If the name of the property does not correspond to a property
          in the given bean a <classname>ConfigurationException</classname> is
          raised.</para>

          <example>
            <title>Property-level declaration</title>

            <programlisting>&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;getter name="firstName"&gt;
            [...]
        &lt;/getter&gt;
        &lt;getter name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/getter&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</programlisting>
          </example>
        </section>

        <section>
          <title>Constraint declaration</title>

          <para>A new constraint declaration is represented by the
          <literal>constraint</literal> element. The annotation
          <literal>attribute</literal> is the class name of the annotation
          representing the constraint. Message and groups are defined
          respectively by the <literal>message</literal> and
          <literal>groups</literal> elements.</para>

          <para>Other custom elements of an annotation are represented by
          <literal>element</literal>. The <literal>name</literal> attribute is
          mandatory and represents the name of the element in the constraint
          declaration. <quote>message</quote>, <quote>groups</quote> are not
          permitted names, use the <literal>message</literal> or
          <literal>groups</literal> elements instead.</para>

          <para>If the element represents a primitive type, a class or an
          enum, the string representation of its value is placed in the
          element itself. See <xref linkend="xml-mapping-typeconversion" />
          for a detailed explanation of the conversion rules from string to
          the type.</para>

          <para>If the element represents a primitive type array, a class
          array or an enum array, the string representation of each value is
          placed in a <literal>value</literal> element placed under the
          element itself.</para>

          <para>If the element represents an annotation, the
          <literal>annotation</literal> element is used to represent the
          annotation and placed under <literal>element</literal>. An
          <literal>annotation</literal> element contains
          <literal>element</literal> elements.</para>

          <para>If the element represents an array of annotations, one or more
          <literal>annotation</literal> elements are placed under
          <literal>element</literal>.</para>

          <para>Elements with default values in the annotation definition do
          not have to be represented in XML: the default value will be used in
          this case. If an XML constraint declaration is missing mandatory
          elements, or if it contains elements not part of the constraint
          definition, a <classname>ConfigurationException</classname> is
          raised.</para>

          <example>
            <title>Constraint declaration</title>

            <programlisting>&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;

        &lt;field name="firstName"&gt;


            &lt;!-- @LooksLike(patterns={
                      @Pattern(value="myRegExp", flag=PatternFlag.INSENSITIVE),
                      @Pattern(value="my2ndRegExp")}
                  )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.LooksLike"&gt;
                &lt;element name="patterns"&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;myRegExp&lt;/element&gt;
                        &lt;element name="flag"&gt;
                            &lt;value&gt;INSENSITIVE&lt;/value&gt;
                        &lt;/element&gt;
                    &lt;/annotation&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;my2ndRegExp&lt;/element&gt;
                    &lt;/annotation&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @DiscreteSize(value={ 0, 20 } )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.DiscreteSize"&gt;
                &lt;element name="value"&gt;
                    &lt;value&gt;0&lt;/value&gt;
                    &lt;value&gt;20&lt;/value&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;

        &lt;getter name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @Size(message="Size is limited",
                       groups={Default.class, LightValidation.class},
                       max=30
                 )
            --&gt;
            &lt;constraint annotation="javax.validation.constraint.Size"&gt;
                &lt;message&gt;Size is limited&lt;/message&gt;
                &lt;groups&gt;
                    &lt;value&gt;com.acme.app.model.LightValidation&lt;/value&gt;
                    &lt;value&gt;javax.persistence.Default&lt;/value&gt;
                &lt;/groups&gt;
                &lt;element name="max"&gt;30&lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/getter&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</programlisting>
          </example>
        </section>
      </section>

      <section id="xml-mapping-constraintdefinition">
        <title>Overriding constraint definitions in XML</title>

        <para>A constraint definition (ie. the annotation representing a
        constraint), cannot be fully expressed in XML but the list of
        <classname>ConstraintValidator</classname> associated to a given
        constraint can be altered.</para>

        <para>A constraint definition is represented by a
        <literal>constraint-definition</literal> element. The
        <literal>annotation</literal> attribute represents the constraint
        annotation being altered. The <literal>validated-by</literal> elements
        represent the (ordered) list of
        <classname>ConstraintValidator</classname> implementations associated
        to the constraint.</para>

        <para>If <literal>include-existing-validator</literal> is set to
        false, <classname>ConstraintValidator</classname> defined on the
        constraint annotation are ignored. If set to true, the list of
        <classname>ConstraintValidator</classname>s described in XML are
        concatenated to the list of <classname>ConstraintValidator</classname>
        described on the annotation to form a new array of
        <classname>ConstraintValidator</classname> evaluated. Annotation based
        <classname>ConstraintValidator</classname> come before XML based
        <classname>ConstraintValidatot</classname> in the array. The new list
        is returned by
        <methodname>ConstraintDescriptor.getConstraintValidatorClasses()</methodname>.</para>

        <example>
          <title>Overriding constraint definitions</title>

          <programlisting>&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
   &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
   &lt;bean class="com.acme.common.model.Address"&gt;
       [...]
    &lt;/bean&gt;

    &lt;constraint-definition annotation="javax.validation.constraint.Size"&gt;
        &lt;validated-by include-existing-validators="true"&gt;
            &lt;value&gt;com.acme.app.constraint.SizeValidatorForDictionary&lt;/value&gt;
        &lt;/validated-by&gt;
    &lt;/constraint-definition&gt;
    &lt;constraint-definition annotation="AcmeOrderNumber"&gt;
        [...]
    &lt;/constraint-definition&gt;
&lt;/constraint-mappings&gt;</programlisting>
        </example>
      </section>

      <section id="xml-mapping-typeconversion">
        <title>Converting the string representation of a value</title>

        <para>Primitive types, <classname>Class</classname> and
        <classname>Enum</classname> are represented as strings in the XML
        descriptor. Elements of an array are represented by the
        <literal>value</literal> element.</para>

        <para><classname>byte</classname> are represented according to the
        rules defined in
        <methodname>Byte.parseByte(String)</methodname>.</para>

        <para><classname>short</classname> are represented according to the
        rules defined in
        <methodname>Short.parseShort(String)</methodname>.</para>

        <para><classname>int</classname> are represented according to the
        rules defined in
        <methodname>Integer.parseInt(String)</methodname>.</para>

        <para><classname>long</classname> are represented according to the
        rules defined in
        <methodname>Long.parseLong(String)</methodname>.</para>

        <para><classname>float</classname> are represented according to the
        rules defined in
        <methodname>Float.parseFloat(String)</methodname>.</para>

        <para><classname>double</classname> are represented according to the
        rules defined in
        <methodname>Double.parseDouble(String)</methodname>.</para>

        <para><classname>boolean</classname> are represented according to the
        rules defined in
        <methodname>Boolean.parseBoolean(String)</methodname>.</para>

        <para><classname>char</classname> are represented according to the
        following rules:</para>

        <itemizedlist>
          <listitem>
            <para>the string must be of one character long</para>
          </listitem>

          <listitem>
            <para>the character extracted from the string is the returned
            <classname>char</classname></para>
          </listitem>
        </itemizedlist>

        <para>A <classname>Class</classname> is represented by the fully
        qualified class name of the class. Note that if the raw string is
        unqualified, default package is taken into account.</para>

        <para>An enum is represented by its <code>enum.name()</code>
        value.</para>

        <para>If any of the string representation does not match its type
        counterpart, a <classname>ConfigurationException</classname> is
        raised.</para>
      </section>

      <section id="xml-mapping-xsd">
        <title>XML Schema</title>

        <para>This section contains the XML schema used for constraint
        mapping.</para>

        <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/mapping"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           version="1.0"&gt;
    &lt;xs:element name="constraint-mappings"
                type="map:constraint-mappingsType"
                xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;

    &lt;xs:complexType name="groupsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupSequenceType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-mappingsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-package" minOccurs="0"/&gt;
            &lt;xs:element type="map:beanType"
                        name="bean"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:constraint-definitionType"
                        name="constraint-definition"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="validated-byType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="include-existing-validators" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraintType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="message" minOccurs="0"/&gt;
            &lt;xs:element type="map:groupsType"
                        name="groups"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="elementType" mixed="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="map:annotationType"
                        name="annotation"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="classType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="groupSequenceType" name="group-sequence" minOccurs="0"/&gt;
            &lt;xs:element type="xs:simpleType" name="stop-constraint-inheritance" fixed="" minOccurs="0"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="beanType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:classType"
                        name="class"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"&gt;
            &lt;/xs:element&gt;
            &lt;xs:element type="map:fieldType"
                        name="field"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:getterType"
                        name="getter"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="class" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="annotationType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="getterType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="xs:string" name="stop-constraint-inheritance" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-definitionType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:validated-byType"
                        name="validated-by"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="fieldType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="xs:string" name="stop-constraint-inheritance" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</programlisting>
      </section>
    </section>

    <section id="xml-config-xsd">
      <title>Configuration schema</title>

      <para>XML Configuration is set in
      <filename>META-INF/validation.xml</filename>. The file is optional. The
      XML schema followed by the configuration file is as followed.</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/configuration"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           version="1.0"&gt;
    &lt;xs:element name="validation-config" type="validation-configType"/&gt;
    &lt;xs:complexType name="validation-configType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-provider" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="message-interpolator" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="traversable-resolver" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-validator-factory" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-mapping" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="propertyType" name="property" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="propertyType"&gt;
        &lt;xs:attribute name="name" use="required" type="xs:string"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</programlisting>

      <para>See <xref linkend="xml-config" /> for more information on XML
      based configuration.</para>
    </section>
  </chapter>

  <appendix id="terminology">
    <title>Terminology</title>

    <para>This appendix aims at giving an overview on the different specific
    terms used through this specification. There are not to be considered
    formal definitions. Formal definitions are to be inferred from the core
    specification.</para>

    <table>
      <title>terminology</title>

      <tgroup cols="2">
        <colspec align="center" colnum="3" />

        <thead>
          <row>
            <entry>Term</entry>

            <entry colsep="" spanname="">Definition</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Constraint</entry>

            <entry>A restriction on a bean instance, the value of a field or
            the value of a JavaBean property</entry>
          </row>

          <row>
            <entry>Constraint declaration</entry>

            <entry>Assignment of a constraint on a target (bean, field,
            property) for a specific class. Typically by declaring an
            annotation on the target but can also be done through a deployment
            descriptor in XML</entry>
          </row>

          <row>
            <entry>Validation routine</entry>

            <entry><para>Implementation of the validation algorithm associated
            to a given constraint </para><para>Also means, sequence of
            operations executed by the Bean Validation provider to validate a
            given object</para></entry>
          </row>

          <row>
            <entry>Constraint definition</entry>

            <entry>Defines a type of constraint, it's attributes and the
            actual constraint implementation. Usually done through
            annotations, this definition can also be done through XML</entry>
          </row>

          <row>
            <entry>group</entry>

            <entry>Constraints can belong to one or more group or context.
            Useful to apply a subset of the constraints for a given use case.
            By default, the <literal>Default</literal> group is used.</entry>
          </row>

          <row>
            <entry>group sequence</entry>

            <entry>Define a group ordering in the validation process. If a
            given ordered group contains one or more failure, the following
            ones in the sequence must be ignored.</entry>
          </row>

          <row>
            <entry>Constraint validation</entry>

            <entry>constraint logic algorithm used to determine whether a
            given value passes a constraint or not.</entry>
          </row>

          <row>
            <entry>Constraint validation implementation</entry>

            <entry>Class implementing the constraint logic and used to
            determine whether a given value pass a constraint or not.</entry>
          </row>

          <row>
            <entry>Validation API</entry>

            <entry>Main API used to validate a given type of bean</entry>
          </row>

          <row>
            <entry>Bean validation provider</entry>

            <entry>Implementation of the specification</entry>
          </row>

          <row>
            <entry>Message interpolator</entry>

            <entry>Algorithm used to build the end user message associated to
            a constraint failure. Typically useful for i18n</entry>
          </row>

          <row>
            <entry>Constraint metadata API</entry>

            <entry>API exposing the constraints applied to a given bean type.
            Also considered one of the integration points with other JSR or
            frameworks.</entry>
          </row>

          <row>
            <entry>javax.validation.ConstraintValidator</entry>

            <entry>interface implemented by a constraint validation
            implementation</entry>
          </row>

          <row>
            <entry>Composing constraint</entry>

            <entry>Constraint declared on another constraint definition. When
            the main constraint is validated, the composing constraints are
            validated too.</entry>
          </row>

          <row>
            <entry>javax.validation.Validator</entry>

            <entry>Main interface for the validation API</entry>
          </row>

          <row>
            <entry>javax.validation.ConstraintViolation</entry>

            <entry>interface describing a given constraint failure on a given
            bean</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para></para>
  </appendix>

  <appendix id="standard-resolver-messages">
    <title>Standard ResourceBundle messages</title>

    <para>The properties listed below are resolved by the default message
    interpolator.</para>

    <programlisting>validator.null=must be null
validator.notNull=must not be mull
validator.assertTrue=assertion failed
validator.assertFalse=assertion failed
validator.min=must be greater than or equal to {value}
validator.max=must be less than or equal to {value}
validator.size=size must be between {min} and {max}
validator.digits=numeric value out of bounds (&lt;{integer} digits&gt;.&lt;{fraction} digits&gt; expected)
validator.past=must be a past date
validator.future=must be a future date</programlisting>
  </appendix>

  <appendix id="appendix-methodlevelvalidation">
    <title>Proposal for method-level validation</title>

    <para>This proposal is not yet present in the specification but is
    considered for inclusion due to numerous feedbacks from the early
    draft.</para>

    <para>A popular demand was to provide a method and parameter level
    validation mechanism reusing the constraint descriptions of the
    specification. This set of APIs is meant to be used by interceptor
    frameworks such as:</para>

    <itemizedlist>
      <listitem>
        <para>application frameworks like Web Beans</para>
      </listitem>

      <listitem>
        <para>component frameworks like Enterprise Java Beans</para>
      </listitem>

      <listitem>
        <para>aspect based frameworks</para>
      </listitem>
    </itemizedlist>

    <para>These frameworks can call the validation APIs to validate either the
    parameter list or the returned value of a method when such method is
    called. More precisely, validation occurs around a method
    invocation.</para>

    <para>This extension of the Bean Validation API allows to reuse the core
    engine as well as the constraint definition and declaration for such
    method level validations.</para>

    <para>The following APIs are added to
    <classname>Validator</classname>.</para>

    <programlisting>public interface Validator {
    // [...]
    
    
    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the method for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if the Object[] does not match the method signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(Class&lt;T&gt; clazz, Method method,
                                                       Object[] parameterValues,
                                                       Class&lt;?&gt;... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the parameterIndex-t parameter of method
     * @param parameterIndex parameter index of the parameter validated in method
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Method method,
                                                   Object parameterValue,
                                                   int parameterIndex, Class&lt;?&gt;... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose result is validated
     * @param returnedValue the value returned by the method invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateReturnedValue(Class&lt;T&gt; clazz, Method method,
                                                       Object returnedValue, Class&lt;?&gt;... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the constructor whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the constructor for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if the Object[] does not match the constructor signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameters(Class&lt;T&gt; clazz, Constructor constructor,
                                                    Object[] parameterValues, Class&lt;?&gt;... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the
     *                       parameterIndex-th parameter of constructor
     * @param parameterIndex parameter index of the parameter validated in constructor
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Constructor constructor,
                                                   Object parameterValue, int parameterIndex,
                                                   Class&lt;?&gt;... groups);</programlisting>

    <para>The constraints declarations evaluated are the constraints hosted on
    the parameters of the method or constructor. If
    <classname>@Valid</classname> is placed on a parameter, constraints
    declared on the object itself are considered.</para>

    <para><methodname>validateReturnedValue</methodname> evaluates the
    constraints hosted on the method itself. If <classname>@Valid</classname>
    is placed on the method, the constraints declared on the object itself are
    considered.</para>

    <programlisting>public @NotNull String saveItem(@Valid @NotNull Item item, @Max(23) BigDecimal price)</programlisting>

    <para>In the previous example,</para>

    <itemizedlist>
      <listitem>
        <para><literal>item</literal> is validated against
        <classname>@NotNull</classname> and all the constraints it
        hosts</para>
      </listitem>

      <listitem>
        <para><literal>price</literal> is validated against
        <classname>@Max(23)</classname></para>
      </listitem>

      <listitem>
        <para>the result of <methodname>saveItem</methodname> is validated
        against <classname>@NotNull</classname></para>
      </listitem>
    </itemizedlist>

    <para>Note that the Bean Validation specification does not trigger the
    validation call. An external framework is responsible for calling one of
    the <methodname>validateParameters</methodname>,
    <methodname>validateParameter</methodname> and
    <methodname>validateReturnedValue</methodname> methods at the appropriate
    time.</para>

    <para>For completeness, Bean Validation exposes metadata for constraints
    hosted on parameters and methods.</para>

    <programlisting>public interface ParameterDescriptor extends ElementDescriptor { 
    boolean isCascaded(); 
    int getIndex(); 
} 

public interface MethodDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
    boolean isCascaded(); 
} 

public interface ConstructorDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
} 

public interface BeanDescriptor { 
    MethodDescriptor getConstraintsForMethod(Method); 
    MethodDescriptor getConstraintsForConstructor(Constructor); 
    Set&lt;String&gt; getConstrainedProperties(); 
    Set&lt;Method&gt; getConstrainedMethods(); 
    Set&lt;Constructor&gt; getConstrainedConstructors(); 
} </programlisting>
  </appendix>

  <appendix id="appendix-jpa">
    <title>Proposal for Java Persistence 2.0 integration</title>

    <para>This proposal is been discussed in the Java Persistence 2.0 expert
    group for evaluation. It does not represent the final views of the JPA 2.0
    expert group and is here to give a global picture of how Bean Validation
    can be brought to the EE ecosystem.</para>

    <programlisting>Java Persistence / Bean Validation integration proposal

Integration between Java Persistence and Bean Validation (BV) happens at two levels:
- as a metadata provider for DDL generation and generally speaking the behavior of
the persistence provider. This approach will be treated in a different email.
- as a validation engine called on entity changes


** Using the Bean Validation (BV) engine inside a Java Persistence provider

Java Persistence delegates the validation of entities to Bean Validation on the following 
entity events:
- pre persist (an entity must be valid to be inserted in the DB)
- pre update (an entity change must be valid before being propagated to the database)
- pre remove (eg. a Customer still owning some Payments cannot be removed)

These events are called at the same time as their respective callback methods after
all callbacks have been called.

For each event type, a list of groups is targeted for validation. By default,
pre persist and pre update events validate the group Default (default BV group)
and pre remove does not validate any group. Each list can be overridden
by a JPA property:
- javax.persistence.validation.group.pre-persist for pre persist events
- javax.persistence.validation.group.pre-update for pre update events
- javax.persistence.validation.group.pre-remove for pre remove events

Question: should JPA introduce the following groups
/** Defaut validation group used when an entity is persisted */
public interface Persist extends Default {}

/** Defaut validation group used when an entity is updated */
public interface Update extends Default {}

/** Defaut validation group used when an entity is removed */
public interface Remove {}


Each property holds the list of targeted groups (fully qualified class name)
separated by a comma.

When any of the pre-cited event is raised on an entity instance 'a' of type A,
the persistence provider must validate 'a' by invoking a validator with the
targeted groups. If the list of targeted groups is empty,
no validation is performed. If the set of constraint violation is not empty,
a javax.validation.ValidationException containing a reference to this set of violations is raised.


** Special need from Java Persistence

Validator instances used to validate entities on pre-* events must use a TraversableResolver
implementing the following logic:
- Lazy properties or associations must not be traversed
- Single or multi valued associations pointing to entities must not be traversed

A typical implementation could rely on 
Persistence.isLoaded(Object objectHostingTheProperty, String property)
to determine the load state of the entity properties.
In the situation where only a singe (ie the default) persistence provider is available
in the classpath, the container can implement a potentially optimized TraversableResolver
that does not rely on Persistence.isLoaded(Object objectHostingTheProperty, String property).

The TraversableResolver instance is passed to Bean Validation through
ValidatorFactory.usingContext().traversableResolver(jpaSpecificTR).getValidator()

These rules guarantee that:
- no lazy property nor association will be loaded by side effect
- no entity will be validated more than once even if it is reachable through @Valid several
times by entities changing state. This keeps JPA cascading and BV orthogonal.


** Interaction between Persistence and Validation Providers
BV metadata APIs and runtime are available from ValidatorFactory instances. It
is recommended to cache ValidatorFactory instances and retrieve Validator on demand.
ValidatorFactory provides metadata informations to the JPA provider, it will be built at
or before EntityManagerFactory initialization.

Providing the ValidatorFactory
-- in EE
A ValidatorFactory is made available at the platform level by the Java EE container. This
ValidatorFactory instance is passed to the persistence provider via the configuration
Map of PersistenceProvider.createContainerEntityManagerFactory(PersistenceUnitInfo, Map).
The property name is
javax.persistence.validation.factory (Persistence.VALIDATOR_FACTORY)
Note that the container must pass an instance of VF.


-- in SE
Out of container, the Persistence provider access to the ValidatorFactory in two ways:
 - it is provided by the application via the configuration Map of
    Persistence.createEntityManagerFaactory(Map). The property name is
    javax.persistence.validation.factory  (Persistence.VALIDATOR_FACTORY)
 - if not provided by the user, and if Bean Validation is present in the classpath, 
    the ValidatorFactory is instantiated using the default bootstrap
    approach ie Validation.buildDefaultValidatorFactory() which uses the configuration
     defined in META-INF/validation.xml


By default:
 - if a Bean Validation provider is present in the environment, the JPA provider
enables the Bean Validation integration features. 
 - if no BeanValidation provider is present in the environment, the JPA provider
disable the Bean Validation integration features.
This default behavior is known as the "auto" mode.

QUESTION: should auto encompass ddl the undefined ddl modification behaviors 
to prevent future backward compatibility headache?

When the mode "callback" is activated, the JPA provider
enables the callback based Bean Validation integration features or raises an exception if
no Bean Validation provider is present in the environment.

QUESTION: callback or event?

When the mode "none" is activated, the JPA provider
does not enable  the Bean Validation integration features.

The validation  mode which defaults to "auto" can be defined via a property
javax.persistence.validation.mode  (Persistence.VALIDATION_MODE)

Such a flag can be defined via the configuration Map at EMF creation time
or in META-INF/persistence.xml

//add constants
public Persistence {
    /** property key receiving a ValidatorFactory instance as value */
    public static final String VALIDATOR_FACTORY = "javax.persistence.validation.factory"

    /** property key receiving the validation mode as a String*/
    public static final String VALIDATOR_FACTORY = "javax.persistence.validation.mode"

   [...]
}
</programlisting>

    <programlisting>********* OLD do not read **************
Java Persistence / Bean Validation integration proposal

Integration between Java Persistence and Bean Validation (BV) happens at two levels:
 - as a metadata provider for DDL generation and generally speaking the behavior of 
the persistence provider
 - as a validation engine called on entity changes

This proposal will describe both integration levels.

** Metadata provider and DDL generation
* main proposal

NOTE: this aspect of the proposal will be integrated to JPA after the runtime 
aspect if time permits.

Java Persistence consumes Bean Validation (BV) metadata to enhance persistence property 
metadata.

A Persistence provider must use the BV metadata of a given list of groups. 
The default group evaluated is Default (default BV group). Groups evaluated 
can be overridden by a JPA property javax.persistence.validation.group.metadata. 
This contains the comma separated groups (fully qualified class name).

For each entity, apply the following algorithm. 
For each persistent property in a given entity: 
 - extract the list of BV constraints (including the composing constraints) 
 - determine the subset of applicable constraints 
    (ie constraints understood by the persistence provider)
 - apply these constraints on the persistent property metadata 
 - if the property type is an embeddable object or a collection 
of embeddable objects, apply the algorithm on the embeddable object properties

The list of constraints that must be understood by persistence providers are
as followed:
 - @NotNull should be considered equivalent to @Column(nullable=false) / 
     @JoinColumn(nullable=false)
 - @Size.max should be considered equivalent to @Column.length 
     for String properties 
 - @Digits (which contains integer and fraction) should be considered 
     equivalent to @Column.precision = integer+fraction, 
     @Column.scale = fraction for decimal columns

The BV annotation metadata should have priority over JPA metadata 
(JPA has no sensible "unset" values on their annotations).

Question: should we add @Unique that would map to @Column(unique=true)? 
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part 
of the BV spec today.

Persistence Provider should optionally recognize and try to apply the 
following constraints as well:
 - @Min / @Max on numeric columns (TODO String too?)
 - @Future / @Past on temporal columns
 - @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model. 
For example, provider ACME might recognize and understand @com.acme.validation.Email 
and apply it to the database model.

While most high level constraints will not be recognize, the BV built-in constraints 
will be the common language spoken by Persistence Providers. Any high level constraint 
can be composed of more modular constraints (constraint composition).

* additional proposition: consider JPA annotations as constraint definitions
Some people have asked for BV to recognize Java Persistence annotations as legit 
constraint definitions. Besides making BV more complex, I am not sure of the 
actual benefit of such an approach. I am even doubtful of the value as a legacy 
migration too. It also raises multiple problems including how to define proper 
error messages and groups. This proposal seems to be a good candidate for BV 
provider extension if a provider is interested.
  =&gt; proposal received no interest from the EG so far

* additional proposal
In case of a constraint violation report detected and generated by the database 
(not null, etc), the Java persistence provider catches this report and translates 
it into a BV error report. From the perspective of the application, constraint 
errors are viewed through a unified layer. BV must provide some API to create a 
constraint violation error (constraintDescriptor.createConstraintViolation(...)).

While this proposal has a lot of value-add, I wonder how difficult it can be to 
implement this in persistence providers.


** Using the Bean Validation (BV) engine inside a Java Persistence provider
NOTE: This part of the proposition has been worked most extensively by the exert group.

Java Persistence delegates the validation of entities to BV on the following entity events:
- pre persist (an entity must be valid to be inserted in the DB)
- pre update (an entity change must be valid before being propagated to the database)
- pre remove (eg. a Customer still owning some Payments cannot be removed)
- question has been asked about post load. What would be the value add?

These events are called at the same time as their respective callback methods but
after all user registered callbacks have been called.

For each event type, a list of groups is targeted for validation. By default, 
pre persist and pre update events vaildate the group Default (default BV group) 
and pre remove does not validate any group. Each list can be overridden 
by a JPA property:
- javax.persistence.validation.group.pre-persist for pre persist events
- javax.persistence.validation.group.pre-update for pre update events
- javax.persistence.validation.group.pre-remove for pre remove events

Each property holds the list of targeted groups (fully qualified class name) 
separated by a comma.

When any of the pre-cited event is raised on an entity instance 'a' of type A, 
the persistence provider must validate 'a' by invoking a validator with the 
targeted groups. If the list of targeted groups is empty, 
no validation is performed. If the set of constraint violation is not empty, 
a ValidationException containing a reference to this set of violations is raised.

Question: should we raise the exception at the first invalid object and stop 
(easy way)? Or should all objects in the persistence context expected 
to raise a pre-* event be passed to the pre-* events and their constraint 
violations merged into a single ValidationException
 =&gt; as defined today, the first invalid object will stop and raise an exception

Question: should ValidationException be defined in JPA or BV?
 =&gt; BV seems a more natural place

** Lazy loaded state boundaries

Validator instances used to validate entities on pre-* events must use a TraversableResolver 
implementing the following logic:
 - Lazy properties or associations must not be traversed
 - Single or multi valued associations pointing to entities must not be traversed

A work is in progress to define a static method provider-agnostic to determine the 
fetching state of a property
eg. boolean Persistence.isLoaded(Object objectHostingTheProperty, String property)

This TraversableResolver implementation is provided and injected by the persistence
provider. This implementation is not exposed.

The TraversableResolver instance is passed to Bean Validation through
ValidatorFactory.usingContext().traversableResolver(jpaSpecificTR).getValidator();
The Validator instance retrieved is used by the persistence provider to validate the 
entities on pre-* events.

The TraversableRsolver rules guarantee that:
 - no lazy property nor association will be loaded by side effect
 - no entity will be validated more than once even if it is reachable through @Valid several 
times due to multiple entities changing state. 
A consequence is that JPA cascading and BV cascading are orthogonal for entity associations.

QUESTION: should embeddable objects be validated even if not marked as @Valid? 
 =&gt; Inclined to say no.


Outside JPA, and if BV validates object graphs loaded by JPA,
BV needs to determine the lazy loaded state boundaries.
BV needs to know whether or not an entity / property is loaded or lazy. 
Java Persistence should expose a way to determine this.
Because BV must work on detached objects and on objects made of potentially 
multiple EMF, this contract should be persistence provider agnostic.

Persistence.isLoaded(Object objectHostingTheProperty, String property) currently
discussed should fulfill such contract.

When the container (say EE) knows that only a single (ie the default) persistence 
provider is available in the classpath, it can implement a potentially optimized 
TraversableResolver that does not rely on 
Persistence.isLoaded(Object objectHostingTheProperty, String property). This decision
is left to the EE implementor.


** Interactions between Persistence and Validation Providers

BV metadata APIs and runtime are available via Validator instances provided by
a ValidatorFactory. BV recommends to cache ValidatorFactory instances while 
retrieving Validators on demand.
Because the ValidatorFactory provides metadata informations to the JPA provider, 
it will be built at or before an EntityManagerFactory initialization.

Providing the ValidatorFactory
-- in EE
A ValidatorFactory is made available at the platform level by the Java EE container. This
ValidationFactory instance is passed to the persistence provider via the PersistenceUnitInfo.
(this point is still under discussion in the expert group) 

-- in SE
Out of container, the Persistence provider accesses the ValidatorFactory in two ways:
 - it is provided by the application via the configuration Map of 
     Persistence.createEntityManagerFactory(Map). The property name is 
     javax.persistence.validation_factory (constant in Persistence?)
 - if not provided by the user, the VF is instantiated using the default bootstrap
     approach. ie Validation.getBuilder().build() which uses the configuration
     defined in META-INF/validation.xml

Note that in the SE case, if the application uses Validation directly, it should
implement a TraversableResolver that does not cross lazy state boundaries
(the implementation is trivial if we have Persistence.isLoaded).

The BV / JPA integration features are enabled by default (provided a Bean Validation 
provider is available in the classpath). It is possible to disable them using
javax.persistence.validation.mode metadata|event|all (should metadata be renamed DDL?)
Such a flag can be defined in META-INF/persistence.xml (JPA level).
  =&gt; the default value (ie activated by default or not) is under discussion by the EG</programlisting>
  </appendix>

  <appendix id="appendix-jsf">
    <title>Proposal for Java Server Faces 2.0 integration</title>

    <para>This proposal has been built with the help of the Java Server Faces
    2.0 expert group for evaluation. This proposal does not bind the Java
    Server faces 2.0 expert group and is here to give a global picture of how
    Bean Validation can be brought to the EE ecosystem.</para>

    <programlisting>Motivation
--------------

To provide bean based validation support in the view layer. This
supports the DRY principle.  The community has trialed this approach
for a couple of years with Hibernate Validator and Seam or MyFaces
extval. As Bean Validation, JSR 303, will be standardized for EE6, we
propose to introduce changes to better support for delegating validation
to an external validation framework and explicit support for Bean
Validation to JSF2.

Proposal
------------
A) GENERAL CHANGES

1) Add a context-param, javax.faces.VALIDATE_EMPTY_FIELDS, by default auto. 
If true, all submitted fields will be validated. This is necessary to delegate 
validation of whether a field can be null/empty to the model validator.
If false, empty values will not be passed to the validators.
If auto, the default will be true only if Bean Validation
is in the environment, false otherwise (keeps backward compatibility)

BACKWARDS COMPATIBILITY NOTE:

JSF 2 validators must not fail on non-null empty values; for a JSF 1.2
validator to work with JSF2 and VALIDATE_EMPTY_FIELDS, it must be be
safe to use with non-null, empty values. If a non-safe validator is
used, validate-empty-fields should be set to false.

2) Add these elements:

&lt;application&gt;
&lt;default-validators&gt;
&lt;validator-id /&gt;

and

public abstract void addDefaultValidatorId(String validatorId);
public abstract Iterator&lt;String&gt; getDefaultValidatorIds();

to javax.faces.application.Application.

The JSF implementation should add the validator to all
EditableValueHolders after any locally defined validators.

If Bean Validation is present in the environment, and if no default 
validator is explicitly specified (either via face-confg.xml or via 
programmatic API), the validator with id javax.faces.Bean is 
considered the default validator.
NOTE: if an application or a container override the default validator 
list (face-config.xml or programmatic API) and wish to keep integration 
with Bean Validation, it must manually add javax.faces.Bean to the list.

B) SPECIFIC SUPPORT FOR JSR-303

3) Add javax.faces.validator.BeanValidator with id
javax.faces.Bean. The property validationGroups on BeanValidator is
used to allow the view designer to specify a comma separated list of
groups which should be validated. A group is represented by the fully
qualified class name of its interface. If the validationGroups attribute is
omitted, the Default (javax.validation.groups.Default) group will be used. 
If the model validator is set as the default validator, this tag can be 
used to specify validation groups for this input.

The BeanValidator requires a version of EL which supports
ValueExpression.getReference(elContext).getProperty(). The validate() method should inspect 
the parent EditableValueHolder and discover the ValueExpression specified 
for the "value" attribute, and from it the EL expression's resolved 
base and property using:

ValueReference ref = valueExpression.getReference(elContext);
String property = ref.getProperty();
Object base = ref.getBase();

The BeanValidator acquires 
javax.validator.ValidatorFactory as defined in 5;
it may keep an application scoped cache of it.
The Validator instance should be acquired as defined in 4) and
Validator.validateValue(property, value,
validationGroups); called to find any validation errors.

Bean Validation returns multiple validation constraint failures from a
single validator, whilst JSF is limited to returning a single validation
failure; lifting this constrain is outside the scope of JSF2, but may be
addressed in the future.  The model validator may take any constraint
failure and use it to throw a ValidatorException. The FacesMessage
created for the ValidatorException should have SEVERITY_ERROR, a message
summary taken from the validation error message taken from the Bean
Validation validation error and the detail message should be null.

4) To ensure proper localization of the messages, JSF should provide a
custom BV MessageInterpolator resolving the Locale according to JSF defaults
and delegating to the default MessageInterpolator as defined in 
ValidationFactory.getMessageInterpolator()

A possible implementation is described as followed

public class class JsfMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator delegate;

    public JsfMessageInterpolator(MessageInterpolator delegate) { 
        this.delegate = delegate; 
    }

    public String interpolate(String message, ConstraintDescriptor constraintDescriptor, 
                              Object value) {
        Locale locale = FacesContext.getCurrentInstance().getViewRoot().getLocale();
        return this.delegate.interpolate(
                        message, constraintDescriptor, value, locale );
    }

    public String interpolate(String message, ConstraintDescriptor constraintDescriptor, 
                              Object value, Locale locale) {
        return this.delegate.interpolate(message, constraintDescriptor, value, locale);
    }
}

Assuming a ValidatorFactory, JSF receives a Validator instance by providing the custom message
interpolator to the validator state.

//could be cached
MessageInterpolator jsfMessageInterpolator = new JsfMessageInterpolator( 
                  validatorFactory.getMessageInterpolator() );

//...

Validator validator = validatorFactory
          .usingContext()
          .messageInterpolator(jsfMessageInterpolator)
          .getValidator();

5) ValidatorFactory are retrieved using the following algorithm:
 - if the servlet context contains a ValidatorFactory instance under the attribute named 
javax.faces.validator.beanValidator.ValidatorFactory, this instance is used by
JSF to acquire Validator instances
 - if the servlet context does not contain such entry, JSF looks for a Bean Validation
provider in the classpath. If present, the standard Bean Validation bootstrap strategy 
is used. If not present, Bean Validation integration is disabled.

The standard Bean Validation bootstrap procedure is shown here
ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

If the BeanValidator is used and no ValidatorFactory can be retrieved,
an exception is raised.

VALIDATOR_FACTORY_KEY is a static final String hosted on BeanValidator whose value 
is javax.faces.validator.beanValidator.ValidatorFactory


6) Add a &lt;f:validateBean /&gt; tag. When nested in an EditableValueHolder
this should add the BeanValidator

7) JSR-303 allows the user to validate a graph of objects, JSF will not
support graph validation.

8) An subtree of components, for example a form, can be validated by
directly nesting a &lt;f:validateBean /&gt; element. Validating an entire
form is especially useful if you are not using the BeanValidator as the
default validator, or you want to set a validationGroup for the entire
form. The &lt;f:validateBean /&gt; should not render a UIComponent. Any
validationGroups specified at this level should be used when validating
each component in the subtree. Any validationGroups defined on
&lt;f:validateBean /&gt; nested in an EditableValueHolder take precedence
over the validationGroups defined for the subtree.

9) If JSF is running in EE then bean validation will be present in the
environment and activated in JSF (see rules 1) and 2) ).
The EE container will also make ValidatorFactory available as an 
attribute in the ServletContext at
"javax.faces.validator.beanValidator.ValidatorFactory"

10) It is possible to disable the default validator for a field/a subtree
by using the disabled attribute: &lt;h:inputText ...&gt; &lt;f:validateBean
disabled="true" /&gt; &lt;/h:inputText&gt; This is useful when you are using the
ModelValidator as the default validator, or validating an entire form

C) AJAX VALIDATION

11) JSF2's Ajax support transparently supports Ajax validation for any JSF
validator, including the BeanValidator. For example you could enable
ajax validation for the onBlur event of an input field:

&lt;h:inputText value="#{item.name}"&gt;
&lt;f:ajaxRequest execute="none" render="none" /&gt;
&lt;/h:inputText&gt;</programlisting>
  </appendix>

  <appendix id="appendix-ee">
    <title>Proposal for Java EE integration</title>

    <para>This proposal has not been discussed with the EE expert group but
    proposes a way to smoothly integrates Bean Validation to the platform.
    This proposition is the result of the work done on JSF and JPA
    integrations.</para>

    <para>Java Persistence and Java Server Faces have deep integration
    proposals with Bean Validation. Java Connector Architecture is a potential
    client. <classname>Validator</classname> and
    <classname>ValidatorFactory</classname> are very good candidates for
    injectable Java EE resources (<classname>ValidatorFactory</classname> is
    responsible for providing <classname>Validator</classname> instances which
    execute the validation logic). To tight everything together in a unified
    way for the Java EE application developer, some integration at the Java EE
    level would be beneficial.</para>

    <para>A <classname>ValidatorFactory</classname> is built by the EE
    container and exposed to applications as well as services like JPA, JSF
    and JCA(?) (this imply a <classname>ValidatorFactory</classname> must be
    built and ready before these services). While not required, it is
    recommended to cache and share the same
    <classname>ValidatorFactory</classname> for a given deployment unit.
    <emphasis>Should we mandate it?</emphasis>.</para>

    <para>The container passes the <classname>ValidatorFactory</classname>
    instance to the JPA provider via the configuration Map of
    <code>PersistenceProvider.createContainerEntityManagerFactory(PersistenceUnitInfo,
    Map)</code>. The property name is
    <literal>javax.persistence.validation.factory</literal>
    (<literal>Persistence.VALIDATOR_FACTORY</literal>).</para>

    <para>The container places the <classname>ValidatorFactory</classname>
    instance into the <classname>ServletContext</classname> in the following
    attribute name entry
    <literal>javax.faces.validator.beanValidator.ValidatorFactory</literal>.
    JSF 2 implementations are required to look in this entry for any
    <classname>ValidatorFactory</classname> and use it.</para>

    <para>In addition, <classname>Validator</classname> and
    <classname>ValidatorFactory</classname> should be considered as Java EE
    resources: injection aware services should allow injection of
    <classname>Validator</classname> instances as well as
    <classname>ValidatorFactory</classname> instances.
    <classname>@Resource</classname> is used for this. If
    <classname>Validator</classname> instances are injected, the default
    validation context is used. In other words,
    <classname>Validator</classname> are provided by
    <code>validatorFactory.getValidator()</code>. The factory is available for
    the lifetime of the deployment.</para>
  </appendix>
</book>