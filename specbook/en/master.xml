<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <title>JSR 303: Bean Validation</title>

  <bookinfo>
    <title>JSR 303: Bean Validation</title>

    <releaseinfo>1.0.Betax</releaseinfo>

    <pubdate>2008-11-04</pubdate>

    <copyright>
      <year>2007, 2008</year>

      <holder>Red Hat Middleware, LLC and Steve Peterson</holder>
    </copyright>

    <authorgroup>
      <corpauthor>Bean Validation Expert Group</corpauthor>

      <author>
        <firstname>Emmanuel</firstname>

        <surname>Bernard</surname>

        <affiliation>
          <orgname>Red Hat Middleware, LLC</orgname>
        </affiliation>
      </author>

      <author>
        <firstname>Steve</firstname>

        <surname>Peterson</surname>
      </author>
    </authorgroup>
  </bookinfo>

  <preface>
    <title>Disclaimer</title>

    <para>This specification is a work in progress. The content of this
    specification is highly subject to change. Specific areas currently at
    work include:</para>

    <itemizedlist>
      <listitem>
        <para>Message resolution and localization</para>
      </listitem>

      <listitem>
        <para>XML deployment descriptor</para>
      </listitem>

      <listitem>
        <para>Extension for method parameters validation</para>
      </listitem>

      <listitem>
        <para>Exception cases</para>
      </listitem>
    </itemizedlist>

    <para>The JSR 303 expert group is seeking for feedbacks from the community
    on this specification and will update it accordingly. Direct feedbacks to
    <ulink
    url="http://forum.hibernate.org/viewforum.php?f=26">http://forum.hibernate.org/viewforum.php?f=26</ulink>.</para>
  </preface>

  <chapter>
    <title>Introduction</title>

    <para>This document is the specification of the Java API for JavaBean
    validation in Java EE and Java SE. The technical objective of this work is
    to provide a class level constraint declaration and validation facility
    for the Java application developer, as well as a constraint metadata
    repository and query API.</para>

    <section>
      <title>Expert group</title>

      <para>This work is being conducted as part of JSR-303 under the Java
      Community Process Program. This specification is the result of the
      collaborative work of the members of the JSR 303 Expert Group. These
      include the following present and former expert group members:</para>

      <itemizedlist>
        <listitem>
          <para>Geert Bevin</para>
        </listitem>

        <listitem>
          <para>Emmanuel Bernard (Red Hat Middleware LLC)</para>
        </listitem>

        <listitem>
          <para>Uri Boness</para>
        </listitem>

        <listitem>
          <para>Erik Brakkee (Ericsson AB)</para>
        </listitem>

        <listitem>
          <para>Ed Burns (Sun Microsystems, Inc.)</para>
        </listitem>

        <listitem>
          <para>Jason Carreira</para>
        </listitem>

        <listitem>
          <para>Robert Clevenger (Oracle - retired)</para>
        </listitem>

        <listitem>
          <para>Linda DeMichiel (Sun Microsystems, Inc.)</para>
        </listitem>

        <listitem>
          <para>Tim Fennel</para>
        </listitem>

        <listitem>
          <para>Bharath Ganesh (Pramati Technologies)</para>
        </listitem>

        <listitem>
          <para>Romain Guy (Google Inc.)</para>
        </listitem>

        <listitem>
          <para>Robert Harrop</para>
        </listitem>

        <listitem>
          <para>Jacob J. Hookom</para>
        </listitem>

        <listitem>
          <para>Bob Lee (Google Inc.)</para>
        </listitem>

        <listitem>
          <para>Craig R. McClanahan (Sun Microsystems, Inc.)</para>
        </listitem>

        <listitem>
          <para>Niall K. Pemberton</para>
        </listitem>

        <listitem>
          <para>Steve Peterson</para>
        </listitem>

        <listitem>
          <para>Dhanji R. Prasanna</para>
        </listitem>

        <listitem>
          <para>Gerhard Petracek</para>
        </listitem>

        <listitem>
          <para>Matt Raible</para>
        </listitem>

        <listitem>
          <para>Michael Nascimento Santos</para>
        </listitem>

        <listitem>
          <para>Sebastian Thomschke</para>
        </listitem>

        <listitem>
          <para>Jon Wetherbee (Oracle)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Specification goals</title>

      <para>Validating data is a common task that occurs throughout an
      application, from the presentation layer to the persistence layer. Often
      the same validation logic is implemented in each layer, proving time
      consuming and error-prone. To avoid duplication of these validations in
      each layer, developers often bundle validation logic directly into the
      domain model, cluttering domain classes with validation code that is, in
      fact, metadata about the class itself.</para>

      <para>This JSR defines a metadata model and API for JavaBean validation.
      The default metadata source is annotations, with the ability to override
      and extend the meta-data through the use of XML validation
      descriptors.</para>

      <para>The validation API developed by this JSR is not intended for use
      in any one tier or programming model. It is specifically not tied to
      either the web tier or the persistence tier, and is available for both
      server-side application programming, as well as rich client Swing
      application developers. This API is seen as a general extension to the
      JavaBeans object model, and as such is expected to be used as a core
      component in other specifications. Ease of use and flexibility are
      influencing the design of this specification.</para>
    </section>

    <section>
      <title>How this document is organized</title>

      <para>This document describes each aspect of the bean validation
      specification in a separate chapter. One should remember that the
      specification is a consistent whole.</para>

      <para><xref linkend="constraintsdefinitionimplementation" /> describes
      how constraints are defined.</para>

      <para><xref linkend="constraintdeclarationvalidationprocess" />
      describes how a JavaBean class is decorated with annotations to describe
      constraints on the contents of an instance of the class.</para>

      <para><xref linkend="validationapi" /> describes how to programmatically
      validate a JavaBean.</para>

      <para><xref linkend="constraintmetadata" /> describes how the metadata
      query API works.</para>

      <para>A <xref linkend="terminology" /> section summarize key concepts.
      Some reviewers have found that reading the terminology section first
      helps to better understand the specification.</para>
    </section>

    <section>
      <title>How to comment</title>

      <para>The expert group is eager to receive feedbacks from readers. Feel
      free to email us at jsr-303-comments@jcp.org.</para>
    </section>
  </chapter>

  <chapter id="constraintsdefinitionimplementation">
    <title>Constraint Definition</title>

    <!--[SCP: "declaration" is creating a new kind of constraint; "definition" is applying a constraint to a class, method, or field.]
EBE I started a thread on the ML => I don't think I like the move.-->

    <!--[SCP: consider moving this chapter after the next one] // EBE:I tried earlier but this order make more sense-->

    <para>Constraints are defined through a combination of a constraint
    annotation and a constraint validation implementation. The constraint
    annotation is applied to a type, method, or field target.</para>

    <para>Unless stated otherwise the default package name for the Bean
    Validation APIs is <classname>javax.validation</classname>.</para>

    <section id="constraintsdefinitionimplementation-constraintdefinition">
      <title>Constraint annotation</title>

      <para>A constraint on a JavaBean is expressed through one or more
      annotations. An annotation is considered a constraint definition if its
      retention policy contains <literal>RUNTIME</literal> and if the
      annotation itself is annotated with
      <literal>javax.validation.ConstraintValidator</literal>.</para>

      <programlisting>/**
 * Link between a constraint annotation and its constraint validation implementation
 *
 * A given constraint annotation should be annotated by a @ConstraintValidator
 * annotation to refer to its constraint validation implementation
 *<!--TODO SCP:  Do we want to just call this Validator? 
EBE thread started on the ML but validator is the name of the main API, maybe ConstraintValidator-->
 */
@Documented
@Target({ANNOTATION_TYPE})
@Retention(RUNTIME)
public @interface ConstraintValidator {
    /**
     * Constraint validation implementation
     */
    Class&lt;? extends Constraint&gt; value();
}</programlisting>

      <para>Constraint annotations can target any of the following
      <classname>ElementType</classname>s:</para>

      <itemizedlist>
        <listitem>
          <para><literal>FIELD</literal> for constrained attributes</para>
        </listitem>

        <listitem>
          <para><literal>METHOD</literal> for constrained getters</para>
        </listitem>

        <listitem>
          <para><literal>TYPE</literal> for constrained beans</para>
        </listitem>

        <listitem>
          <para><literal>ANNOTATION_TYPE</literal> for constraints composing
          other constraints</para>
        </listitem>
      </itemizedlist>

      <para>While other <classname>ElementType</classname>s are not forbidden,
      the provider does not have to recognize and process constraints placed
      on such types.</para>

      <para>Since a given constraint definition applies to one or more
      specific Java types, the JavaDoc for the constraint annotation should
      clearly state which types are supported. Applying a constraint
      annotation to an incompatible type is a runtime error.</para>

      <section>
        <title>Constraint definition properties</title>

        <para>A constraint definition may have properties that can be
        specified at the time the constraint is applied to a JavaBean. The
        properties are mapped as annotation elements. The annotation element
        names <literal>message</literal> and <literal>groups</literal> are
        considered reserved names; a constraint may use any other element name
        for its parameters.<!--[SCP: reserve a prefix for future use?] EBE: I think I have a smarter approach check the "Constraint definition elements" email from 2007/11/26--></para>

        <section id="constraintsdefinitionimplementation-constraintdefinition-parameters-message">
          <title>message</title>

          <para>Every constraint annotation must define a
          <literal>message</literal> element of type
          <literal>String</literal>.</para>

          <programlisting>String message() default "{constraint.myConstraintFailure}";</programlisting>

          <para>The <methodname>message</methodname> element value is used to
          create the error message. See <xref
          linkend="validationapi-message" /> for a detailed
          explanation.</para>
        </section>

        <section id="constraintsdefinitionimplementation-constraintdefinition-groups">
          <title>groups</title>

          <para><literal>groups</literal> is a required element that specifies
          which processing groups the constraint definition is associated
          with.</para>

          <programlisting>    String[] groups() default {};</programlisting>

          <para>The default value must be an empty array.</para>

          <para>When using the constraint declaration, if no group is
          specified, the <literal>default</literal> group is considered
          declared. The validation will be evaluated if</para>

          <itemizedlist>
            <listitem>
              <para>no group was specified at validation time (which defaults
              to the <literal>default</literal> group) and the annotation is a
              member of the <literal>default</literal> group</para>
            </listitem>

            <listitem>
              <para>or if one of the groups specified at validation time
              matches one of the groups specified on the constraint annotation
              declaration</para>
            </listitem>
          </itemizedlist>

          <para>See <xref linkend="validationapi-validatorapi-groups" /> for
          more information. It is required that all constraint definitions
          support this element.</para>

          <para>Groups are typically used to control the order of validator
          evaluation, or perform partial validation of a JavaBean.</para>
        </section>

        <section>
          <title>Constraint specific parameter</title>

          <para>The constraint annotation definitions may define additional
          elements needed to parameterize the constraint definition. For
          example, a constraint that validates the length of a string can use
          an annotation element named <literal>length</literal> to specify the
          maximum length at the time the constraint is declared.</para>
        </section>
      </section>

      <section>
        <title>Examples</title>

        <example>
          <title>NotNull constraint definition</title>

          <programlisting>@Documented
@ConstraintValidator(NotNullConstraint.class)
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface NotNull {
    String message() default "{constraint.notNull}";
    String[] groups() default {};
}</programlisting>
        </example>

        <para>Defines a not null constraint with a specific default message.
        The constraint validator is implemented by
        <classname>NotNullConstraint</classname>.</para>

        <example>
          <title>Length constraint definition</title>

          <programlisting>@Documented
@ConstraintValidator(LengthConstraint.class)
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Length {
    int min() default 0;
    int max() default Integer.MAX_VALUE;
    String message() default "{constraint.length}";
    String[] groups() default {};
}</programlisting>
        </example>

        <para>Defines a length constraint. The constraint definition includes
        two optional properties that may be specified when the constraint is
        applied.</para>

        <example>
          <title>Min constraint definition</title>

          <programlisting>@Documented
@ConstraintValidator(MinConstraint.class)
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Min {
    int value();
    String message() default "{constraint.min}";
    String[] groups() default {};
}</programlisting>
        </example>

        <para>Defines a min constraint with a constraint property that must be
        specified when the constraint is applied.</para>
      </section>
    </section>

    <section id="constraintsdefinitionimplementation-multipleconstraints">
      <title>Applying multiple constraints of the same type</title>

      <para>It is often useful to apply the same constraint more than once to
      the same target, with different properties. A common example is the
      <literal>@Pattern</literal> constraint, which validates that its target
      matches a specified regular expression.</para>

      <para>To support this, the bean validation provider treats non
      constraint annotations (an annotation not annotated by
      <classname>@ConstraintValidator</classname>) with a
      <literal>value</literal> element having a return type of an array of
      constraint annotations as a list of annotations that are processed by
      the Bean Validation implementation. This means that each constraint
      specified in the value element is applied to the target. The annotation
      must have retention <literal>RUNTIME</literal> and can be applied on a
      type, field or property.</para>

      <para>Each constraint annotation should be coupled with its
      corresponding multi-valued annotation.</para>

      <programlisting>@Documented
@ConstraintValidator(PatternValidator.class)
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Pattern {
    /** regular expression */
    String regex();

    /** Flags parameter for Pattern.compile() */
    int flags() default 0;

    String message() default "{constraint.pattern}";
    String[] groups() default {};
}

@Documented
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Patterns {
    Pattern[] value();<!--SCP:  will we ever need to distinguish this type of annotation from other arrays of constraints?
EBE anything specific in mind?--><!--SCP:  what order are these evaluated in? 
EBE: this is not specified, I don't think there is a need for-->}</programlisting>

      <example>
        <title>Multi-valued constraint</title>

        <programlisting>public class Engine {
    @Patterns( {
            @Pattern(regex = "^[A-Z0-9-]+$", 
                message = "must contain alphabetical characters only"),
            @Pattern(regex = "^....-....-....$", message="must match ....-....-....")
            } )
    private String serialNumber;
}</programlisting>
      </example>

      <para>In this example, both constraints (<literal>^[A-Z0-9-]+$</literal>
      and <literal>^....-....-....$</literal>) will be applied on the
      <literal>serialNumber</literal> field.</para>
    </section>

    <section id="constraintsdefinitionimplementation-constraintcomposition">
      <title>Constraint composition</title>

      <para>The specification allows to compose constraints from other
      constraints.</para>

      <para>Constraint composition is useful in several ways:</para>

      <itemizedlist>
        <listitem>
          <para>Avoid duplication and facilitate reuse of more primitive
          constraints.</para>
        </listitem>

        <listitem>
          <para>Expose primitive constraints as part of a composed constraint
          in the metadata API.</para>
        </listitem>
      </itemizedlist>

      <para>Composition is done by annotating the constraint annotation with
      constraint annotations.</para>

      <example>
        <title>Composition consists of annotating the composed</title>

        <programlisting>@NotNull
@Size(min=5, max=5)
@ConstraintValidator(FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    String[] groups() default {};
}</programlisting>
      </example>

      <para>Annotating an element with <classname>@FrenchZipcode</classname>
      is equivalent to annotate it with <classname>@NotNull</classname>,
      <classname>@Size(min=5, max=5)</classname> and
      <classname>@FrenchZipcode</classname>. More formally, each constraint
      annotation hosted on a constraint annotation is applied to the target
      element and this recursively. Note that the main annotation and its
      constraint validation implementation is also applied. By default, each
      failing constraint generates an error report. Groups from the main
      constraint annotation are inherited by the composing annotations. Any
      <methodname>groups</methodname> definition on a composing annotation is
      ignored.</para>

      <para>It is possible to ensure that composing annotations do not raise
      individual error reports. In this scenario, if one or more composing
      annotations are invalid, the main annotation is automatically considered
      invalid and the corresponding error report is generated. To mark a
      constraint as raising only the main constraint error report despite its
      use of composing constraints, use the
      <classname>@ReportAsViolationFromCompositeConstraint</classname>
      annotation.</para>

      <example>
        <title>If any of the composing constraint fails, the error report
        corresponding to @FrenchZipcode is raised and none other.</title>

        <programlisting>@NotNull
@Size(min=5, max=5)
@ReportAsViolationFromCompositeConstraint
@ConstraintValidator(FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    String[] groups() default {};
}</programlisting>
      </example>

      <example>
        <title>@ReportAsViolationFromCompositeConstraint annotation
        definition</title>

        <programlisting>/**
 * A constraint annotation annotated with this annotation
 * will return the composed annotation error report if any of the composing annotations
 * fail. The error reports of each individual composing constraint is ignored.
 * 
 * @author Emmanuel Bernard
 */
public @interface ReportAsViolationFromCompositeConstraint {
}</programlisting>
      </example>

      <para>Composing annotations can define parameters and message (aside
      from <methodname>groups</methodname>) but these are fixed for a given
      main annotation.</para>

      <example>
        <title>Composing annotations can use parameters. They are fixed for a
        given main annotation. All @FrenchZipcode constraints have a @Size
        restricted to 5.</title>

        <programlisting>@NotNull
@Size(min=5, max=5)
@ConstraintValidator(FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    String[] groups() default {};
}</programlisting>
      </example>

      <para>It is possible to override parameters and messages defined on a
      composing annotation. A parameter from the main annotation is used to
      override one or more parameters from the composing annotations. Such a
      parameter is annotated with the
      <classname>@OverridesParameter</classname> annotation or its multivalued
      equivalent <classname>@OverridesParameters</classname>.</para>

      <example id="example-composing-overridden">
        <title>Parameters from composing annotations can be overridden by
        parameters from the main annotation.</title>

        <programlisting>@NotNull
@Size    //arbitrary settings
@ConstraintValidator(FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    String[] groups() default {};

    @OverridesParameters( {
        @OverridesParameter(constraint=Size.class, parameter="min"),
        @OverridesParameter(constraint=Size.class, parameter="max") } )
    int size() default 5;

    @OverridesParameter(constraint=Size.class, parameter="message")
    String sizeMessage() default "{beancheck.zipcode.size}";
}</programlisting>
      </example>

      <para>The parameter value from the main application annotated with
      <classname>@OverridesParameter</classname> is applied to the composing
      constraint of type
      <methodname>OverridesParameter.constraint</methodname> on its parameter
      named after <methodname>OverridesParameter.parameter</methodname>. If
      not specified, the name of the targeted parameter equals the name of the
      parameter the <classname>@OverridesParameter</classname> is on The types
      of the overridden and overriding parameters must be equals.</para>

      <para>Using <xref linkend="example-composing-overridden" />,</para>

      <programlisting>@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</programlisting>

      <para>is equivalent to</para>

      <programlisting>@FrenchZipcode</programlisting>

      <para>using the following definition</para>

      <programlisting>@NotNull
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@ConstraintValidator(FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    String[] groups() default {};
}</programlisting>

      <para>If a constraint type is used more than once as a composing
      constraint, the construct described at <xref
      linkend="constraintsdefinitionimplementation-multipleconstraints" /> is
      used. To select the appropriate composing constraint targeted,
      <methodname>OverridesParameter.index</methodname> is used. It represents
      the constraint index of the <methodname>value</methodname> array. If
      index is undefined, the single constraint declaration is
      targeted.</para>

      <example>
        <title>@OverridesParameter annotation definition</title>

        <programlisting>/**
 * Mark a parameter as overriding the parameter of a composing constraint.
 * Both parameter must share the same type.
 *
 * @author Emmanuel Bernard
 */
public @interface OverridesParameter {
    /**
     * constraint type the parameter is overriding
     */
    Class&lt;? extends Annotation&gt; constraint();

    /**
     * name of constraint parameter overridden
     * Defaults to the name of the parameter hosting the annotation  
     */
    String parameter();

    /**
     * index of the targetted constraint declaration when using
     * multiple constraints of the same type.
     * The index represents the index of the constraint in the value() array.
     *
     * By default, no index is defined and the single constraint declaration
     * is targeted
     */
    int index() default -1;
}</programlisting>
      </example>

      <para>The following elements uniquely identify an overridden constraint
      parameter:</para>

      <itemizedlist>
        <listitem>
          <para><methodname>OverridesParameter.constraint</methodname></para>
        </listitem>

        <listitem>
          <para><methodname>OverridesParameter.parameter</methodname></para>
        </listitem>

        <listitem>
          <para><methodname>OverridesParameter.index</methodname></para>
        </listitem>
      </itemizedlist>

      <para>Constraint designers are encouraged to make use of composition
      (recursively or not) based on the built-in constraints defined by the
      specification. The composing constraints are exposed through the Bean
      Validation metadata API (<xref
      linkend="constraintmetadata-constraintdescriptor" />). This metadata is
      particularly useful for third-party metadata consumers like persistence
      frameworks generating database schemas (such as Java Persistence) or
      presentation frameworks.</para>
    </section>

    <section id="constraintsdefinitionimplementation-validationimplementation">
      <title>Constraint validation implementation</title>

      <para>A constraint validation implementation performs the validation of
      a target class, field, or method. It is specified by the value element
      of the <classname>ConstraintValidator</classname> annotation that
      decorates the constraint definition. The constraint validation
      implementation implements the <classname>Constraint</classname>
      interface.</para>

      <!--[SCP: consider naming this ConstraintValidator] EBE naming proposal circulating-->

      <example>
        <title>Constraint interface</title>

        <programlisting>/**
 * Define the logic to validate a given constraint.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface Constraint&lt;A extends Annotation&gt; {
    /**
     * Validator parameters for a given constraint definition
     * Annotations parameters are passed as key/value into parameters
     * &lt;p/&gt;
     * This method is guaranteed to be called before any of the other Constraint implementation methods
     *
     * @param constraintAnnotation parameters for a given constraint definition
     */
    void initialize(A constraintAnnotation);

    /**
     * Implement the validation constraint
     * &lt;code&gt;object&lt;/code&gt; state must not be changed by a Constraint implementation
     *
     * @param object object to validate
     * @param constraintContext context in which the constraint implementation is evaluated
     *
     * @return false if &lt;code&gt;object&lt;/code&gt; does not pass the constraint
     */
    boolean isValid(Object object, ConstraintContext constraintContext);
}</programlisting>
      </example>

      <para>The life cycle of a constraint validation implementation instance
      is undefined. Compliant implementations are allowed to cache
      <classname>Constraint</classname> instances retrieved from the
      <classname>ConstraintFactory</classname> or request them every time it
      is needed.</para>

      <warning>
        <para>Should we restrict further? Should a constraint impl be
        retrieved from the ConstraintFactory before each use? Providing the
        constraint via the Metadata API was driving the undefined lifecycle
        but we no longer return the implementation via
        ConstraintDescriptor.</para>
      </warning>

      <!--EBE should we make explicit that instances cannot be shared if the annotations attributes are not the same?-->

      <para><methodname>initialize</methodname> is called by the Bean
      validation provider prior to any use of the constraint
      implementation.</para>

      <para>The <methodname>isValid</methodname> method is evaluated by the
      Bean Validation provider each time a given value is validated. It
      returns <literal>false</literal> if the value is not valid,
      <literal>true</literal> otherwise. <literal>isValid</literal>
      implementations must be thread-safe.</para>

      <para>If the value parameter references an object with an unanticipated
      type, an <literal>IllegalArgumentException</literal> should be raised.
      The constraint validation implementation is not allowed to change the
      state of the value passed to <methodname>isValid</methodname>.</para>

      <note>
        <para>While not mandatory, it is considered a good practice to split
        the core constraint validation from the not null constraint validation
        (for example, an <classname>@Email</classname> constraint will return
        true on a null object, i.e. will not take care of the
        <classname>@NotNull</classname> validation)</para>

        <para><code>null</code> can have multiple meanings but is commonly
        used to express that a value does not make sense, is not available or
        is simply unknown. Those constraints on the value are orthogonal in
        most cases to other constraints. For example a String, if present,
        must be an email but can be null. Separating both concerns is a good
        practice.</para>

        <!--[SCP: I think this should be mandatory.] I don't think you can: for once, it would prevent from implementing @NotNull or @NotEmpty-->
      </note>

      <para>The <classname>ConstraintContext</classname> object passed to the
      <methodname>isValid</methodname> method carries information and
      operations available in the context the constraint is validated
      to.</para>

      <example>
        <title>ConstraintContext interface passed to
        Constraint.isValid()</title>

        <programlisting>/**
 * Provide contextual data and operation when applying a given constraint implementation
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintContext {
    /**
     * Disable default error message and default ConstraintViolation object generation.
     * Useful to set a different error message or generate an ConstraintViolation based on
     * a different property
     *
     * @see #addError(String)
     * @see #addError(String, String)
     */
    void disableDefaultError();

    /**
     * return the current unexpanded default message
     * TODO: is it needed
     */
    String getDefaultErrorMessage();

    /**
     * Add a new unexpanded error message.
     * &lt;p/&gt;
     * If isValid returns false, a ConstraintViolation object will be built per error message
     * including the default one unless #disableDefaultErrorMEssage() has been called.
     * &lt;p/&gt;
     * Aside from the error message, ConstraintViolation objects generated from such a call
     * contains the same contextual information (root bean, path and so on)
     * &lt;p/&gt;
     * This method can be called multiple time. One ConstraintViolation instance per
     * call is created.
     *
     * @param message new unexpanded error message
     */
    void addError(String message);

    /**
     * Add a new unexpanded error message to a given sub property.
     * &lt;p/&gt;
     * If isValid returns false, a ConstraintViolation object will be built
     * per error message including the default one
     * if null apply to the current property or the bean the constraint is applied on,
     * otherwise apply to the &lt;code&gt;property&lt;/code&gt; named
     * &lt;p/&gt;
     * TODO exception or swallowed when bean level instance is not present?
     *
     * @param message new unexpanded error message
     * @param property property name the ConstraintViolation is targeting
     *
     * @throws ValidationException when the property is not present on the bean level object
     */
    void addError(String message, String property);

}</programlisting>
      </example>

      <para>The <classname>ConstraintContext</classname> interface allows to
      redefine the default message error generated when a constraint is not
      valid. By default, every invalid constraint lead to the generation of an
      error object represented by a <classname>ConstraintViolation</classname>
      object. This object is build from the default error message as defined
      by the constraint declaration and the context the constraint declaration
      is placed on (bean, property, attribute).</para>

      <para>The <classname>ConstraintContext</classname> methods let the
      constraint implementation disable the default error object generation
      and create one or more custom ones. The unexpanded message passed as a
      parameter is used to build the
      <classname>ConstraintViolation</classname> object (the message
      resolution operation is applied to it). The property on which the error
      object is applied is defined as following:</para>

      <itemizedlist>
        <listitem>
          <para>if the property is not overridden, the current context the
          constraint is declared on is used (bean or property)</para>
        </listitem>

        <listitem>
          <para>if the property is overridden, the current context the
          constraint is declared on the property passed as a parameter
          relative to the bean the constraint declaration is on</para>
        </listitem>

        <listitem>
          <para>if the property is overridden and the constraint is declared
          on a property, TODO what should we do, exception or swallow?</para>
        </listitem>

        <listitem>
          <para>if the overridden property is not present on the bean, a
          <classname>ValidationException</classname> is raised.</para>
        </listitem>
      </itemizedlist>

      <para>The property can be overridden by calling
      <methodname>ConstraintContext.addError(String,
      String)</methodname>.</para>

      <section id="constraintsdefinitionimplementation-validationimplementation-example">
        <title>Example</title>

        <example>
          <title>Length constraint validator</title>

          <programlisting>/**
 * Check that a string length is between min and max
 *
 */
public class LengthConstraint implements Constraint&lt;Length&gt; {
    private int min;
    private int max;
<!--SCP: does this take a Map as its input to support XML descriptor, or do we map the XML descriptor into a Length instance?
EBE: The second option-->
    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Length constraint) {
        min = constraint.min();
        max = constraint.max();
<!--SCP: is best practice here to just keep a reference to the Length? Since there will be one LengthConstraint for each Length instance
EBE in real life, I expect some preprocessing anyway, so keeping the annotations as a data container probably does not make a lot of sense generally speaking
Note that generally speaking one "LengthConstraint for each Length instance" is not guaranteed. -->
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     * @exception IllegalArgumentException if the object is not of type String
     */
    public boolean isValid(Object value, ConstraintContext constraintContext) {
        if ( value == null ) return true;
        if ( !( value instanceof String ) ) {
            throw new IllegalArgumentException("Expected String type");
        }
        String string = (String) value;
        int length = string.length();
        return length &gt;= min &amp;&amp; length &lt;= max;
    }
}</programlisting>
        </example>

        <para>This constraint validator checks that the string's length is
        between min and max. It also demonstrates some best practices:</para>

        <itemizedlist>
          <listitem>
            <para>raises an <classname>IllegalArgumentException</classname> in
            case of type mismatch</para>
          </listitem>

          <listitem>
            <para>returns <literal>true</literal> on a null parameter</para>
          </listitem>
        </itemizedlist>

        <para>The next example shows how to use
        <classname>ConstraintContext</classname>.</para>

        <example>
          <title>Use of ConstraintContext</title>

          <programlisting>/**
 * Check that a string length is between min and max
 * Error messages are using either key:
 *  - constraint.length.min if the min limit is reached
 *  - constraint.length.max if the max limit is reached
 */
public class FineGrainedLengthConstraint implements Constraint&lt;Length&gt; {
    private int min;
    private int max;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Length constraint) {
        min = constraint.min();
        max = constraint.max();
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     * @exception IllegalArgumentException if the object is not of type String
     */
    public boolean isValid(Object value, ConstraintContext constraintContext) {
        if ( value == null ) return true;
        if ( !( value instanceof String ) ) {
            throw new IllegalArgumentException("Expected String type");
        }
        String string = (String) value;
        int length = string.length();

        //remove default error
        constraintContext.disableDefaultError();

        if (length &lt; min) {
            //add min specific error
            constraintContext.addError( "{constraint.length.min}" );
            return false;
        }
        if (length &gt; max) {
            //add max specific error
            constraintContext.addError( "{constraint.length.max}" );
            return false;
        }
        return true;
    }
}</programlisting>
        </example>

        <para>The default error message is disabled and replaced by a specific
        error message depending on the type of constraint violation detected.
        In this case, only one error report is returned at a given time but a
        constraint validation implementation can return several error
        reports.</para>
      </section>
    </section>

    <section id="constraintsdefinitionimplementation-constraintfactory">
      <title>The ConstraintFactory</title>

      <para>Constraint validation implementation instances are created by a
      <classname>ConstraintFactory</classname>.</para>

      <programlisting>/**
 * This class manages the creation of constraint validators.
 */
public interface ConstraintFactory {
    /**
     * Instantiate a Constraint.
     *
     * @return Returns a new Constraint instance
     * The ConstraintFactory is &lt;b&gt;not&lt;/b&gt; responsible for calling Constraint#initialize
     */
    &lt;T extends Constraint&gt; T getInstance(Class&lt;T&gt; constraintClass);
}</programlisting>

      <para>The default <classname>ConstraintFactory</classname> provided by
      the bean provider implementation uses the public constraint no-arg
      constructor. A custom constraint factory can be provided for example to
      benefit from a dependency injection control in constraint
      implementations. Any constraint implementation relying on
      <classname>ConstraintFactory</classname> behaviors specific to an
      implementation (dependency injection, no no-arg constructor and so on)
      are not considered portable, hence great care should be given before
      walking that path.</para>

      <!--[SCP: I think supporting dependency injection here violates the javadoc comment on Constraint.initialize() above]
EBE fixed this by rewordingthe JavaDoc-->
    </section>
  </chapter>

  <chapter id="constraintdeclarationvalidationprocess">
    <title>Constraint declaration and validation process</title>

    <para>The Bean Validation specification defines a framework for declaring
    constraints on JavaBean classes, fields and properties.</para>

    <para>Constraints are declared for classes, and evaluated against
    instances or graphs of instances.</para>

    <section id="constraintdeclarationvalidationprocess-requirements">
      <title>Requirements on classes to be validated</title>

      <para>Objects that are to be validated must fulfill the following
      requirements.</para>

      <para>Properties to be validated must follow the method signature
      conventions for JavaBeans read properties, as defined by the JavaBeans
      specification.</para>

      <para>Static fields and static methods are excluded from
      validation.</para>

      <para>Constraints can be applied to interfaces and superclasses.</para>

      <para>The target of an annotation definition can be a field, property,
      or type, provided that:</para>

      <itemizedlist>
        <listitem>
          <para>the constraint definition supports the specified target</para>
        </listitem>

        <listitem>
          <para>the constraint validator supports the type of the target
          object</para>
        </listitem>
      </itemizedlist>

      <section id="constraintdeclarationvalidationprocess-requirements-object">
        <title>Object validation</title>

        <para>Constraint declarations can be applied to a class or an
        interface. Applying a constraint to a class or interface expresses a
        validation over the state of the class or interface.</para>
      </section>

      <section id="constraintdeclarationvalidationprocess-requirements-property">
        <title>Field and property validation</title>

        <para>Constraint declarations can be applied on both fields and
        properties for the same object type. The same constraint should
        however not be duplicated between a field and its associated property
        (the constraint validation would be applied twice). It is recommended
        for objects holding constraint declarations to adhere a single state
        access strategy (either annotated fields or properties).</para>

        <!--EBE steve, constraints can be applied on fields of primitive types. We use boxing.-->

        <para>When a field is annotated with a constraint declaration, field
        access strategy is used to access the state validated by such
        constraint.</para>

        <para>When a property is annotated with a constraint declaration,
        property access strategy is used to access the state validated by such
        constraint.</para>

        <para>When using field access strategy, the bean validation provider
        accesses the instance variable directly. When using the property
        access strategy, the bean validation provider accesses the state via
        the property accessor method. It is required that the class follow the
        method signature conventions for JavaBeans read properties (as defined
        by the JavaBeans <classname>Introspector</classname> class) for
        constrained properties when constrained properties are used. In this
        case, for every constraint property of type T, there is a getter
        method, <methodname>get&lt;Property-name&gt;</methodname>. For
        <code>boolean</code> properties,
        <methodname>is&lt;Property-name&gt;</methodname> is an alternative
        name for the getter method. Specifically, if
        <methodname>getX</methodname> is the name of the getter method, where
        X is a string, the name of the persistent property is defined by the
        result of <code>java.beans.Introspector.decapitalize(X)</code>.</para>

        <para>The fields or methods visibility are not constrained.</para>
      </section>

      <section>
        <title>Graph validation</title>

        <para>In addition to supporting instance validation, validation of
        graphs of object is also supported. The result of graph validation is
        a unified list of constraint violations.</para>

        <para>Consider the situation where bean X contains a field of type Y.
        By annotating field Y with the <classname>@Valid</classname>
        annotation, the Validator will validate the contents of Y when X is
        validated. The exact type of the field of type Y (subclass,
        implementation) is determined at runtime. The constrain definitions
        for this particular subtype are used. This ensures proper polymorphism
        behavior.</para>

        <para>Collection-valued or array-valued fields and properties may also
        be decorated with the <classname>@Valid</classname> annotation. This
        causes the contents of the collection or array to be validated. The
        following types are supported:</para>

        <itemizedlist>
          <listitem>
            <para>any array of object</para>
          </listitem>

          <listitem>
            <para><classname>java.util.Collection</classname></para>
          </listitem>

          <listitem>
            <para><classname>java.util.Set</classname></para>
          </listitem>

          <listitem>
            <para><classname>java.util.List</classname></para>
          </listitem>

          <listitem>
            <para><classname>java.util.Map</classname></para>
          </listitem>
        </itemizedlist>

        <para>Each object stored in the array or collection is validated. For
        <classname>Map</classname>, the value of each entry is validated. Like
        regular references, it's type is determined at runtime and the
        constraint definitions for this particular type are used.</para>

        <para>The <classname>@Valid</classname> annotation is applied
        recursively. A conforming implementation avoids infinite loops by
        validating an object the first time it is encountered in the graph,
        and ignores it if it is encountered through at different path.</para>
      </section>
    </section>

    <section>
      <title>Constraint declaration</title>

      <para>Constraint declarations are placed on classes or interfaces
      primarily through annotations. A constraint annotation (see <xref
      linkend="constraintsdefinitionimplementation-constraintdefinition" />),
      can be applied to a type, on any of the type's fields or on any of the
      JavaBeans-compliant properties.</para>

      <para>When a constraint is defined on a type, the type instance being
      validated is passed to the constraint validator. When a constraint is
      defined on a field, the value of the field is passed to the constraint
      validator. When a constraint is defined on a getter, the result of the
      getter invocation is passed to the validation routine.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-inheritance">
      <title>Inheritance (interface and superclass)</title>

      <para>A constraint declaration can be placed on an interface. Constraint
      declarations held on superclasses as well as interfaces are evaluated by
      the Validator.</para>

      <para>The effect of constraint declarations is cumulative. Constraints
      declared on a superclass getter will be validated along with any
      constraints defined on an overridden version of the getter.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-groupsequence">
      <title>Group and group sequence</title>

      <para>Groups are useful to define subsets of constraints for validation
      purposes. Assigning constraints to groups provides the ability to do
      partial validation of the group. The <methodname>groups</methodname>
      element of the constraint annotation specifies the groups in which the
      constraint participates. At validation time, an optional parameter can
      be specified that narrows the set of groups to be validated.</para>

      <para>One important application for grouping is to control the order of
      evaluation of constraints. There are often scenarios where a preliminary
      set of constraints should be evaluated prior to other constraints. This
      is useful in two scenarios:</para>

      <itemizedlist>
        <listitem>
          <para>the second group depends on a stable state to run
          properly</para>
        </listitem>

        <listitem>
          <para>the second group is a heavy consumer of time, CPU or memory
          and should be avoided if possible</para>
        </listitem>
      </itemizedlist>

      <para>To implement such ordering, one or more
      <classname>@GroupSequence</classname> annotations can be added.</para>

      <programlisting>@Target({TYPE})
@Retention(RUNTIME)
public @interface GroupSequence {
    String name();
    String[] sequence();
}

@Target({TYPE})
@Retention(RUNTIME)
public @interface GroupSequences {
    GroupSequence[] value();
}</programlisting>

      <para><classname>@GroupSequence</classname> and
      <classname>@GroupSequences</classname> are placed on the validated class
      they should be applied on.</para>

      <para>Each group of a group sequence must be processed sequentially in
      the order defined by <methodname>@GroupSequence.sequence</methodname>
      when the group <methodname>@GroupSequence.name</methodname> is requested
      ; processing a group is defined in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine" /> ;
      if one of the groups processed in the sequence leads to one or more
      validation failures, the groups following in the sequence must not be
      processed.</para>

      <para>A group sequence can contain other group sequence names in its
      sequence. Group sequences are recursively resolved: the user must make
      sure no circular graph is defined by the group sequence
      definitions.</para>

      <para>For a given class, the group sequences taken into account are the
      ones placed on the class itself as well as the ones on all its
      superclasses and all its interfaces.</para>

      <para>When an object graph is validated (through the use of
      <literal>@Valid</literal>), the children elements of the graph inherit
      the sequence definitions of their parent. Two group sequences must not
      share the same group name in a given object graph (including
      superclasses and interfaces).</para>

      <para>Group sequences must not use constraint declaration group names as
      a name. In other words, constraint definition groups cannot contain one
      of the group sequence names.</para>

      <para>Unless constrained by a group sequence, the order in which groups
      are validated is undefined.</para>

      <!--Make explicit what happens if a group is part of a group sequence and also explicitly called in validator.validate()-->
    </section>

    <section id="constraintdeclarationvalidationprocess-validationroutine">
      <title>Validation routine</title>

      <para>For a given group to validate, the validation routine applied on a
      given bean instance is expected to execute the constraint
      validations:</para>

      <itemizedlist>
        <listitem>
          <para>execute all field level validations (including the ones
          expressed in interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine (as part of a previous
          group match)</para>
        </listitem>

        <listitem>
          <para>execute all getter level validations (including the ones
          expressed in interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine (as part of a previous
          group match)</para>
        </listitem>

        <listitem>
          <para>execute all class level validations (including the ones
          expressed in interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine (as part of a previous
          group match)</para>
        </listitem>

        <listitem>
          <para>execute all cascading validations (see <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation" />)
          including the ones expressed in interfaces and superclasses</para>
        </listitem>
      </itemizedlist>

      <para>Note that it implies that a given validation constraint will not
      be processed more than once per validation.</para>

      <!--SCP: note that grouping, as currently defined cannot control depth of search in the graph
EBE: correct, so far I don't think it's useful-->

      <para>The object validation routine is described as such. For each
      constraint declaration and in the previously defined order:</para>

      <itemizedlist>
        <listitem>
          <para>execute the <methodname>isValid</methodname> operation (from
          the constraint validation implementation) on the appropriate data
          (see <xref
          linkend="constraintsdefinitionimplementation-validationimplementation" />)</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns true, continue to
          the next constraint,</para>
        </listitem>

        <listitem>
          <para>if <methodname>isValid</methodname> returns false, the Bean
          Validation provider populates
          <classname>ConstraintViolation</classname> object(s) according to
          the rules defined in <xref
          linkend="constraintsdefinitionimplementation-validationimplementation" />
          and appends these objects to the list of returned values</para>

          <!--SCP: note that this implies that validation issues are returned in the order they are discovered
EBE: is that a problem?-->
        </listitem>
      </itemizedlist>

      <para>Bean Validation is a fully polymorphic framework. Constraints are
      gathered according to the object type determined at runtime.</para>

      <section id="constraintdeclarationvalidationprocess-validationroutine-graphvalidation">
        <title>Object graph validation</title>

        <para>The <classname>@Valid</classname> annotation on a given
        association (i.e. object reference or collection / array of objects),
        dictates the Bean Validator implementation to apply recursively the
        bean validation routine on (each of) the associated object(s). This
        mechanism is recursive: an associated object can itself contain
        cascaded references. The Bean Validation implementation must ignore
        the cascading operation if the associated object instance has already
        been validated by the current validation routine, thus preventing
        infinite loops.</para>

        <para>The <classname>ConstraintViolation</classname> objects, built
        when a failing constraint on an associated object is found, reflects
        the path to reach the object from the root validated object (See <xref
        linkend="validationapi-constraintviolation" />).</para>
      </section>
    </section>

    <section>
      <title>Examples</title>

      <para>The first example demonstrates how beans, fields and getters are
      annotated to express some constraints.</para>

      <example>
        <title>Place constraint declarations on the element to
        validate</title>

        <programlisting>@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Length(max=30)
    private String addressline1;

    @Length(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Length(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}</programlisting>
      </example>

      <para>During the validation routine execution on an
      <classname>Address</classname> object,</para>

      <itemizedlist>
        <listitem>
          <para><methodname>addressline1</methodname> field value is passed to
          the <classname>NotNull</classname> as well as
          <classname>Length</classname> constraint validation
          implementation.</para>
        </listitem>

        <listitem>
          <para><methodname>addressline2</methodname> field value is passed to
          the <classname>Length</classname> constraint validation
          implementations.</para>
        </listitem>

        <listitem>
          <para><methodname>getCity</methodname> value is passed to the
          <classname>Length</classname> and <classname>NotNull</classname>
          constraint validation implementations</para>
        </listitem>

        <listitem>
          <para><classname>ZipCodeCohereceChecker</classname> is a constraint
          whose validation implementation's <methodname>isValid</methodname>
          method receives the <classname>Address</classname> object</para>
        </listitem>
      </itemizedlist>

      <para>The second example demonstrates object graph validation</para>

      <example>
        <title>Define object graph validation</title>

        <programlisting>public class Country {
    @NotNull
    private String name;
    @Length(max=2) private String ISO2Code;
    @Length(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Length(max=30)
    private String addressline1;
    @Length(max=30)
    private String addressline2;
    @Length(max=11)
    private String zipCode;
    <emphasis role="bold">@NotNull @Valid</emphasis>
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Length(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</programlisting>
      </example>

      <para>During the validation routine execution on an
      <classname>Address</classname> object, constraints on
      <methodname>addressLine1</methodname>,
      <methodname>addressLine2</methodname>, <methodname>zipCode</methodname>
      and <methodname>country</methodname> are processed as well as the
      validation of the <classname>Country</classname> object itself, more
      specifically <methodname>country.name</methodname> is checked for
      <classname>NotNull</classname>, <methodname>ISO2Code</methodname> and
      <methodname>ISO3Code</methodname> are checked for
      <classname>Length</classname>.</para>

      <para>Assuming that @NotEmpty is defined as such</para>

      <programlisting>@Documented
@NotNull
@Size(min=1)
@ConstraintValidator(NotEmptyConstraint.class)
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
public @interface NotEmpty {
    ...
}</programlisting>

      <para>The third example demonstrates superclass, inheritance and
      composite constraints.</para>

      <example>
        <title>Use inheritance, constraints on superclasses and composite
        constraints</title>

        <programlisting>public interface Person {
    @NotEmpty
    String getFirstName();

    String getMiddleName();
    
    @NotEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}</programlisting>
      </example>

      <para>When validating a <classname>PreferredGuest</classname> the
      following constraints are processed:</para>

      <itemizedlist>
        <listitem>
          <para>NotEmpty, NotNull and Size(min=1) on firstName</para>
        </listitem>

        <listitem>
          <para>NotEmpty, NotNull and Size(min=1) on lastName</para>
        </listitem>

        <listitem>
          <para>NotNull on customerId, Password on password</para>
        </listitem>

        <listitem>
          <para>CreditCard on guestCreditCardNumber</para>
        </listitem>
      </itemizedlist>

      <para>The fourth example demonstrates the influence of group
      sequence.</para>

      <example>
        <title>Use groups and group sequence to define constraint
        ordering</title>

        <programlisting><emphasis role="bold">@GroupSequence(name="default", sequence={"first", "second", "last"})</emphasis>
public class Book {
    @NotEmpty(groups="first")
    private String title;

    @Length(max=30, groups="second")
    private String subtitle;

    @Valid
    @NotNull(groups="first")
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NotEmpty(groups="last")
    private String firstName;
    
    @NotEmpty(groups="first")
    private String lastName;

    @Length(max=30, groups="last")
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}</programlisting>
      </example>

      <para>Assuming the validation process of the following book
      instance:</para>

      <programlisting>Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );</programlisting>

      <para>the validation routine will return the following failure:</para>

      <itemizedlist>
        <listitem>
          <para><classname>NotNull</classname> failure (from
          <classname>NotEmpty</classname>) on the <literal>title</literal>
          field</para>
        </listitem>
      </itemizedlist>

      <para>As both <methodname>title</methodname> and
      <methodname>author.lastname</methodname> are checked as part of the
      <literal>first</literal> group. If the instance is updated:</para>

      <programlisting>book.setTitle( "Les fleurs du mal" );
author.setCompany("Some random publisher with a very very very long name");</programlisting>

      <para>the validation routine will return the following failures:</para>

      <itemizedlist>
        <listitem>
          <para><methodname>author.firstName</methodname> fails to pass the
          <classname>Size(min=1)</classname> (from
          <classname>NotEmpty</classname>) constraint</para>
        </listitem>

        <listitem>
          <para><methodname>author.company</methodname> fails to pass the
          <classname>Length</classname> constraint</para>
        </listitem>
      </itemizedlist>

      <para>As the <literal>first</literal> and <literal>second</literal>
      groups pass without failure, the <literal>last</literal> group is going
      through validation.</para>
    </section>
  </chapter>

  <chapter id="validationapi">
    <title>Validation APIs</title>

    <para>The default package for the Bean Validation APIs is
    <classname>javax.validation</classname></para>

    <section id="validationapi-validatorapi">
      <title>Validator API</title>

      <para>The main Bean Validation API is the
      <classname>javax.validation.Validator</classname> interface.</para>

      <para>A <classname>Validator</classname> instance is able to validate
      instances of beans and their associated objects if any. It is
      recommended to let <classname>Validator</classname> instance caching to
      the <classname>ValidatorFactory</classname>.
      <classname>Validator</classname> implementations are thread-safe.</para>

      <programlisting>/**
 * Validate bean instances
 * Implementations of this interface must be thread-safe
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @todo Should Serializable be part of the definition?
 */
public interface Validator {
    /**
     * validate all constraints on object
     *
     * @param object object to validate
     * @param groups group name(s) (including group sequence names) targeted
     * for validation (default to &amp;lt;code&amp;gt;default&amp;lt;/code&amp;gt;)
     *
     * @return constraint violations or an empty Set if none
     *
     * @throws IllegalArgumentException e if object is null
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, String... groups);

    /**
     * validate all constraints on &amp;lt;code&amp;gt;propertyName&amp;lt;/code&amp;gt; property of object
     *
     * @param object object to validate
     * @param propertyName property to validate (ie field and getter constraints)
     * @param groups group name(s) (including group sequence names) targeted
     * for validation (default to &amp;lt;code&amp;gt;default&amp;lt;/code&amp;gt;)
     *
     * @return constraint violations or an empty Set if none
     *
     * @throws IllegalArgumentException e if object is null or if propertyName is not present
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object, String propertyName, String... groups);

    /**
     * validate all constraints on &lt;code&gt;propertyName&lt;/code&gt; property
     * if the property value is &lt;code&gt;value&lt;/code&gt;
     * &lt;p/&gt;
     * TODO express limitations of ConstraintViolation in this case
     *
     * @param propertyName property to validate
     * @param value property value to validate
     * @param groups group name(s) (including group sequence names) targeted
     * for validation (default to &lt;code&gt;default&lt;/code&gt;)
     *
     * @return constraint violations or an empty Set if none
     * @throws IllegalArgumentException e if propertyName is not present
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType, String propertyName, Object value, String... groups);

    /**
     * Return the descriptor object describing bean constraints
     * The returned object (and associated objects including ConstraintDescriptors)
     * are immutable.
     *
     * @param clazz class type evaluated
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);
}</programlisting>

      <para><methodname>getConstraintsForClass</methodname> is described in
      <xref linkend="constraintmetadata" />.</para>

      <section id="validationapi-validatorapi-validationmethods">
        <title>Validation methods</title>

        <para><methodname>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validate(T object, String... groups)</methodname> is used to validate
        a given object of type <classname>T</classname>. This method
        implements the logic described in <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />.
        A Set containing all <classname>ConstraintViolation</classname>
        objects representing the failing constraints is returned, an empty
        <classname>Set</classname> is returned otherwise.</para>

        <para><methodname>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validateProperty(T object, String propertyName, String...
        groups)</methodname> validates a given field or property of an object.
        The property name is the JavaBeans property name (as defined by the
        JavaBeans <classname>Introspector</classname> class). This method
        implements the logic described in <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />
        and apply it only to the given property. <literal>@Valid</literal> is
        not honored by this method. This method is useful for partial object
        validation.</para>

        <para><methodname>&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validateValue(Class&lt;T&gt; beanType, String propertyName, Object
        value, String... groups)</methodname> validates the property
        referenced by <parameter>propertyName</parameter> present on
        <literal>beanType</literal> or any of its superclasses, if the
        property value were <parameter>value</parameter>. This method
        implements the logic described in <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />
        and apply it only to the given property and the given value.
        <literal>@Valid</literal> is not honored by this method. This method
        is useful for ahead of time validation.</para>

        <!--SCP: what values come back in ConstraintViolation for the validateValue() case?
EBE the value passed as a parameter. I think the JavaDoc is clear, should it be made explicit?-->

        <section>
          <title>Examples</title>

          <para>All the examples will be based on the following class
          definition, constraint declarations and address instance.</para>

          <programlisting>public class Address {
    <emphasis role="bold">@NotNull @Length(max=30)</emphasis>
    private String addressline1;

    <emphasis role="bold">@Length(max=30)</emphasis>
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    <emphasis role="bold">@Length(max=30) @NotNull</emphasis>
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales</programlisting>

          <para>The following code will return two
          <classname>ConstraintViolation</classname> objects. One for
          <literal>addressline1</literal> violating <literal>NotNull</literal>
          and one for <literal>city</literal> violating
          <literal>Length</literal>.</para>

          <programlisting>validator.validate(address).size() == 2</programlisting>

          <para>The following code will return one
          <classname>ConstraintViolation</classname> since
          <literal>city</literal> violates <literal>Length</literal> and only
          <literal>city</literal> is validated.</para>

          <programlisting>validator.validateProperty(address, "city").size() == 1</programlisting>

          <para>The following code will return no
          <classname>ConstraintViolation</classname> object because the value
          <literal>Paris</literal> for <literal>city</literal> would not raise
          any constraint failure.</para>

          <programlisting>validator.validateValue("city", "Paris").size() == 0</programlisting>
        </section>
      </section>

      <section id="validationapi-validatorapi-groups">
        <title>groups</title>

        <para>The (list of) group(s) restricts the set of constraints applied.
        Only the constraint declarations targeting (see <xref
        linkend="constraintsdefinitionimplementation-constraintdefinition-groups" />)
        one or more of the group(s) passed as a parameter to the
        <methodname>validate</methodname>,
        <methodname>validateProperty</methodname> and
        <methodname>validateValue</methodname> methods will be applied during
        the <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine" />.
        If no group is passed, the <literal>default</literal> group is
        assumed.</para>

        <section>
          <title>Examples</title>

          <programlisting>public class Address {
    @NotEmpty(groups = "minimal")
    @Length(max=50)
    private String street1;
    
    @NotEmpty
    private String city;

    @NotEmpty(groups = {"minimal", "default"})
    private String zipCode;
    ...
}</programlisting>

          <para>In the previous example, <classname>@NotEmpty</classname> (and
          it's composing constraints) on <methodname>street1</methodname>
          applies to the group <literal>minimal</literal>,
          <classname>@Length</classname> on <methodname>street1</methodname>
          applies to the group <literal>default</literal> and
          <classname>@NotEmpty </classname>(and it's composing constraints) on
          <methodname>zipCode</methodname> applies to the groups
          <literal>default</literal> and <literal>minimal</literal>.</para>

          <programlisting>validator.validate(address);</programlisting>

          <para>applies <classname>@Length</classname> on
          <methodname>street1</methodname>, <classname>@NotEmpty</classname>
          (and it's composing constraints) on <methodname>city</methodname>,
          <classname>@NotEmpty</classname> (and it's composing constraints) on
          <methodname>zipCode</methodname>. Particularly,
          <classname>@NotEmpty</classname> (and it's composing constraints) on
          <methodname>street1</methodname> are not applied.</para>

          <programlisting>validator.validate(address, "minimal");</programlisting>

          <para>applies <classname>@NotEmpty</classname> (and it's composing
          constraints) on <methodname>street1</methodname> and
          <classname>@NotEmpty</classname> (and it's composing constraints) on
          <methodname>zipCode</methodname></para>

          <programlisting>validator.validate(address, "minimal", "default");</programlisting>

          <para>applies <classname>@NotEmpty</classname> (and it's composing
          constraints) and <classname>@Length</classname> on
          <methodname>street1</methodname>, <classname>@NotEmpty</classname>
          (and it's composing constraints) on <methodname>city</methodname>,
          <classname>@NotEmpty</classname> (and it's composing constraints) on
          <methodname>zipCode</methodname>. Note that if
          <methodname>zipCode</methodname> is empty, only one
          <classname>ConstraintViolation</classname> object will represent the
          failure and the not empty validation will only be executed
          once.</para>

          <para>Let's look at a more complex example involving group
          sequence.</para>

          <programlisting>@GroupSequence(name="total", sequence={"firststep", "secondstep"})
public class Address {
    @NotEmpty(groups = "minimal")
    @Length(max=50, groups="firststep")
    private String street1;
    
    @NotEmpty(groups="secondstep")
    private String city;

    @NotEmpty(groups = {"minimal", "secondstep"})
    private String zipCode;
    ...
}</programlisting>

          <para>When running:</para>

          <programlisting>validator.validate(address, "minimal", "total");</programlisting>

          <para>the validation process will process
          <classname>NotEmpty</classname> (and it's composing constraints) and
          <classname>Length</classname> from <methodname>street1</methodname>
          and <classname>NotEmpty</classname> (and it's composing constraints)
          from <methodname>zipCode</methodname>. If
          <classname>Length</classname> from <methodname>street1</methodname>
          does not generate a failure, then <classname>NotEmpty</classname>
          (and it's composing constraints) from <methodname>city</methodname>
          will be processed. Note that <classname>NotEmpty</classname> (and
          it's composing constraints) from <methodname>zipCode</methodname>
          are not reprocessed as they have already been processed
          before.</para>

          <para>When running:</para>

          <programlisting>validator.validate(address, "total", "secondstep");</programlisting>

          <para><classname>NotEmpty</classname> (and it's composing
          constraints) from <methodname>city</methodname> and
          <classname>NotEmpty</classname> (and it's composing constraints)
          from <methodname>zipCode</methodname> will be processed even if
          <classname>Length</classname> from <methodname>street1</methodname>
          fails: while <literal>secondstep</literal> is in the
          <literal>total</literal> group sequence and hence should not be
          triggered if <literal>firststep</literal> has a failure, it also has
          been requested outside the sequence (in this case
          explicitly).</para>
        </section>
      </section>
    </section>

    <section id="validationapi-constraintviolation">
      <title>ConstraintViolation</title>

      <para><classname>ConstraintViolation</classname> is the class describing
      a single constraint failure. A set of
      <classname>ConstraintViolation</classname> is returned from an object
      validation.</para>

      <programlisting>/**
 * Describe a constraint violation. This object describe the error context as
 * well as the message describing the violation.
 *
 * @author Emmanuel Bernard
 * @todo the rational behind rootBean and propertyPath is to keep the context available to the user
 */
public interface ConstraintViolation&lt;T&gt; {

    /**
	 * @return The interpolated error message for this constraint violation.
	 */
	String getInterpolatedMessage();

	/**
	 * @return The non-interpolated error message for this constraint violation.
	 */
	String getRawMessage();

    /**
     * @return The root bean being validated.
     */
    T getRootBean();

    /**
     * If a bean constraint, the bean instance the constraint is applied on
     * If a property constraint, the bean instance hosting the property the
     * constraint is applied on
     * 
     * @return the leaf bean the constraint is applied on or null if Validator#validateValue
     * is used
     */
    Object getLeafBean();

    /**
     * @return the property path to the value from &lt;code&gt;rootBean&lt;/code&gt;
     *         &lt;code&gt;null&lt;/code&gt; if the value is the &lt;code&gt;rootBean&lt;code&gt; itself.
     */
    String getPropertyPath();


    /**
     * @return the type of interface or class being validated.
     */
    Class&lt;T&gt; getBeanClass();

    /**
     * @return the value failing to pass the constraint.
     */
    Object getInvalidValue();

    /**
     * @return the list of groups that the triggered constraint applies on and which also are
     *         within the list of groups requested for validation.
     *
     * TODO: considering removal, if you think it's important, speak up
     */
    Set&lt;String&gt; getGroups();

    /**
     * Constraint metadata reported to fail.
     * The returned instance is immutable.
     *
     * @return constraint metadata
     */
    ConstraintDescriptor getConstraintDescriptor();
}</programlisting>

      <para>The <methodname>getInterpolatedMessage</methodname> method returns
      the expanded (localized) message for the failing constraint (See <xref
      linkend="validationapi-message" /> for more information on message
      expansion). This can be used by clients to expose user friendly
      messages.</para>

      <para>The <methodname>getRawMessage</methodname> method returns the
      non-interpolated error message (usually the message attribute on the
      constraint declaration). Frameworks can use this as an error code
      key.</para>

      <para>The <methodname>getRootBean</methodname> method returns the root
      object being validated that led to the failing constraint (i.e. the
      object the client code passed to the
      <methodname>Validator.validate</methodname> method.</para>

      <para>The <methodname>getBeanClass</methodname> method returns the type
      of the current bean being validated and leading to the failure.
      <methodname>getLeafBean</methodname> returns the bean itself.</para>

      <para>The <methodname>getInvalidValue</methodname> method returns the
      value (field, property or validated object) being passed to
      <methodname>isValid</methodname> and returning false.</para>

      <para>The <methodname>getPropertyPath</methodname> is defined by the
      following rules:</para>

      <itemizedlist>
        <listitem>
          <para>if the constraint is a class level constraint, then the empty
          string is used</para>
        </listitem>

        <listitem>
          <para>if the constraint is a field level constraint, the field name
          is the <methodname>propertyPath</methodname></para>
        </listitem>

        <listitem>
          <para>if the constraint is a getter level constraint, the JavaBeans
          property name (as defined by the JavaBeans
          <classname>Introspector</classname> class) is the
          <literal>propertyPath</literal></para>
        </listitem>

        <listitem>
          <para>if an associated object is validated, add the association
          field or JavaBeans property name and a dot ('.') as a prefix to the
          previous rules. This rule is recursive.</para>

          <!--SCP: Need to decide what to do here when terminal is class. Trailing dot?
EBE rule #1 addresses that or am I off base?-->
        </listitem>

        <listitem>
          <para>if an associated object in a <classname>List</classname> or
          array is validated, add the association field or JavaBeans property
          name, followed by the index value surrounded by square brackets
          (<literal>[index]</literal>) and a dot ('.') as a prefix to the
          previous rules. For example <code>order.orderLines[1]</code> This
          rule is recursive.</para>
        </listitem>

        <listitem>
          <para>if an associated object in a Map is validated, add the
          association field or JavaBeans property name, followed by the
          <methodname>toString()</methodname> result of the key object
          surrounded by square brackets and quotes
          (<literal>["key.toString()"]</literal>) and a dot ('.') as a prefix
          to the previous rules. For example
          <code>item.evaluation["quality"]</code> This rule is
          recursive.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>the collection notation is following the Unified Expression
        Language conventions.</para>
      </note>

      <note>
        <para>From <methodname>rootBean</methodname> and
        <methodname>propertyPath</methodname>, it is possible to rebuild the
        context of the failure</para>
      </note>

      <para><methodname>groups</methodname> returns the intersection of the
      groups the triggered constraint applies on and the groups requested for
      validation.</para>

      <!--EBE: this notion is quite vague with the recursive group sequence-->

      <para><methodname>getConstraintDescriptor</methodname> provides access
      to the failing constraint metadata (see <xref
      linkend="constraintmetadata-constraintdescriptor" />).</para>

      <section>
        <title>Examples</title>

        <para>These examples assume the following definition of
        <classname>@NotEmpty</classname>.</para>

        <programlisting>@Documented
@NotNull
@Size(min=1)
@ReportAsViolationFromCompositeConstraint
@ConstraintValidator(NotEmptyConstraint.class)
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
public @interface NotEmpty {
    ...
}</programlisting>

        <para>and the following class definitions</para>

        <programlisting>public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Length(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    @NotEmpty(groups={"firstlevelcheck", "default"})
    private String title;

    @Valid
    @NotNull
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

Author author = new Author();
author.setCompany("ACME");
Book book = new Book();
book.setTitle("");
book.setAuthor(author);

Set&lt;ConstraintViolation&gt; constraintViolations = validator.validate(book);</programlisting>

        <para><classname>ConstraintViolations</classname> is a set of size 2.
        One of the entries represents the failure of
        <literal>NotEmpty</literal> (or more precisely
        <classname>Size(min=1)</classname> a component of
        <classname>NotEmpty</classname>) on the <literal>title</literal>
        property.</para>

        <para>The <classname>ConstraintViolation</classname> object for this
        failure passes the following assertions:</para>

        <programlisting>//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getInterpolatedMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();
assert Book.class == constraintViolation.getBeanClass();
//the offending value
assert book.getTitle().equals( constraintViolation.getInvalidValue() );
//the offending property
assert "title".equals( constraintViolation.getPropertyPath() );
assert constraintViolation.getGroups().length == 1 

List expectedGroups = new ArrayList(1);
expectedGroups.add("default");
for ( String group : constraintViolation.getGroups() ) {
    assert expectedGroups.contains(group);
}</programlisting>

        <para>The second failure, <literal>NotEmpty</literal> (or more
        precisely <classname>NotNull</classname> a component of
        <classname>NotEmpty</classname>) on the author's
        <methodname>lastname</methodname>, will produce the following
        <classname>ConstraintViolation</classname> object:</para>

        <programlisting>assert "lastname must not be null".equals( constraintViolation.getInterpolatedMessage() );
assert book == constraintViolation.getRootBean();
assert author == constraintViolation.getLeafBean();
assert Author.class == constraintViolation.getBeanClass();
//the offending value
assert book.getAuthor().getLastName() == constraintViolation.getInvalidValue();
//the offending property
assert "author.lastName".equals( constraintViolation.getPropertyPath() );
assert constraintViolation.getGroups().length == 0</programlisting>
      </section>
    </section>

    <section id="validationapi-message">
      <title>Message resolution</title>

      <section id="default-messageresolver">
        <title>Default message resolution</title>

        <para>A conforming implementation includes a default message resolver.
        This message resolver shall use the algorithm defined here to resolve
        message descriptors into human-readable messages.</para>

        <para>Each constraint defines a message descriptor via its
        <methodname>message</methodname> property. Every constraint definition
        shall define a default message descriptor for that constraint. A
        particular use of a constraint can override the default message
        descriptor of the constraint by setting the
        <methodname>message</methodname> property on the constraint.</para>

        <para>The message descriptor is a string literal and may contain one
        or more message parameters. Message parameters are string literals
        enclosed in braces.<!--SCP need to define the string literal here--></para>

        <programlisting>Value must be between {min} and {max}</programlisting>

        <section id="default-resolution-algorithm">
          <title>Algorithm</title>

          <para>The default message resolver begins by retrieving the message
          descriptor from the constraint. Message parameters are then replaced
          by repeatedly executing the steps listed below until no replacements
          are performed.</para>

          <!--SCP: Do we want to allow MessageFormat style formatting here?-->

          <orderedlist>
            <listitem>
              <para>A message parameter that matches the name of an attribute
              of the constraint declaration is replaced by the value of that
              property.</para>

              <!--SCP: The {value} message parameter is replaced by the value being validated, using the result of invoking the toString method onvalue. 
If the value being valudated is null, the string 'null' is used as a replacement string
EBE: hummm, relying on toString sucks. Not sure I like the {value} idea. and it conflicts with value the default annotation name-->
            </listitem>

            <listitem>
              <para>The message parameter is used as a key to search the
              <classname>ResourceBundle</classname> named
              <literal>ValidationMessages</literal> (often materialized as the
              property file
              <filename>/ValidationMessages.properties</filename> and its
              locale variations) using the default
              <classname>Locale</classname> as provided by
              <methodname>Locale.getDefault()</methodname>. If a property is
              found, the message parameter is replaced with the
              property.</para>
            </listitem>

            <listitem>
              <para>The message parameter is used as a key to search the
              default message resolver's built-in message properties. If a
              property is found, the message parameter is replaced with the
              property.</para>
            </listitem>
          </orderedlist>
        </section>
      </section>

      <section id="custom-message-resolution">
        <title>Custom message resolution</title>

        <para>A custom message resolver may be provided (e.g., to resolve
        contextual data, or to adjust the default <classname>Locale
        </classname>used). A message resolver implements the
        <classname>MessageResolver</classname> interface.</para>

        <programlisting>/**
 * Interpolate a given constraint violation message.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface MessageResolver {
    /**
     * Interpolate the message from the constraint parameters and the actual validated object.
     * The locale is defaulted according to the &lt;code&gt;MessageResolver&lt;/code&gt; implementation
     * See the implementation documentation for more detail.
     *
     * @param message The message to interpolate.
     * @param constraintDescriptor The constraint descriptor.
     * @param value The object being validated
     *
     * @return Interpolated error message.
     */
    String interpolate(String message, 
                       ConstraintDescriptor constraintDescriptor, 
                       Object value);

    /**
     * Interpolate the message from the constraint parameters and the actual validated object.
     * The Locale used is provided as a parameter
     *
     * @param message The message to interpolate.
     * @param constraintDescriptor The constraint descriptor.
     * @param value The object being validated
     * @param locale the locale targeted for the message
     *
     * @return Interpolated error message.
     */
    String interpolate(String message, 
                       ConstraintDescriptor constraintDescriptor, 
                       Object value, 
                       Locale locale);
}</programlisting>

        <para><parameter>message</parameter> is the message descriptor as seen
        in <literal>@ConstraintAnnotation.message</literal> or provided to the
        <classname>ConstraintContext</classname> methods.</para>

        <para><parameter>constraintDescriptor</parameter> is the
        <classname>ConstraintDescriptor</classname> object representing the
        metadata of the failing constraint (see <xref
        linkend="constraintmetadata" />).</para>

        <para><parameter>value</parameter> is the value being
        validated.</para>

        <para><methodname>MessageResolver.interpolate(String,
        ConstraintDescriptor, Object)</methodname> is invoked by for each
        constraint violation report generated. The default
        <classname>Locale</classname> is implementation specific.</para>

        <para><methodname>MessageResolver.interpolate(String,
        ConstraintDescriptor, Object, Locale)</methodname> can be invoked by a
        wrapping <classname>MessageResolver</classname> to enforce a specific
        Locale value by bypassing or overriding the default
        <classname>Locale</classname> strategy.</para>

        <para>A message resolver implementation shall be threadsafe.</para>

        <para>The message resolver is provided to the
        <classname>ValidatorFactory</classname> at construction time using
        <methodname>ValidatorFactoryBuilder.messageResolver(MessageResolver)</methodname>.
        This message resolver is shared by all validators generated by this
        <classname>ValidatorFactory</classname>.</para>

        <para>It is possible to override the
        <classname>MessageResolver</classname> implementation for a given
        <classname>Validator</classname> instance by invoking
        <methodname>ValidatorFactory.getValidator(Class&lt;?&gt;,
        MessageResolver)</methodname>.</para>

        <para>It is recommended that <classname>MessageResolver</classname>
        implementations delegate final interpolation to the Bean Validation
        default <classname>MessageResolver</classname> to ensure standard Bean
        Validation interpolation rules are followed, The default
        implementation is accessible through
        <methodname>ValidatorFactoryBuilder.getDefaultMessageResolver()</methodname>.</para>
      </section>

      <section id="validationapi-message-examples">
        <title>Examples</title>

        <para>These examples describe message interpolation based on the
        default message resolver's built-in messages (see <xref
        linkend="standard-resolver-messages" />), and the
        <filename>ValidationMessages.properties</filename> file shown in table
        . The current locale is assumed English.</para>

        <programlisting>//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid</programlisting>

        <para></para>

        <table>
          <title>message interpolation</title>

          <tgroup cols="2">
            <colspec align="center" />

            <tbody>
              <row>
                <entry>Failing constraint declaration</entry>

                <entry>interpolated message</entry>
              </row>

              <row>
                <entry>@NotNull</entry>

                <entry>must not be null</entry>
              </row>

              <row>
                <entry>@Max(30)</entry>

                <entry>must be less than or equal to 30</entry>
              </row>

              <row>
                <entry>@Size(min=5, max=15, message="Key must have between
                {min} and {max} characters")</entry>

                <entry>Key must have between 5 and 15 characters</entry>
              </row>

              <row>
                <entry>@Digits(integer=9, fraction=2)</entry>

                <entry>numeric value out of bounds (&lt;9 digits&gt;.&lt;2
                digits&gt; expected)</entry>
              </row>

              <row>
                <entry>@CreditCard(message={myapp.creditcard.error})</entry>

                <entry>credit card number not valid</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <!--SCP: add example of {value} here. Add use of MessageFormat style formatting-->

        <para>Here is an approach to specify the <classname>Locale</classname>
        value to choose on a given <classname>Validator</classname>.
        <classname>Locale</classname> aware
        <classname>MessageResolver</classname>. See <xref
        linkend="bootstrapping" /> for more details on the APIs.</para>

        <example id="validationapi-message-examples-specificlocale">
          <title>Use MessageResolver to use a specific Locale value</title>

          <programlisting>/**
 * delegate to a MessageResolver implementation but enforce a given Locale
 */
public class LocaleSpecificMessageResolver implements MessageResolver {
    private final MessageResolver defaultResolver;
    private final Locale defaultLocale;

    public LocaleSpecificMessageResolver(MessageResolver resolver, Locale locale) {
        this.defaultLocale = locale;
        this.defaultResolver = resolver;
    }

    /**
     * enforece the locale passed to the resolver
     */
    public String interpolate(String message, 
                              ConstraintDescriptor constraintDescriptor, 
                              Object value) {
        return defaultResolver.interpolate(message, constraintDescriptor, 
                                           value, this.defaultLocale);
    }

    // no real use, implemented for completeness
    public String interpolate(String message,
                              ConstraintDescriptor constraintDescriptor,
                              Object value,
                              Locale locale) {
        return defaultResolver.interpolate(message, constraintDescriptor, value, locale);
    }
}


Locale locale = getMyCurrentLocale();
Validator validator = 
    validatorFactory.getValidator(new LocaleSpecificMessageResolver(
                                       validatorFactory.getMessageResolver(),
                                       locale)
    );</programlisting>
        </example>

        <para>Most of the time, however, the relevant
        <classname>Locale</classname> will be provided by your application
        framework transparently. This framework will implement its own version
        of <classname>MessageResolver</classname> and pass it during the
        <classname>ValidatorFactory</classname> configuration. The application
        will not have to set the <classname>Locale</classname> itself. This
        example shows how a web framework like Java Server Faces would
        implement <classname>MessageResolver</classname> to provide a user
        specific default locale.</para>

        <example id="validationapi-message-examples-jsflocale">
          <title>Java Server Faces possible MessageResolver</title>

          <programlisting>public class JsfMessageResolver {
    private final MessageResolver delegate;

    public JsfMessageResolver(MessageResolver delegate) { 
        this.delegate = delegate; 
    }

    public String interpolate(String message, ConstraintDescriptor constraintDescriptor, 
                              Object value) {
        Locale locale = FacesContext.getCurrentInstance().getUIViewRoot().getLocale();
        return this.delegate.interpolate(
                        message, constraintDescriptor, value, locale );
    }

    public String interpolate(String message, ConstraintDescriptor constraintDescriptor, 
                              Object value, Locale locale) {
        return this.delegate.interpolate(message, constraintDescriptor, value, locale);
    }
}


//Build the ValidatorFactory
ValidatorFactoryBuilder builder = Validation.getBuilder();
ValidatorFactory factory = builder
          .messageResolver( new JsfMessageResolver( builder.getDefaultMessageResolver() ) )
          .build();

//JSF uses the factory to validate UI components using the specific MessageResolver
Validator validator = factory.getValidator();</programlisting>
        </example>

        <para>The application code will not even deal with Bean Validation
        APIs.</para>
      </section>
    </section>

    <section id="bootstrapping">
      <title>Bootstrapping</title>

      <para>The bootstrapping API aims at providing a
      <classname>ValidatorFactory</classname> object which is used to create
      <classname>Validator</classname> instances. The bootstrap process is
      decoupled from the provider implementation initialization: a bootstrap
      implementation must be able to bootstrap any Bean Validation provider
      implementation. The bootstrap sequence has been designed to achieve
      several goals:</para>

      <itemizedlist>
        <listitem>
          <para>plug multiple implementations</para>
        </listitem>

        <listitem>
          <para>choose a specific implementation</para>
        </listitem>

        <listitem>
          <para>extensibility: an application using a specific provider
          implementation can use specific configurations</para>
        </listitem>

        <listitem>
          <para>share and reuse of metadata across validators</para>
        </listitem>

        <listitem>
          <para>leave as much freedom as possible to implementations</para>
        </listitem>

        <listitem>
          <para>provide integration mechanisms to Java EE 5 and other
          containers</para>
        </listitem>

        <listitem>
          <para>type safety</para>
        </listitem>
      </itemizedlist>

      <para>The main artifacts involved in the bootstrap process are:</para>

      <itemizedlist>
        <listitem>
          <para><classname>Validation</classname>: API entry point. Lets you
          optionally define the Bean Validation provider targeted as well as a
          provider resolution strategy. Validation generates
          <classname>ValidatorFactoryBuilder</classname> objects and can
          bootstrap any provider implementation.</para>
        </listitem>

        <listitem>
          <para><classname>ValidationProvider</classname>: contract between
          the bootstrap procedure and a Bean Validation provider
          implementation.</para>
        </listitem>

        <listitem>
          <para><classname>ValidationProviderResolver</classname>: returns a
          list of all Bean Validation providers available in the execution
          context (generally the classpath).</para>
        </listitem>

        <listitem>
          <para><classname>ValidatorFactoryBuilder</classname>: collects the
          configuration details that will be used to build
          <classname>ValidatorFactory</classname>. A specific sub interface of
          <classname>ValidatorFactoryBuilder</classname> must be provided by
          Bean Validation providers as a unique identifier. This sub interface
          typically hosts provider specific configurations.</para>
        </listitem>

        <listitem>
          <para><classname>ValidatorFactory</classname>: result of the
          bootstrap process. Build <classname>Validator</classname> instances
          from a given Bean Validation provider.</para>
        </listitem>
      </itemizedlist>

      <para>Let's first see the API in action through some examples before
      diving into the concrete definitions.</para>

      <section>
        <title>Examples</title>

        <para>The most simple approach is to use the default Bean Validation
        provider or the one defined in the XML configuration file. The
        bootstrap entry point returns a generic
        <classname>ValidatorFactoryBuilder</classname> instance on which we
        apply the build operation. The <classname>ValidatorFactory</classname>
        is then ready to provide <classname>Validator</classname>
        instances.</para>

        <example>
          <title>Simple Bean Validation bootstrap sequence</title>

          <programlisting>ValidatorFactory factory = Validation.getBuilder().build();

//cache the factory somewhere
Validator validator = factory.getValidator();</programlisting>
        </example>

        <para>The <classname>ValidatorFactory</classname> object is
        thread-safe. Building <classname>Validator</classname> instances is
        typically a cheap operation. Building a
        <classname>ValidatorFactory</classname> is typically more expensive.
        Make sure to check your Bean Validation implementation documentation
        for more accurate details.</para>

        <para>The second example shows how a container can customize some Bean
        Validator resource handling to match its own behavior.</para>

        <example>
          <title>Customize message resolution and constraint factory
          implementation</title>

          <programlisting>//some customization from a container like Web Beans
ValidatorFactory factory = Validation
       .getBuilder()
          .messageResolver( new WBMessageResolver() )
          .constraintFactory( new WBComponentConstraintFactory() )
          .build();

//cache the factory somewhere
Validator validator = factory.getValidator();</programlisting>
        </example>

        <para>The third example shows how to bootstrap Bean Validation in an
        environment not following the traditional Java classloader strategies
        (such as tools or alternative service containers like OSGi). They can
        provider some alternative provider resolution strategy to discover
        Bean Validation providers.</para>

        <example>
          <title>Customize the Bean Validation provider resolution
          mechanism</title>

          <programlisting>//osgi environment
ValidatorFactory factory = Validation
       .defineBootstrapState()
          .providerResolver( new OSGiServiceDiscoverer() )
          .build();

//cache the factory somewhere
Validator validator = factory.getValidator();</programlisting>
        </example>

        <para>The next example shows how a client can choose a specific Bean
        Validation provider and configure provider specific properties
        programmatically in a type-safe way.</para>

        <example>
          <title>Use a specific provider and add specific
          configuration</title>

          <programlisting>ValidatorFactory factory = Validation
       .builderType( ACMEValidatorFactoryBuilder.class )
       .getBuilder()
          .messageResolver( new ContainerMessageResolver() ) //default configuration option
          .addConstaint(Address.class, customConstraintDescriptor) //ACME specific method
          .build();

//same initialization breaking the chaining method use
ACMEValidatorFactoryBuilder acmeBuilder = Validation
       .builderType( ACMEValidatorFactoryBuilder.class )
       .getBuilder();

ValidatorFactory factory = acmeBuilder
          .messageResolver( new ContainerMessageResolver() ) //default configuration option
          .addConstaint(Address.class, customConstraintDescriptor) //ACME specific method
          .build();


/**
 * ACME specific validator builder and configuration options
 */
public interface ACMEValidatorFactoryBuilder 
                    extends ValidatorFactoryBuilder&lt;ACMEValidatorFactoryBuilder&gt; {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     */
    ACMEValidatorFactoryBuilder addConstraint(Class&lt;?&gt; entity, 
                                              ACMEConstraintDescriptor constraintDescriptor);
}</programlisting>
        </example>

        <para>The last example shows how a Validator can use a specific
        <classname>MessageResolver</classname> implementation</para>

        <example>
          <title>Use a specific MessageResolver instance for a given
          Validator</title>

          <programlisting>ValidatorFactory factory = ...;
MessageResolver customResolver = new LocaleSpecificMessageResolver(
    locale, 
    factory.getMessageResolver()
);

Validator localizedValidator = 
    factory.getValidator(customResolver);</programlisting>
        </example>

        <para>We will now explore the various interfaces, their constraints
        and usage. We will go from the <classname>ValidatorFactory</classname>
        to the <classname>Validation</classname> class walking up the
        bootstrap chain.</para>
      </section>

      <section>
        <title>ValidatorFactory</title>

        <para><classname>ValidatorFactory</classname> objects build and
        provide initialized instances of <classname>Validator</classname> to
        Bean Validation clients. Clients should cache
        <classname>ValidatorFactory</classname> objects and reuse them for
        optimal performances. The API is designed to allow implementors to
        share constraint metadata in
        <classname>ValidatorFactory</classname>.</para>

        <para><classname>ValidatorFactory</classname> implementations must be
        thread-safe. <classname>ValidatorFactory</classname> implementations
        can cache <classname>Validator</classname> instances if needed.</para>

        <example>
          <title>ValidatorFactory interface</title>

          <programlisting>/**
 * Factory returning initialized Validator instances.
 * Implementations are thread-safe
 * This object is typically cached and reused.
 *
 * @author Emmanuel Bernard
 */
public interface ValidatorFactory {
    /**
     * return an initialized Validator instance.
     * Validator instances can be pooled and shared by the implementation
     *
     */
    Validator getValidator();

    /**
     * return an initialized Validator instance.
     * Validator instances can be pooled and shared by the implementation
     *
     * The returned Validator instance must use the MessageResolver instance
     * passed as a parameter to resolve error messages. 
     *
     */
    Validator getValidator(MessageResolver messageResolver);

    /**
     * Returns the MessageResolver instance configured at initialization time
     * for the ValidatorFactory
     * This is the instance used by #getValidator(Class)
     *
     * @return MessageResolver instance
     */
    MessageResolver getMessageResolver();
}</programlisting>
        </example>

        <para>A <classname>ValidatorFactory</classname> is provided by a
        <classname>ValidatorFactoryBuilder</classname>.</para>

        <para>The <classname>MessageResolver</classname> instance used by a
        <classname>Validator</classname> instance can be overridden specified
        using
        <methodname>ValidatorFactory.getValidator(MessageResolver)</methodname>.
        The <classname>MessageResolver</classname> passed as a parameter is
        used instead of the <classname>ValidatorFactory</classname>'s
        <classname>MessageResolver</classname>.</para>

        <para><methodname>getMessageResolver()</methodname> returns the
        <classname>MessageResolver</classname> instance configured during the
        initialization of the <classname>ValidatorFactory</classname>. It is
        particularly useful to build a <classname>Validator</classname>
        specific <classname>MessageResolver</classname> wrapping the one from
        the <classname>ValidatorFactory</classname>.</para>

        <para>See <xref
        linkend="validationapi-message-examples-specificlocale" /> for an
        example using both
        <methodname>getValidator(`MessageResolver)</methodname> and
        <methodname>getMessageResolver()</methodname>.</para>
      </section>

      <section>
        <title>ValidatorFactoryBuilder</title>

        <para><classname>ValidatorFactoryBuilder</classname> collects
        configuration informations, determines the correct provider
        implementation and delegates it the
        <classname>ValidatorFactory</classname> creation. This class lets you
        define:</para>

        <itemizedlist>
          <listitem>
            <para>the message resolver strategy instance</para>
          </listitem>

          <listitem>
            <para>the constraint factory instance</para>
          </listitem>

          <listitem>
            <para>the configuration <classname>InputStream</classname></para>
          </listitem>
        </itemizedlist>

        <para>A <classname>ValidatorFactoryBuilder</classname> does provide a
        <classname>MessageResolver</classname> implementation following the
        default Bean Validation <classname>MessageResolver</classname> rules
        as defined in <xref linkend="default-messageresolver" /> in
        <methodname>getDefaultMessageResolver()</methodname>. Such an
        implementation is useful to let a custom
        <classname>MessageResolver</classname> delegates to the standard
        <classname>MessageResolver</classname> (see <xref
        linkend="custom-message-resolution" /> and an example making use of
        <methodname>getDefaultMessageResolver()</methodname> in <xref
        linkend="validationapi-message-examples-jsflocale" />).</para>

        <para>Clients call
        <methodname>ValidatorFactoryBuilder.build()</methodname> to retrieve
        the initialized <classname>ValidatorFactory</classname>
        instance.</para>

        <example>
          <title>ValidatorFactoryBuilder interface</title>

          <programlisting>/**
 * Receives configuration information, selects the appropriate
 * Bean Validation provider and build the appropriate
 * ValidatorFactory.
 * &lt;p/&gt;
 * Usage:
 * &lt;pre&gt;
 * ValidatorFactoryBuilder&lt;?&gt; builder = //provided by one of the Validation bootstrap methods
 * ValidatorFactory = builder
 *         .messageResolver( new CustomMessageResolver() )
 *         .build();
 * &lt;/pre&gt;
 * &lt;p/&gt;
 * The ValidationProviderResolver is specified at ValidatorFactoryBuilder time
 * (see {@link javax.validation.spi.ValidationProvider}).
 * If none is explicitely requested, the default ValidationProviderResolver is used.
 * &lt;p/&gt;
 * The provider is selected in the following way:
 * - if a specific ValidatorFactoryBuilder subclass is requested programmatically using
 * Validation.builderType(), find the first provider matching it
 * - if a specific ValidatorFactoryBuilder subclass is defined in META-INF/validation.xml,
 * find the first provider matching it
 * - otherwise, use the first provider returned by the ValidationProviderResolver
 * &lt;p/&gt;
 * Implementations are not meant to be thread-safe
 *
 * @author Emmanuel Bernard
 */
public interface ValidatorFactoryBuilder&lt;T extends ValidatorFactoryBuilder&gt; {
    /**
     * Defines the message resolver used. Has priority over the configuration
     * based message resolver.
     *
     * @param resolver message resolver implementation.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     */
    T messageResolver(MessageResolver resolver);

    /**
     * Defines the constraint factory. Has priority over the configuration
     * based constraint factory.
     *
     * @param constraintFactory constraint factory inmplementation.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     */
    T constraintFactory(ConstraintFactory constraintFactory);

    /**
     * Configure the ValidatorFactory based on &lt;code&gt;stream&lt;/code&gt;
     * If not specified, META-INF/validation.xml is used
     * &lt;p/&gt;
     * The stream should be closed by the client API after the
     * ValidatorFactory has been returned
     *
     * @param stream configuration stream.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     */
    T configure(InputStream stream);

    /**
     * Return an implementation of the MessageResolver interface following the
     * default MessageREsolver defined in the specification:
     *  - use the ValidationMessages resource bundle to load keys
     *  - use Locale.getDefault()
     *
     * @return default MessageResolver implementation compliant with the specification
     */
    MessageResolver getDefaultMessageResolver();

    /**
     * Build a ValidatorFactory implementation.
     *
     * @return ValidatorFactory
     */
    ValidatorFactory build();
}</programlisting>
        </example>

        <para>A Bean Validation provider must define a sub interface of
        <classname>ValidatorFactoryBuilder</classname> uniquely identifying
        the provider. The <methodname>isSuitable()</methodname> method of its
        <classname>ValidationProvider</classname> implementation must return
        true when this sub interface type is passed as a parameter, false
        otherwise. The <classname>ValidatorFactoryBuilder</classname> sub
        interface typically hosts provider specific configuration
        methods.</para>

        <para>To facilitate the use of provider specific configuration
        methods, <classname>ValidatorFactoryBuilder</classname> uses generics:
        <classname>ValidatorFactoryBuilder&lt;T extends
        ValidatorFactoryBuilder&lt;T&gt;&gt;</classname> ; the generic return
        type <classname>T</classname> is returned by chaining methods. The
        provider specific sub interface must resolve the generic T as itself
        as shown in the following example.</para>

        <example>
          <title>Example of provider specific ValidatorFactoryBuilder sub
          interface</title>

          <programlisting>/**
 * Unique identifier of the ACME provider
 * also host some provider specific configuration methods
 *
 * @author Emmanuel Bernard
 */
public interface ACMEValidatorFactoryBuilder 
    extends ValidatorFactoryBuilder&lt;ACMEValidatorFactoryBuilder&gt; {

    /**
     * Enables contraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEValidatorFactoryBuilder enableDynamicReloading(boolean);

}</programlisting>
        </example>

        <para>When <methodname>ValidatorFactoryBuilder.build()</methodname> is
        called, the requested Bean Validation provider is determined and the
        result of
        <code>validationProvider.buildValidatorFactory(ValidatorFactoryConfiguration)</code>
        is returned. <classname>ValidatorFactoryConfiguration</classname>
        gives access to the configuration artifacts passed to
        <classname>ValidatorFactoryBuilder</classname>. A typical
        implementation of <classname>ValidatorFactoryBuilder</classname> also
        implements <classname>ValidatorFactoryConfiguration</classname>, hence
        <code>this</code> can be passed to
        <methodname>buildValidatorFactory(ValidatorFactoryConfiguration)</methodname>.<!--talk about extensibility--></para>

        <example>
          <title>ValidatorFactoryConfiguration interface</title>

          <programlisting>/**
 * Contract between a &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt; and a
 * &lt;/code&gt;ValidatorProvider&lt;/code&gt; to create a &lt;code&gt;ValidatorFactory&lt;/code&gt;.
 * The configuration artifacts provided to the
 * &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt; are passed along.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidatorFactoryConfiguration {
    /**
     * Message resolver as defined by the client programmatically
     * or null if undefined.
     *
     * @return message provider instance or null if not defined
     */
    MessageResolver getMessageResolver();

    /**
     * Returns the configuration stream defined by the client programmatically
     * or null if undefined.
     *
     * @return the configuration input stream or null
     */
    InputStream getConfigurationStream();

    /**
     * Defines the constraint implementation factory as defined by
     * the client programmatically or null if undefined
     *
     * @return factory instance or null if not defined
     */
    ConstraintFactory getConstraintFactory();
}</programlisting>
        </example>

        <para>The correct provider implementation is resolved according to the
        following rules in the following order:</para>

        <itemizedlist>
          <listitem>
            <para>Use the provider implementation requested if
            <classname>ValidatorFactoryBuilder</classname> has been created
            from
            <classname>Validation.builderType(Class).build()</classname>.</para>
          </listitem>

          <listitem>
            <para>Use the provider implementation associated with the
            <classname>ValidatorFactoryBuilder</classname> implementation
            described in the XML configuration (under
            <literal>validation.provider</literal>) if defined: the value of
            this element is the fully qualified class name of the
            <classname>ValidatorFactoryBuilder</classname> sub interface
            uniquely identifying the provider.</para>
          </listitem>

          <listitem>
            <para>Use the first provider implementation returned by
            <classname>validationProviderResolver.getValidationProviders()</classname>.</para>
          </listitem>
        </itemizedlist>

        <para>The <classname>ValidationProviderResolver</classname> is
        specified when <classname>ValidatorFactoryBuilder</classname> are
        created (see <classname>ValidationProvider</classname>). If no
        <classname>ValidationProviderResolver</classname> instance has been
        specified, the default
        <classname>ValidationProviderResolver</classname> is used.</para>

        <para><classname>ValidatorFactoryBuilder</classname> instances are
        provided to the Bean Validation client through one of
        <classname>Validation</classname> methods.
        <classname>ValidatorFactoryBuilder</classname> instances are created
        by <classname>ValidationProvider</classname>.</para>

        <warning>
          <para>Should we add a ignore XML method? to bypass the XMl file
          configuration?</para>
        </warning>
      </section>

      <section>
        <title>ValidationProvider and ValidationProviderResolver</title>

        <para><classname>ValidationProvider</classname> is the contract
        between the bootstrap process and a Bean Validation provider.
        <classname>ValidationProviderResolver</classname> can be implemented
        by any Bean Validation client but is typically implemented by
        containers having specific classloader structures and
        restrictions.</para>

        <section>
          <title>ValidationProviderResolver</title>

          <para><classname>ValidationProviderResolver</classname> returns the
          list of Bean Validation providers available at runtime and more
          specifically a <classname>ValidationProvider</classname> instance
          for each provider available in the context. This service can be
          customized by implementing
          <classname>ValidationProviderResolver</classname>. Implementations
          must be thread-safe.</para>

          <example>
            <title>ValidationProviderResolver</title>

            <programlisting>/**
 * Determine the list of Bean Validation providers available in the runtime environment
 * &lt;p&gt;
 * Bean Validation providers are identified by the presence of 
 * META-INF/services/javax.validation.spi.ValidationProvider
 * files following the Service Provider pattern described
 * &lt;a href="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider"&gt;here&lt;/a&gt;
 * &lt;p/&gt;
 * Each META-INF/services/javax.validation.spi.ValidationProvider file contains the list of
 * ValidationProvider implementations each of them representing a provider.
 *
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface ValidationProviderResolver {
    /**
     * Returns a list of ValidationProviders available in the runtime environment.
     *
     * @return list of validation providers.
     */
    List&lt;ValidationProvider&gt; getValidationProviders();
}</programlisting>
          </example>

          <para>By default, providers are resolved using the Service Provider
          pattern described in <ulink
          url="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider">http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider</ulink>.
          Each Bean Validation provider should supply a service provider
          configuration file by creating a text file name
          <filename>javax.validation.spi.ValidationProvider</filename> and
          placing it in the <filename>META-INF/services</filename> directory
          of one of its jar files. The content of the the file should be the
          name of the provider implementation class of the
          <classname>javax.validation.spi.ValidationProvider</classname>
          interface.</para>

          <para>Persistence provider jars may be installed or made available
          in the same ways as other service providers, e.g. as extensions or
          added to the application classpath according to the guidelines in
          the JAR file specification.</para>

          <para>The default <classname>ValidationProviderResolver</classname>
          implementation will locate all the Bean Validation providers by
          their provider configuration files visible in the classpath. The
          default <classname>ValidationProviderResolver</classname>
          implementation is recommended and custom
          <classname>ValidationProviderResolver</classname> implementations
          should be rarely used. A typical use of a custom resolution is
          resolving providers in a classloader constrained container like OSGi
          or in a tool environment (IDE).</para>

          <para>The default implementation of
          <classname>ValidationProviderResolver</classname> must be available
          at
          <classname>javax.validation.bootstrap.DefaultValidationProviderResolver</classname>.
          It must contain a public no-arg constructor and must not have any
          other non private attribute or method besides the method described
          by <classname>ValidationProviderResolver</classname>.</para>
        </section>

        <section>
          <title>ValidationProvider</title>

          <para><classname>ValidationProvider</classname> represents the SPI
          (Service Provider Interface) defining the contract between the
          provider discovery mechanism and initialization and the provider. A
          <classname>ValidationProvider</classname> does:</para>

          <itemizedlist>
            <listitem>
              <para>Determine if a provider matches a given
              <classname>ValidatorFactoryBuilder</classname> sub interface.
              One <classname>ValidatorFactoryBuilder</classname> sub interface
              specifically represent one Bean Validation provider.</para>
            </listitem>

            <listitem>
              <para>Provide a provider specific
              <classname>ValidatorFactoryBuilder</classname> implementation.
              This <classname>ValidatorFactoryBuilder</classname> will
              specifically build <classname>ValidatorFactory</classname>
              though the provider it comes from.</para>
            </listitem>

            <listitem>
              <para>Build a <classname>ValidatorFactory</classname> object
              from the configuration provided by
              <classname>ValidatorFactoryBuilder</classname>.</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>ValidationProvider</title>

            <programlisting>/**
 * Contract between the validation bootstrap mechanism and the provider engine.
 * &lt;p/&gt;
 * Implementations must have a public no-arg constructor. The construction of a provider
 * should be as "lightweight" as possible.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidationProvider {
    /**
     * This sub interface uniquely identify a provider.
     * 
     * @param builderClass targeted builder class.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;builderClass&lt;/code&gt; is the Bean Validation Provider sub
     *         interface for ValidatorFactoryBuilder
     */
    boolean isSuitable(Class&lt;? extends ValidatorFactoryBuilder&lt;?&gt;&gt; builderClass);

    /**
     * Returns a ValidatorFactoryBuilder instance implementing the
     * &lt;code&gt;builderType&lt;/code&gt; interface.
     * The ValidatorFactoryBuilder instance uses the current provider (&lt;code&gt;this&lt;/code&gt;)
     * to build the ValidatorFactory instance.
     * &lt;p/&gt;
     * This method can only be called on providers returning true on &lt;
     * code&gt;#isSuitable(builderType)&lt;/code&gt;
     *
     * @param builderClass the Builder class type
     * @param state bootstrap state
     *
     * @return specific validator builder implementation
     */
    &lt;T extends ValidatorFactoryBuilder&lt;T&gt;&gt; T createSpecializedValidatorFactoryBuilder(
            BootstrapState state,
            Class&lt;T&gt; builderClass);

    /**
     * Returns a ValidatorFactoryBuilder instance. This instance is not bound to
     * use the current provider. The choice of provider follows the algorithm described
     * in {@link javax.validation.ValidatorFactoryBuilder}
     * &lt;p/&gt;
     * The ValidationProviderResolver used is provided by &lt;code&gt;state&lt;/code&gt;.
     * If null, the default ValidationProviderResolver is used.
     *
     * @param state bootstrap state
     *
     * @return validator builder implementation
     */
    ValidatorFactoryBuilder&lt;?&gt; createGenericValidatorFactoryBuilder(BootstrapState state);

    /**
     * Build a ValidatorFactory using the current provider implementation. The
     * ValidatorFactory is assembled and follow the configuration passed
     * using ValidatorFactoryConfiguration.
     * &lt;p&gt;
     * The returned ValidatorFactory is properly initialized and ready for use.
     * &lt;/p&gt;
     *
     * @param configuration the configuration descriptor
     *
     * @return the instanciated ValidatorFactory
     */
    ValidatorFactory buildValidatorFactory(ValidatorFactoryConfiguration configuration);
}</programlisting>
          </example>

          <example>
            <title>BootstrapState interface</title>

            <programlisting>/**
 * Defines the state used to bootstrap the ValidatorFactoryBuilder
 *
 * @author Emmanuel Bernard
 */
public interface BootstrapState {
    /**
     * returns the user defined ValidationProviderResolver strategy instance or null 
     * if undefined
     *
     * @return ValidationProviderResolver instance or null
     */
    ValidationProviderResolver getValidationProviderResolver();
}</programlisting>
          </example>

          <para>A client can request a specific Bean Validation provider by
          using <classname>Validation.builderType(Class&lt;T exptends
          ValidatorFactoryBuilder&lt;T&gt;&gt;)</classname> or by defining the
          provider in the XML configuration file. The key uniquely identifying
          a Bean Validation provider is a provider specific sub interface of
          <classname>ValidatorFactoryBuilder</classname>. The sub interface
          does not have to add any new method but is the natural holder of
          provider specific methods.</para>

          <example>
            <title>Example of provider specific ValidatorFactoryBuilder sub
            interface</title>

            <programlisting>/**
 * Unique identifier of the ACME provider
 * also host some provider specific configuration methods
 *
 * @author Emmanuel Bernard
 */
public interface ACMEValidatorFactoryBuilder 
    extends ValidatorFactoryBuilder&lt;ACMEValidatorFactoryBuilder&gt; {

    /**
     * Enables contraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEValidatorFactoryBuilder enableDynamicReloading(boolean);

}</programlisting>
          </example>

          <note>
            <para><classname>ACMEValidatorFactoryBuilder</classname>
            references itself in the generic definition. Methods of
            <classname>ValidatorFactoryBuilder</classname> will return the
            <classname>ACMEValidatorFactoryBuilder</classname> making the API
            easy to use even for vendor specific extensions.</para>
          </note>

          <para>The provider discovery mechanism uses the following
          algorithm:</para>

          <itemizedlist>
            <listitem>
              <para>Retrieve available providers using
              <methodname>ValidationProviderResolver.getValidationProviders()</methodname>.</para>
            </listitem>

            <listitem>
              <para>The first <classname>ValidationProvider</classname>
              matching the requested provider is returned. Providers are
              evaluated in the order they are provided by
              <classname>ValidationProviderResolver</classname>. A provider is
              considered matching if
              <methodname>ValidationProvider.isSuitable(Class&lt;T extends
              ValidatorFactoryBuilder&lt;T&gt;&gt;)</methodname> returns true
              when the requested provider specific
              <classname>ValidatorFactoryBuilder</classname> sub interface is
              passed as a parameter.</para>
            </listitem>
          </itemizedlist>

          <para>When the default Bean Validation provider is requested, the
          first <classname>ValidationProvider</classname> returned by the
          <classname>ValidationProviderResolver</classname> strategy is
          returned.</para>

          <para>Every Bean Validation provider must provide a
          <classname>ValidationProvider</classname> implementation containing
          a public no-arg constructor and add the corresponding
          <filename>META-INF/services/javax.validation.spi.ValidationProvider</filename>
          file descriptor in one of its jars.</para>
        </section>
      </section>

      <section>
        <title>Validation</title>

        <para>The <classname>Validation</classname> class is the entry point
        used to bootstrap Bean Validation providers. The first entry point,
        <methodname>getBuilder()</methodname>, returns a
        <classname>ValidatorFactoryBuilder</classname> not tied to any
        provider implementation. The first provider returned by the default
        <classname>ValidationProviderResolver</classname> is used to build the
        <classname>ValidatorFactoryBuilder</classname>.
        <code>Validation.getBuilder()</code> is equivalent to
        <code>Validation.defineBootstrapState().getBuilder()</code>.</para>

        <warning>
          <para>Should the resolver strategy be configurable by XML</para>
        </warning>

        <example>
          <title>Validation methods available</title>

          <programlisting>/**
 * This class is the entry point for the Bean Validation framework. There are three ways
 * to bootstrap the framework:
 * &lt;ul&gt;
 * &lt;li&gt;
 * The easiest approach is to use the default Bean Validation provider.
 * &lt;pre&gt;
 * ValidatorFactory factory = Validation.getBuilder().build();
 * &lt;/pre&gt;
 * In this case {@link  javax.validation.bootstrap.DefaultValidationProviderResolver}
 * will be used to locate available providers.
 *
 * The chosen provider is defined as followed:
 * &lt;ul&gt;
 * &lt;li&gt;if the XML configuration defines a provider, this provider is used&lt;/li&gt;
 * &lt;li&gt;if the XML configuration does not define a provider or if no XML configuration
 * is present the first provider returned by the ValidationProviderResolver
 * isntance is used.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The second bootstrap approach allows to choose a custom
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt;. The chosen
 * &lt;code&gt;ValidationProvider&lt;/code&gt; is then determined in the same way
 * as in the default bootstrapping case (see above).
 * &lt;pre&gt;
 * ValidatorFactoryBuilder&amp;lt?&amp;gt; builder = Validation
 *    .defineBootstrapState()
 *    .providerResolver( new MyResolverStrategy() )
 *    .getBuilder();
 * ValidatorFactory factory = builder.build();
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * 
 * &lt;p/&gt;
 * &lt;li&gt;
 * The third approach allows you to specify explicitly and in
 * a type safe fashion the expected provider by
 * using its specific &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt; sub-interface.
 *
 * Optionally you can choose a custom &lt;code&gt;ValidationProviderResolver&lt;/code&gt;.
 * &lt;pre&gt;
 * ACMEValidatorFactoryBuilder builder = Validation
 *    .builderType(ACMEValidatorFactoryBuilder.class)
 *    .providerResolver( new MyResolverStrategy() )  // optionally set the provider resolver
 *    .getBuilder();
 * ValidatorFactory factory = builder.build();
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * Note:&lt;br/&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * The ValidatorFactory object built by the bootstrap process should be cached
 * and shared amongst Validator consumers.
 * &lt;/li&gt;
 * &lt;li&gt;
 * This class is thread-safe.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Feretnschik
 * @see DefaultValidationProviderResolver
 */
public class Validation {

    /**
     * Build a &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt;. The actual provider
     * choice is given by the XML configuration. If the
     * XML configuration does not exsist the default is taken.
     * &lt;p/&gt;
     * The provider list is resolved using the
     * {@link  javax.validation.bootstrap.DefaultValidationProviderResolver}.
     *
     * @return &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt; instance.
     */
    public static ValidatorFactoryBuilder&lt;?&gt; getBuilder() {
        ...
    }

    /**
     * Build a &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt;. The provider list is resolved
     * using the strategy provided to the bootstrap state.
     * &lt;pre&gt;
     * ValidatorFactoryBuilder&amp;lt?&amp;gt; builder = Validation
     *    .defineBootstrapState()
     *    .providerResolver( new MyResolverStrategy() )
     *    .getBuilder();
     * ValidatorFactory factory = builder.build();
     * &lt;/pre&gt;
     * The actual provider choice is given by the XML configuration. If the XML
     * configuration does not exsist the first available provider will be returned.
     *
     * @return instance building a generic &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt;
     * compliant with the bootstrap state provided.
     */
    public static GenericBuilderFactory defineBootstrapState() {
        ...
    }

    /**
     * Build a &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt; for a particular provider implementation.
     * Optionally override the provider resolution strategy used to determine the provider.
     * &lt;p/&gt;
     * Used by applications targeting a specific provider programmatically.
     * &lt;p/&gt;
     * &lt;pre&gt;
     * ACMEValidatorFactoryBuilder builder = Validation.builderType(ACMEValidatorFactoryBuilder.class)
     *     .providerResolver( new MyResolverStrategy() )
     *     .build();
     * &lt;/pre&gt;,
     * where &lt;code&gt;ACMEValidatorFactoryBuilder&lt;/code&gt; is the &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt;
     * sub interface uniquely identifying the ACME Bean Validation provider.
     *
     * @param builderType the &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt; sub interface
     * uniquely defining the targeted provider.
     *
     * @return instance building a provider specific &lt;code&gt;ValidatorFactoryBuilder&lt;/code&gt;
     * sub interface implementation.
     *
     * @see #getBuilder()
     */
    public static &lt;T extends ValidatorFactoryBuilder&lt;T&gt;&gt; 
            SpecializedBuilderFactory&lt;T&gt; builderType(Class&lt;T&gt; builderType) {
        ...
    }
}</programlisting>
        </example>

        <para>The second entry point lets the client provide a custom
        <classname>ValidationProviderResolution</classname> instance. This
        instance is passed to <classname>GenericBuilderFactory</classname>.
        <classname>GenericBuilderFactory</classname> builds a generic
        <classname>ValidatorFactoryBuilder</classname> using the first
        <classname>ValidationProvider</classname> returned by
        <classname>ValidationProviderResolution</classname> and calling
        <code>ValidatorFactoryBuilder&lt;?&gt;
        createGenericValidatorFactoryBuilder(BootstrapState state)</code>.
        <classname>BootstrapState</classname> holds the
        <classname>ValidationProviderResolution</classname> instance passed to
        <classname>GenericBuilderFactory</classname> and will be used by the
        <classname>ValidatorFactoryBuilder</classname> instance when resolving
        the provider to use.</para>

        <example>
          <title>GenericBuilderFactory interface</title>

          <programlisting>/**
 * Defines the state used to bootstrap Bean Validation and create an appropriate
 * ValidatorFactoryBuilder
 *
 * @author Emmanuel Bernard
 */
public interface GenericBuilderFactory {
    /**
     * Defines the provider resolution strategy.
     * This resolver returns the list of providers evaluated
     * to build the ValidatorFactoryBuilder
     * &lt;p/&gt;
     * If no resolver is defined, the default ValidationProviderResolver
     * implementation is used.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    GenericBuilderFactory providerResolver(ValidationProviderResolver resolver);

    /**
     * Returns a generic ValidatorFactoryBuilder implementation.
     * At this stage the provider used to build the ValidatorFactory is not defined.
     * &lt;p/&gt;
     * The ValidatorFactoryBuilder implementation is provided by the first provider returned
     * by the ValidationProviderResolver strategy.
     *
     * @return a ValidatorFactoryBuilder implementation compliant with the bootstrap state
     */
    ValidatorFactoryBuilder&lt;?&gt; getBuilder();
}</programlisting>
        </example>

        <para>The last entry point lets the client define the specific Bean
        Validation provider requested as well as a custom
        <classname>ValidationProviderResolver</classname> implementation if
        needed. The entry point method, <methodname>builderType(Class&lt;T&gt;
        builderType)</methodname>, takes the provider specific
        <classname>ValidatorFactoryBuilder</classname> sub interface type and
        returns a <classname>SpecializedBuilderFactory</classname> object that
        guarantees to return an instance of the specific
        <classname>ValidatorFactoryBuilder</classname> sub interface. Thanks
        to the use of generics, the client API does not have to cast to the
        <classname>ValidatorFactoryBuilder</classname> sub interface.</para>

        <para>A <classname>SpecializedBuilderFactory</classname> object can
        optionally receive a <classname>ValidationProviderResolver</classname>
        instance.</para>

        <example>
          <title>SpecializedBuilderFactory interface</title>

          <programlisting>/**
 * Build implementations of builderType, the specific ValidatorFactoryBuilder
 * sub interface uniquely identifying a provider.
 * &lt;p/&gt;
 * The requested provider is the first provider suitable for T (as defined in
 * {@link javax.validation.spi.ValidationProvider#isSuitable(Class)}). The
 * list of providers evaluated is returned by {@link ValidationProviderResolver}.
 * If no ValidationProviderResolver is defined, the
 * default ValidationProviderResolver strategy is used.
 *
 * @author Emmanuel Bernard
 */
public interface SpecializedBuilderFactory&lt;T extends ValidatorFactoryBuilder&lt;T&gt;&gt; {

    /**
     * Optionally define the provider resolver implementation used.
     * If not defined, use the default ValidationProviderResolver
     *
     * @param resolver ValidationProviderResolver implementation used
     *
     * @return self
     */
    public SpecializedBuilderFactory&lt;T&gt; providerResolver(ValidationProviderResolver resolver);

    /**
     * Determine the provider implementation suitable for builderType and delegate
     * the creation of this specific ValidatorFactoryBuilder subclass to the provider.
     *
     * @return a ValidatorFactoryBuilder sub interface implementation
     */
    public T getBuilder();
}</programlisting>
        </example>

        <para><methodname>SpecializedBuilderFactory.getValidatorFactoryBuilder()</methodname>
        must return the result of
        <methodname>ValidationProvider.createSpecializedValidatorFactoryBuilder(BootstrapState
        state, Class&lt;T extends
        ValidatorFactoryBuilder&lt;T&gt;&gt;)</methodname>. The state
        parameter holds the <classname>ValidationProviderResolver</classname>
        passed to <classname>SpecializedBuilderFactory</classname>. The
        builder type passed as a parameter is the builder type passed to
        <methodname>Validation.builderType(Class)</methodname>. The validation
        provider is selected from the builder type according to the algorithm
        described in (XX).</para>

        <para>The <classname>Validation</classname> implementation provided by
        the Bean Validation provider must not contain any non private
        attribute or method aside from the three public static bootstrap
        methods:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>public static ValidatorFactoryBuilder&lt;?&gt;
            getValidatorFactoryBuilder()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>public static GenericBuilderFactory
            defineBootstrapState()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>public static &lt;T extends
            ValidatorFactoryBuilder&lt;T&gt;&gt;
            SpecializedBuilderFactory&lt;T&gt; builderType(Class&lt;T&gt;
            builderType)</methodname></para>
          </listitem>
        </itemizedlist>

        <para>The bootstrap API is designed to allow complete portability
        amongst Bean Validation provider implementations. The bootstrap
        implementation must ensure it can bootstrap third party
        providers.</para>
      </section>

      <section>
        <title>Usage</title>

        <para>The Bean Validation bootstrap API can be used directly by the
        application, through the use of a container or by framework in need
        for validation. In all cases, the following rules apply:</para>

        <itemizedlist>
          <listitem>
            <para><classname>ValidatorFactory</classname> is a thread-safe
            object that should be built once per deployment unit</para>
          </listitem>

          <listitem>
            <para><classname>Validator</classname> is thread-safe too and
            should be considered a lightweight object.
            <classname>ValidatorFactory</classname> would typically implement
            appropriate <classname>Validator</classname> instance caching
            strategies if needed.</para>
          </listitem>
        </itemizedlist>

        <para>Containers such as Java EE, Web Bean, dependency injection
        frameworks, component frameworks are encouraged to propose access to
        <classname>ValidatorFactory</classname> and
        <classname>Validator</classname> objects in a way that respects the
        following rules. For example, injection of
        <classname>Validator</classname> should be possible.</para>
      </section>
    </section>
  </chapter>

  <chapter id="constraintmetadata" xreflabel="Constraint metadata request API">
    <title>Constraint metadata request APIs</title>

    <para>The Bean Validation specification provides a way to query the
    constraint repository. This API is expected to be used for tooling support
    as well as integration with other frameworks, libraries and JSRs. The Bean
    Validation specification aims to provide both a validation engine and a
    metadata repository for object constraints. Frameworks (EE or SE) in need
    for constraint definition, validation and metadata will be able to rely on
    the Bean Validation specification for these services avoiding any
    unnecessary duplication work from an application and infrastructure point
    of view.</para>

    <section>
      <title>Validator</title>

      <para>The main API to access all metadata related to a given object is
      <classname>Validator</classname> (see <xref linkend="bootstrapping" />
      for more information on how to retrieve a
      <classname>Validator</classname> instance).</para>

      <para>A <classname>Validator</classname> instance hosts the method to
      access to the metadata repository for a given class. It is recommended
      to let <classname>Validator</classname> instance caching to the
      <classname>ValidatorFactory</classname>.
      <classname>Validator</classname> implementation are thread-safe.</para>

      <programlisting>/**
 * Validate a given object type
 * Implementations of this interface must be thread-safe
 * 
 * @author Emmanuel Bernard
 */
public interface Validator {

    [...] //See 4.1

    /**
     * Return the descriptor object describing bean constraints
     * The returned object (and associated objects including ConstraintDescriptors)
     * are immutable.
     *
     * @param clazz class type evaluated
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);<!--Add a method to return the GroupSequences-->
}</programlisting>

      <para><methodname>getConstraintsForClass</methodname> returns a
      <classname>BeanDescriptor</classname> object describing the bean level
      constraints (see <xref
      linkend="constraintdeclarationvalidationprocess-requirements-object" />)
      and providing access to the property level constraints metadata.</para>
    </section>

    <section>
      <title>ElementDescriptor</title>

      <para><classname>ElementDescriptor</classname> is the root interface
      describing elements hosting constraints. It is used to describe the list
      of constraints for a given element (whether it be a field, a method or a
      class).</para>

      <programlisting>/**
 * Describes a validated element (class, field or property).
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ElementDescriptor {

    /**
     * @return Statically defined returned type.
     *
     * @todo should it be Type or even completly removed
     */
    Class&lt;?&gt; getType();

    /**
     * @return All the constraint descriptors for this element.
     */
    List&lt;ConstraintDescriptor&gt; getConstraintDescriptors();

}</programlisting>

      <para><methodname>getType</methodname> returns either the object type
      for a class, or the returned type for a property (TODO problem of
      generics resolution).</para>

      <para><classname>getConstraintDescriptors</classname> returns the
      <classname>ConstraintDescriptor</classname>s (see <xref
      linkend="constraintmetadata-constraintdescriptor" />), each
      <classname>ConstraintDescriptor</classname> describing one of the
      constraints declared on the given element.</para>
    </section>

    <section>
      <title>BeanDescriptor</title>

      <para>The <classname>BeanDescriptor</classname> interface describes a
      constrained Java Bean. This interface is returned by
      <methodname>Validator.getConstraintsForClass(Class&lt;?&gt;)</methodname>.</para>

      <programlisting>/**
 * Describe a constrained Java Bean and the constraints associated to it.
 * 
 * @author Emmanuel Bernard
 */
public interface BeanDescriptor extends ElementDescriptor {
    /**
     * return true if at least one constraint declaration is present for the given bean
     * or if one property is marked for validation cascade
     */
    boolean hasConstraints();

    /**
     * Return the property level constraints for a given propertyName
     * or null if either the property does not exist or has no constraint
     * The returned object (and associated objects including ConstraintDescriptors)
     * are immutable.
     *
     * @param propertyName property evaludated
     */
    PropertyDescriptor getConstraintsForProperty(String propertyName);

    /**
     * return the property names having at least a constraint defined
     */
    Set&lt;String&gt; getPropertiesWithConstraints();
}</programlisting>

      <para><methodname>hasConstraints</methodname> returns true if the given
      class has at least one constraint declared.</para>

      <para><methodname>getConstraintsForProperty</methodname> returns a
      <classname>PropertyDescriptor</classname> object describing the property
      level constraints (See <xref
      linkend="constraintdeclarationvalidationprocess-requirements-property" />).
      The property is uniquely identified by its name as per the JavaBeans
      convention: field level and getter level constraints of the given name
      are all returned.</para>

      <para><methodname>getPropertiesWithConstraints</methodname> returns the
      names of the bean properties having at least one constraint or being
      cascaded (<classname>@Valid</classname> annotation).</para>
    </section>

    <section>
      <title>PropertyDescriptor</title>

      <para>The <classname>PropertyDescriptor</classname> interface describes
      a constrained property of a Java Bean. This interface is returned by
      <methodname>BeanDescriptor.getConstraintsForProperty(String)</methodname>.
      Constraints declared on the attribute and the getter of the same name
      according to the Java Bean rules are returned by this descriptor.</para>

      <programlisting>/**
 * Describes a Java Bean property hosting validation constraints.
 *
 * Constraints placed on the attribute and the getter for a given property
 * are all referenced by this object.
 *
 * @author Emmanuel Bernard
 */
public interface PropertyDescriptor extends ElementDescriptor {
    /**
     * Is the property marked by the &lt;code&gt;@Valid&lt;/code&gt; annotation.
     * @return true if the annotation is present
     */
    boolean isCascaded();

    /**
     * Name of the property acording to the Java Bean specification.
     * @return property name
     */
    String getPropertyName();
}</programlisting>

      <para>The <methodname>isCascaded</methodname> method returns
      <literal>true</literal> of the property is marked with
      <classname>@Valid</classname>.</para>

      <para><methodname>getPropertyName</methodname> returns the property name
      as described in <xref
      linkend="validationapi-constraintviolation" />.</para>
    </section>

    <section id="constraintmetadata-constraintdescriptor">
      <title>ConstraintDescriptor</title>

      <para>A <classname>ConstraintDescriptor</classname> object describes a
      given constraint declaration (i.e. a constraint annotation).</para>

      <programlisting>/**
 * Describes a single constraint and its composing constraints.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintDescriptor {
    /**
     * Returns the annotation describing the constraint declaration.
     * If a composing constraint, parameter values are reflecting
     * the overridden parameters from the main constraint
     *
     * @return The annotation for this constraint.
     */
    Annotation getAnnotation();

    /**
     * @return The groups the constraint is applied on.
     */
    Set&lt;String&gt; getGroups();

    /**
     * @return the constraint implementation class
     */
    Class&lt;? extends Constraint&gt; getConstraintClass();

    /**
     * Returns a map containing the annotation parameter names as keys and the
     * annotation parameter values as value.
     * If this constraint is used as part of a composed constraint, parameter
     * values are reflecting the overridden parameters from the main constraint.
     *
     * @return Returns a map containing the annotation paramter names as keys
     *         and the annotation parameter values as value.
     */
    Map&lt;String, Object&gt; getParameters();

    /**
     * Return a set of composing &lt;code&gt;ConstraintDescriptor&lt;/code&gt;s where each
     * descriptor describes a composing constraint. &lt;code&gt;ConstraintDescriptor&lt;/code&gt;
     * instances of composing constraints reflect overridden parameter values in
     * {@link #getParameters()}  and {@link #getAnnotation()}.
     *
     * @return a set of &lt;code&gt;ConstraintDescriptor&lt;code&gt; objects or an empty set
     *         in case there are no composing constraints.
     */
    Set&lt;ConstraintDescriptor&gt; getComposingConstraints();

    /**
     * @return true if the constraint is annotated with @ReportAsViolationFromCompositeConstraint
     */
    boolean isReportAsViolationFromCompositeConstraint();
}</programlisting>

      <para><methodname>getAnnotation</methodname> returns the annotation
      instance (or an annotation instance representing the given constraint
      declaration). If <classname>ConstraintDescriptor</classname> represents
      a composing annotation (see <xref
      linkend="constraintsdefinitionimplementation-constraintcomposition" />),
      the returned annotation must reflect parameter overriding. In other
      words, the annotation parameter values must reflect any parameter
      overriding.</para>

      <para><methodname>getParameters</methodname> returns a map containing
      the annotation parameter names as a key, and the annotation parameter
      values as a value (this API is anticipated to be simpler to use by tools
      than reflection over the annotation instance). If
      <classname>ConstraintDescriptor</classname> represents a composing
      annotation (see <xref
      linkend="constraintsdefinitionimplementation-constraintcomposition" />),
      the returned map must reflect parameter overriding.</para>

      <para><methodname>getGroups</methodname> returns the group names, the
      constraint is supposed to be applied upon.</para>

      <para><methodname>getConstraintClass</methodname> returns the class
      implementing the constraint.</para>

      <warning>
        <para>Would <methodname>getConstraintImplementation()</methodname> be
        useful? Why would you use it for?</para>
      </warning>
    </section>

    <section>
      <title>Example</title>

      <para>Assuming the following <classname>@NotEmpty</classname>
      definition</para>

      <programlisting>@Documented
@NotNull
@Size(min=1)
@ReportAsViolationFromCompositeConstraint
@ConstraintValidator(NotEmptyConstraint.class)
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
public @interface NotEmpty {
    ...
}</programlisting>

      <para>and the following class definitions</para>

      <programlisting>public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Length(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    private String title;
    private String description;

    @Valid
    @NotNull
    private Author author;

    @NotEmpty(groups={"firstlevelcheck", "default"})
    @Length(max=30)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setAuthor(String description) {
        this.description = description;
    }
}

BeanDescriptor bookDescriptor = validator.getConstraintsForClass(Book.class);

assert bookDescriptor.hasConstraints();

assert bookDescriptor.getConstraintDescriptors().size() == 0 //no bean-level constraint

//more specifically "author" and "title"
assert bookDescriptor.getPropertiesWithConstraints().size() == 2;

//not a property
assert bookDescriptor.getConstraintsForProperty("doesNotExist") == null; 

//property with no constraint
assert bookDescriptor.getConstraintsForProperty("description") == null; 

ElementDescriptor propertyDescriptor = bookDescriptor.getConstraintsForProperty("title");
assert propertyDescriptor.getConstraintDescriptors().size() == 2
assert "title".equals( propertyDescriptor.getPropertyName() );

//assuming the implementation returns the NotEmpty constraint first
ConstraintDescriptor constraintDescriptor = propertyDescriptor.getConstraintDescriptors()
                                                              .iterator().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( NotEmpty.class );
assert constraintDescriptor.getGroups().size() == 2; //"firstlevelcheck" and "default"
assert constraintDescriptor.getComposingConstraints().size() == 2;
assert constraintDescriptor.isReportAsViolationFromCompositeConstraint() == true

//@NotEmpty cannot be null
boolean notNullPresence = false;
for ( ConstraintDescriptor composingDescriptor : constraintDescriptor.getComposingConstraints() ) {
    if ( composingDescriptor.getAnnotation().getAnnotationType().equals( NotNull.class ) ) {
        notNullPresence = true;
    }
}
assert notNullPresence; 

//assuming the implementation returns the Length constraint second
constraintDescriptor = propertyDescriptor.getConstraintDescriptors().iterator().next().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( Length.class );
assert constraintDescriptor.getParameters().get("max") == 30; 
assert constraintDescriptor.getGroups().length == 0;

propertyDescriptor = bookDescriptor.getConstraintsForProperty("author");
assert propertyDescriptor.getConstraintDescriptors().size() == 1
assert propertyDescriptor.isCascaded()</programlisting>
    </section>
  </chapter>

  <chapter>
    <title>Built-in Constraint definitions</title>

    <para>The specification defines a small set of built-in constraints. Their
    usage is encouraged both in regular constraint declarations and as
    composing constraints. Using this set of constraints will enhance
    portability of your constraints across constraint-consuming frameworks
    relying on the metadata API (such as client side validation frameworks or
    database schema generation frameworks).</para>

    <para>All built-in constraints are in the
    <classname>javax.validation.constraints</classname> package. Here is the
    list of constraints and their declaration.</para>

    <example>
      <title>@Null constraint</title>

      <programlisting>/**
 * The annotated element must be null.
 * Accepts any type. 
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Null {
    String message() default "{constraint.null}";
    String[] groups() default {};
}</programlisting>
    </example>

    <example>
      <title>@NotNull constraint</title>

      <programlisting>/**
 * The annotated element must not be null.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface NotNull {
    String message() default "{constraint.notNull}";
    String[] groups() default {};
}</programlisting>
    </example>

    <example>
      <title>@AssertTrue constraint</title>

      <programlisting>/**
 * The annotated element must be true.
 * Supported types are &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt; 
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface AssertTrue {
    String message() default "{constraint.assertTrue}";
    String[] groups() default {};
}</programlisting>
    </example>

    <example>
      <title>@AssertFalse constraint</title>

      <programlisting>/**
 * The annotated element must be false.
 * Supported types are &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface AssertFalse {
    String message() default "{constraint.assertFalse}";
    String[] groups() default {};
}</programlisting>
    </example>

    <example>
      <title>@Min constraint</title>

      <programlisting>/**
 * The annotated element must be a number whose value must be greater or
 * equal than the specificed minimum
 * 
 * Supported types are:
 *   - &lt;code&gt;BigDecimal&lt;/code&gt;
 *   - &lt;code&gt;BigInteger&lt;/code&gt;
 *   - &lt;code&gt;Number&lt;/code&gt;
 *   - &lt;code&gt;String&lt;/code&gt; (TODO should we keep it?)
 *   - &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, 
 * &lt;code&gt;double&lt;/code&gt;
 * TODO &lt;code&gt;byte&lt;/code&gt;
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Min {
    String message() default "{constraint.min}";
    String[] groups() default {};

    /**
     * @return Value the element must be higher or equal to
     */
    long value();
}</programlisting>
    </example>

    <example>
      <title>@Max constraint</title>

      <programlisting>/**
 * The annotated element must be a number whose value must be lower or
 * equal than the specificed maximum.
 *
 * Supported types are:
 *   - &lt;code&gt;BigDecimal&lt;/code&gt;
 *   - &lt;code&gt;BigInteger&lt;/code&gt;
 *   - &lt;code&gt;Number&lt;/code&gt;
 *   - &lt;code&gt;String&lt;/code&gt; (TODO should we keep it?)
 *   - &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, 
 * &lt;code&gt;double&lt;/code&gt;
 * TODO &lt;code&gt;byte&lt;/code&gt;
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Max {
    String message() default "{constraint.max}";
    String[] groups() default {};

    /**
     * @return Value the element must be lower or equal to
     */
    long value();
}</programlisting>
    </example>

    <example>
      <title>@Size constraint</title>

      <programlisting>/**
 * The annotated element size must be between the specified boundaries (included).
 *
 * Supported types are:
 *   - &lt;code&gt;String&lt;/code&gt; (string length is evaludated)
 *   - &lt;code&gt;Collection&lt;/code&gt; (collection size is evaluated)
 *   - Array (array length is evaludated)
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Size {
    String message() default "{constraint.size}";
    String[] groups() default {};

    /**
     * @return size the element must be higher or equal to
     */
    int min() default Integer.MIN_VALUE;

    /**
     * @return size the element must be lower or equal to
     */
    int max() default Integer.MAX_VALUE;
}</programlisting>
    </example>

    <example>
      <title>@Digits constraint</title>

      <programlisting>/**
 * The annotated element must be a number within accepted range
 * Supported types are:
 *   - &lt;code&gt;BigDecimal&lt;/code&gt;
 *   - &lt;code&gt;BigInteger&lt;/code&gt;
 *   - &lt;code&gt;Number&lt;/code&gt;
 *   - &lt;code&gt;String&lt;/code&gt; (TODO should we keep it?)
 *   - &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, 
 * &lt;code&gt;double&lt;/code&gt;
 * TODO &lt;code&gt;byte&lt;/code&gt;  
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Digits {
    String message() default "{constraint.digits}";
    String[] groups() default {};

    /**
     * @return maximum number of integral digits accepted for this number
     */
    int integer();

    /**
     * @return maximum number of fractional digits accepted for this numbe
     */
    int fraction();
}</programlisting>
    </example>

    <example>
      <title>@Past constraint</title>

      <programlisting>/**
 * The annotated element must be a date in the past.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type &lt;code&gt;Calendar&lt;/code&gt;
 * is the calendar based on the current timezone and the current locale.
 *
 * TODO what are the implications
 * 
 * Supported types are:
 *  - &lt;code&gt;java.util.Date&lt;/code&gt;
 *  - &lt;code&gt;java.util.Calendar&lt;/code&gt;
 *  - TODO new date/time JSR types?
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Past {
    String message() default "{constraint.past}";
    String[] groups() default {};
}</programlisting>
    </example>

    <example>
      <title>@Future constraint</title>

      <programlisting>/**
 * The annotated element must be a date in the future.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type &lt;code&gt;Calendar&lt;/code&gt;
 * is the calendar based on the current timezone and the current locale.
 *
 * TODO what are the implications
 *
 * Supported types are:
 *  - &lt;code&gt;java.util.Date&lt;/code&gt;
 *  - &lt;code&gt;java.util.Calendar&lt;/code&gt;
 *  - TODO new date/time JSR types?
 *
 * Null elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface Future {
    String message() default "{constraint.future}";
    String[] groups() default {};
}</programlisting>
    </example>

    <para>Built-in annotations are not annotated with
    <classname>@ConstraintValidator</classname> to avoid any dependency
    between the specification API and a specific implementation. Each Bean
    Validation provider must recognize built-in constraint annotations as
    valid constraint definitions and provide a compliant constraint
    implementation for each.</para>

    <warning>
      <para>Add @Like, @AlphaNumerical? other subset of Regexp? Regexp seems
      too generic and not descriptive enough.</para>
    </warning>
  </chapter>

  <chapter>
    <title>XML deployment descriptor</title>

    <section>
      <title></title>

      <para></para>
    </section>
  </chapter>

  <appendix id="terminology">
    <title>Terminology</title>

    <para>This appendix aims at giving an overview on the different specific
    terms used through this specification. There are not to be considered
    formal definitions. Formal definitions are to be inferred from the core
    specification.</para>

    <table>
      <title>terminology</title>

      <tgroup cols="2">
        <colspec align="center" colnum="3" />

        <thead>
          <row>
            <entry>Term</entry>

            <entry colsep="" spanname="">Definition</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Constraint</entry>

            <entry>A restriction on a bean instance, the value of a field or
            the value of a JavaBean property</entry>
          </row>

          <row>
            <entry>Constraint declaration</entry>

            <entry>Assignment of a constraint on a target (bean, field,
            property) for a specific class. Typically by declaring an
            annotation on the target but can also be done through a deployment
            descriptor in XML</entry>
          </row>

          <row>
            <entry>Validation routine</entry>

            <entry><para>Implementation of the validation algorithm associated
            to a given constraint </para><para>also means, sequence of
            operations executed by the Bean Validation provider to validate a
            given object</para></entry>
          </row>

          <row>
            <entry>Constraint definition</entry>

            <entry>Defines a type of constraint, it's attributes and the
            actual constraint implementation. Usually done through
            annotations, this definition can also be done through XML</entry>
          </row>

          <row>
            <entry>group</entry>

            <entry>Constraints can belong to one or more group or context.
            Useful to apply a subset of the constraints for a given use case.
            By default, the <literal>default</literal> group is used.</entry>
          </row>

          <row>
            <entry>group sequence</entry>

            <entry>Define a group ordering in the validation process. If a
            given ordered group contains one or more failure, the following
            ones in the sequence must be ignored.</entry>
          </row>

          <row>
            <entry>Constraint validation</entry>

            <entry>constraint logic algorithm used to determine whether a
            given value passes a constraint or not.</entry>
          </row>

          <row>
            <entry>Constraint validation implementation</entry>

            <entry>Class implementing the constraint logic and used to
            determine whether a given value pass a constraint or not.</entry>
          </row>

          <row>
            <entry>Validation API</entry>

            <entry>Main API used to validate a given type of bean</entry>
          </row>

          <row>
            <entry>Bean validation provider</entry>

            <entry>Implementation of the specification</entry>
          </row>

          <row>
            <entry>Message resolver</entry>

            <entry>Algorithm used to build the end user message associated to
            a constraint failure. Typically useful for i18n</entry>
          </row>

          <row>
            <entry>Constraint repository API</entry>

            <entry>API exposing the constraints applied to a given bean type.
            Also considered one of the integration points with other JSR or
            frameworks.</entry>
          </row>

          <row>
            <entry>javax.validation.Constraint</entry>

            <entry>interface implemented by a constraint validation
            implementation</entry>
          </row>

          <row>
            <entry>Composing constraint</entry>

            <entry>Constraint declared on another constraint definition. When
            the main constraint is validated, the composing constraints are
            validated too.</entry>
          </row>

          <row>
            <entry>javax.validation.Validator</entry>

            <entry>Main interface for the validation API</entry>
          </row>

          <row>
            <entry>javax.validation.ConstraintViolation</entry>

            <entry>interface describing a given constraint failure on a given
            bean</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para></para>
  </appendix>

  <appendix id="standard-resolver-messages">
    <title>Standard resolver messages</title>

    <para>The properties listed below are resolved by the default message
    resolver.</para>

    <programlisting>constraint.null=must be null
constraint.notNull=must not be mull
constraint.assertTrue=assertion failed
constraint.assertFalse=assertion failed
constraint.min=must be greater than or equal to {value}
constraint.max=must be less than or equal to {value}
constraint.size=size must be between {min} and {max}
constraint.digits=numeric value out of bounds (&lt;{integer} digits&gt;.&lt;{fraction} digits&gt; expected)
constraint.past=must be a past date
constraint.future=must be a future date</programlisting>
  </appendix>

  <appendix>
    <title>Proposal for method-level validation</title>

    <para>This is a proposition not yet present in the specification
    officially but that is considered for inclusion.</para>

    <para>A popular demand after the initial draft was to provide a method and
    parameter level validation mechanism reusing the constraint descriptions
    of the specification. This set of APIs is meant to be used by interceptor
    frameworks such as:</para>

    <itemizedlist>
      <listitem>
        <para>application frameworks like Web Beans</para>
      </listitem>

      <listitem>
        <para>component frameworks like Enterprise Java Beans</para>
      </listitem>

      <listitem>
        <para>aspect based frameworks</para>
      </listitem>
    </itemizedlist>

    <para>These framework can call the validation APIs to validate either the
    parameter list or the returned value when a method is called (or more
    precisely around a method invocation).</para>

    <para>This extension of the Bean Validation API allows to reuse the core
    engine as well as the constraint definition and declaration for such
    method level validations.</para>

    <para>The following APIs are added to
    <classname>Validator</classname>.</para>

    <programlisting>public interface Validator {
    // [...]
    
    
    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the method for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt; or if the Object[]
     * does not match the method signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(Class&lt;T&gt; clazz, Method method, Object[] parameterValues,
                                                       String... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the parameterIndex-t parameter of method
     * @param parameterIndex parameter index of the parameter validated in method
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt; or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Method method, Object parameterValue,
                                                   int parameterIndex, String... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose result is validated
     * @param returnedValue the value returned by the method invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateReturnedValue(Class&lt;T&gt; clazz, Method method,
                                                       Object returnedValue, String... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the constructor whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the constructor for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt; or if the Object[]
     * does not match the constructor signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameters(Class&lt;T&gt; clazz, Constructor constructor,
                                                    Object[] parameterValues, String... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the parameterIndex-t parameter of constructor
     * @param parameterIndex parameter index of the parameter validated in constructor
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt; or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Constructor constructor,
                                                   Object parameterValue, int parameterIndex, String... groups);
}</programlisting>

    <para>The constraints declarations evaluated are the constraints hosted on
    the parameters of the method or constructor. If
    <classname>@Valid</classname> is placed on a parameter, the constraints
    declared on the object itself are considered.</para>

    <para><methodname>validateReturnedValue</methodname> evaluates the
    constraints hosted on the method itself. If <classname>@Valid</classname>
    is placed on the method, the constraints declared on the object itself are
    considered.</para>

    <programlisting>public @NotNull String saveItem(@Valid @NotNull Item item, @Max(23) BigDecimal price)</programlisting>

    <para>In the previous example,</para>

    <itemizedlist>
      <listitem>
        <para><literal>item</literal> is validated against
        <classname>@NotNull</classname> and the object is validated by
        <classname>Validator</classname></para>
      </listitem>

      <listitem>
        <para><literal>price</literal> is validated against @Max(23)</para>
      </listitem>

      <listitem>
        <para>the result of <methodname>saveItem</methodname> is validated
        against <classname>@NotNull</classname></para>
      </listitem>
    </itemizedlist>

    <para>Note that the Bean Validation specification does not triggers the
    validation call. An external framework is responsible for calling one of
    the <methodname>validateParameters</methodname>,
    <methodname>validateParameter</methodname> and
    <methodname>validateReturnedValue</methodname> methods at the appropriate
    time.</para>

    <para>For completeness, Bean Validation exposes metadata around method
    validation.</para>

    <programlisting>public interface ParameterDescriptor extends ElementDescriptor { 
    boolean isCascaded(); 
    int getIndex(); 
} 

public interface MethodDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
    boolean isCascaded(); 
} 

public interface ConstructorDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
} 

public interface BeanDescriptor { 
    MethodDescriptor getConstraintsForMethod(Method); 
    MethodDescriptor getConstraintsForConstructor(Constructor); 
    Set&lt;String&gt; getPropertiesWithConstraints(); 
    Set&lt;Method&gt; getMethodsWithConstraints(); 
    Set&lt;Constructor&gt; getConstructorsWithConstraints(); 
} </programlisting>
  </appendix>

  <appendix>
    <title>Proposal for Java Persistence 2.0 integration</title>

    <para>This proposal has been sent to the Java Persistence 2.0 expert group
    for evaluation. It in no way represent the views of the JPA 2.0 expert
    group and is merely here to give a global picture of how Bean Validation
    can be brought to the EE ecosystem.</para>

    <programlisting>Java Persistence / Bean Validation integration proposal

Integration between Java Persistence and Bean Validation (BV) happens at two levels:
- as a metadata provider for DDL generation and generally speaking the behavior of 
the persistence provider
- as a validation engine called on entity changes

This proposal will describe both integration levels.

This proposal imply some familiarity with the Bean Validation latest draft (attached). 
It is better to read it but alternatively you can read the following blogs:
- http://in.relation.to/Bloggers/BeanValidationSneakPeekPartI 
(some parts might be a bit outdated)
- http://in.relation.to/Bloggers/BeanValidationSneakPeekPartIICustomConstraints 
(some parts might be a bit outdated)
- http://in.relation.to/Bloggers/BeanValidationSneakPeekPartIIIGroupsAndPartialValidation 
(some parts might be a bit outdated)
- http://in.relation.to/Bloggers/BeanValidationReferenceImplementationAndBootstrapAPI
- http://in.relation.to/Bloggers/ConstraintCompositionProposalInBeanValidationJSR303


** Metadata provider and DDL generation
* main proposal
Java Persistence consumes Bean Validation (BV) metadata to enhance persistence property 
metadata.

A Persistence provider must use the BV metadata of a given list of groups [1]. 
The default group is "default" (default BV group). The default group can be overridden 
by a JPA property javax.persistence.validation.group.metadata which contains the comma 
separated group names.
Question: should the group be overridable as described?

For each entity and for each persistent property in a given entity:
- extract the list of BV constraints (including the composing constraints [2])
- determine the subset of applicable constraints
- apply these constraints on the persistent property metadata

Specifically:
- @NotNull should be considered equivalent to @Column(nullable=false) / 
@JoinColumn(nullable=false)
- @Size.max should be considered equivalent to @Column.length 
for String properties
- @Digits (which contains integer and fraction) should be considered 
equivalent to @Column.precision = integer+fraction, 
@Column.scale = fraction for decimal columns
The BV annotation metadata should have priority over JPA metadata 
(the reason being JPA has no sensible "unset" values 
on their annotations).
Question: should we add @Unique mapping to @Column(unique=true)? 
@Unique cannot be tested at the Java level reliably. This is not part 
of the BV spec today.

Persistence Provider should optionally recognize and try to apply the 
following constraints as well:
- @Min / @Max on numeric columns (TODO String too?)
- @Future / @Past on temporal columns
- @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model. 
For example, provider ACME might recognize and understand @com.acme.validation.Email 
and apply it to the database model.

While most high level constraints will not be recognize, the BV built-in constraints 
will be the common language spoken by Persistence Providers. Any high level constraint 
can be composed of more modular constraints (constraint composition [2]).

* additional proposition: consider JPA annotations as constraint definitions
Some people have asked for BV to recognize Java Persistence annotations as legit 
constraint definitions. Besides making BV more complex, I am not sure of the 
actual benefit of such an approach. I am even doubtful of the value as a legacy 
migration too. It also raises multiple problems including how to define proper 
error messages and groups. This proposal seems to be a good candidate for BV 
provider extension if a provider is interested.

* additional proposal
In case of a constraint violation report detected and generated by the database 
(not null, etc), the Java persistence provider catches this report and translate 
it into a BV error report. From the perspective of the application, constraint 
errors are viewed through a unified layer. BV must provide some API to create a 
constraint violation error (constraintDescriptor.createConstraintViolation(...)).

While this proposal has a lot of value-add, I wonder how difficult it can be to 
implement this in persistence providers.


** Using the Bean Validation (BV) engine inside a Java Persistence provider

Java Persistence delegates the validation of entities to BV on the following entity events:
- pre persist (an entity must be valid to be inserted in the DB)
- pre update (an entity change must be valid before being propagated to the database)
- pre remove (eg. a Customer still owning some Payments cannot be removed)

These events are called at the same time as their respective callback methods after 
all callbacks have been called.

For each event type, a list of groups [1] is targeted for validation. By default, 
pre persist and pre update events vaildate the group "default" (default BV group) 
and pre remove does not validate any group. Each list can be overridden 
by a JPA property:
- javax.persistence.validation.group.pre-persist for pre persist events
- javax.persistence.validation.group.pre-update for pre update events
- javax.persistence.validation.group.pre-remove for pre remove events

Each property holds the list of targeted groups separated by a comma.

When any of the pre-cited event is raised on an entity instance 'a' of type A, 
the persistence provider must validate 'a' by invoking a validator of type 
Validator with the targeted groups. If the list of targeted groups is empty, 
no validation is performed. If the set of constraint violation is not empty, 
a ValidationException containing a reference to this set of violations is raised.

Question: should we raise the exception at the first invalid object and stop 
(easy way) or should all objects in the PC and expeted to raise a pre-* event 
be passed to the pre-* events and their constraint violations merged into a 
single ValidationException

Question: should ValidationException be defined in JPA or BV?

** Special need from Java Persistence

BV needs to determine if an association can be safely traversed and as such needs 
to know whether or not an entity / property is loaded or lazy. Java Persistence 
should expose a way to determine if a given association is loaded or not.
Because BV must work on detached objects and on objects made of potentially 
multiple EMF, the current approach of hosting these methods on a EMF is limitative.
TODO: A SPI must be defined in BV


** Platform integration
BV metadata APIs and runtime are available from ValidatorFactory instances. It 
is recommended to cache ValidatorFactory instances and retrieve Validator on demand.

A ValidatorFactory is made available at the platform level by the Java EE container 
(at a standardized JNDI location). Alternatively, a ValidationFactory is created by 
the Persistence provider using the standard BV bootstrap approach at JPA initialization 
time. (TODO either approach is viable, we need to chose. The first approach is probably 
slightly better wrt Web Beans integration as we could define a ConstraintFactory that 
understand WB resource resolution).

Out of container, the Persistence provider must use the standard BV bootstrap approach 
at JPA initialization time if a Bean Validation provider is available.

The BV / JPA integration features are enabled by default (provided a Bean Validation 
provider is available in the classpath). It is possible to disable them using
javax.persistence.validation.mode metadata|event|all (should metadata be renamed DDL?)

Such a flag can be defined in META-INF/persistence.xml (JPA level).


[1] http://in.relation.to/Bloggers/BeanValidationSneakPeekPartIIIGroupsAndPartialValidation
[2] http://in.relation.to/Bloggers/ConstraintCompositionProposalInBeanValidationJSR303</programlisting>
  </appendix>

  <appendix>
    <title>Proposal for Java Server Faces 2.0 integration</title>

    <para>This proposal has been built with the help of the Java Server Faces
    2.0 expert group for evaluation. This proposal does not bind the Java
    Server faces 2.0 expert group and is merely here to give a global picture
    of how Bean Validation can be brought to the EE ecosystem.</para>

    <programlisting>Motivation
--------------

To provide bean based validation support in the view layer. This supports the DRY principle. 
The community have trialed this approach for a couple of years with Hibernate Validator 
and Seam or MyFaces extval. As Bean Validation, JSR 303, will be standardized for EE6, 
we propose to introduce changes to better support for delegating validation to an external 
validation framework and explicit support for Bean Validation to JSF2.


Proposal
------------

A) GENERAL CHANGES

1) Add a Boolean property to javax.faces.application.Application, and it's 
corresponding element in faces-config.xml

&lt;validate-empty-fields&gt;false&lt;/validate-empty-fields&gt;

public abstract void setValidateEmptyFields(Boolean boolean);
public abstract Boolean getValidateEmptyFields();

which is by default false. If set to true all submitted fields will have any 
attached validators called, regardless of whether they are empty or not.

BACKWARDS COMPATIBILITY NOTE:

JSF 2 validators must not fail on non-null empty values; for a JSF 1.2 validator 
to work with JSF2 and validate-empty-fields, it must be be safe to use with non-null, 
empty values. If a non-safe validator is used, validate-empty-fields should be set 
to false.

2) Add these elements:

&lt;application&gt;
   &lt;default-validators&gt;
      &lt;validator-id /&gt;

and

public abstract void addDefaultValidatorId(String validatorId);
public abstract Iterable&lt;String&gt; getDefaultValidatorIds();

to javax.faces.application.Application.

The JSF implementation should add the validator to all EditableValueHolders after any 
locally defined validators.

B) SPECIFIC SUPPORT FOR JSR-303

3) Add javax.faces.validator.ModelValidator with id javax.faces.Model. The property 
validationGroups on ModelValidator is used to allow the view designer to specify a 
comma separated list which groups should be validated. If the validationGroups 
attribute is omitted, the default group will be used. If the model validator 
is set as the default validator, this tag can be used to specify validation 
groups for this input.

The ModelValidator requires a version of EL which supports ValueExpression.getBase() 
and ValueExpression.getProperty(). The validate() method should inspect the parent 
EditableValueHolder and discover the ValueExpression specified for the "value" 
attribute, and from it the EL expression's resolved base and property.

The ModelValidator should lazily acquire a copy of javax.validator.ValidatorFactory 
when the validate() method is called; it may keep an application scoped cache of it. 
ValidatorFactory.getValidator(base.getClass()) should be called to get the Validator 
instance, and Validator.validateValue(valueExpression.getProperty(), value, 
validationGroups); called to find any validation errors.

BeanValidator returns multiple validation constraint failures from a single validator, 
whilst JSF is limited to returning a single validation failure; lifting this 
constrain is outside the scope of JSF2, but may be addressed in the future. 
The model validator may take any constraint failure and use it to throw a 
ValidatorException. The FacesMessage created for the ValidatorException 
should have SEVERITY_ERROR, a message summary taken from the validation 
error message taken from the Bean Validation validation error and the 
detail message should be null.

4) Add a &lt;f:validateModel /&gt; tag. When nested in an EditableValueHolder 
this should add the ModelValidator

5) JSR-303 allows the user to validate a graph of objects, JSF will not 
support graph validation.

6) An subtree of components, for example a form, can be validated by directly 
nesting a &lt;f:validateModel /&gt; element. Validating an entire form is especially 
useful if you are not using the ModelValidator as the default validator, or you 
want to set a validationGroup for the entire form. The &lt;f:validateModel /&gt; should 
not render a UIComponent. Any validationGroups specified at this level should be 
used when validating each component in the subtree. Any validationGroups defined 
on &lt;f:validateModel /&gt; nested in an EditableValueHolder take precedence over the 
validationGroups defined for the subtree.

7) If JSF is running in EE then bean validation will be enabled by default. 
An implementation may choose to enable Bean Validation by default in other environments. 
The javax.faces.Model validator will be added to the defaultValidators, 
and validate-empty-fields will be set to true on javax.faces.application.Application.

Emmanuel Bernard will take this to the EE EG.

8) It is possible to disable the default validator for a field/a subtree by 
using the disabled attribute:

&lt;h:inputText ...&gt;
  &lt;f:validateModel disabled="true" /&gt;
&lt;/h:inputText&gt;

This is useful when you are using the ModelValidator as the default validator, 
or validating an entire form

C) AJAX VALIDATION

9 JSF2's Ajax support transparently supports Ajax validation for any JSF validator, 
including the ModelValidator. For example you could enable ajax validation for the 
onBlur event of an input field:

&lt;h:inputText value="#{item.name}"&gt;
   &lt;f:ajaxRequest execute="none" render="none" /&gt;
&lt;/h:inputText&gt;</programlisting>
  </appendix>
</book>